import { ParserRule } from "../types.js";
import { BaseRuleVisitor } from "./rule-utils.js";
class RequireWhitespaceInsideTags extends BaseRuleVisitor {
    visitERBNode(node) {
        const openTag = node.tag_opening;
        const closeTag = node.tag_closing;
        const content = node.content;
        if (!openTag || !closeTag || !content) {
            return;
        }
        const value = content.value;
        if (openTag.value === "<%#") {
            this.checkCommentTagWhitespace(node, openTag, closeTag, value);
        }
        else {
            this.checkOpenTagWhitespace(node, openTag, closeTag, value);
            this.checkCloseTagWhitespace(node, openTag, closeTag, value);
        }
    }
    checkCommentTagWhitespace(node, openTag, closeTag, content) {
        if (!content.startsWith(" ") && !content.startsWith("\n") && !content.startsWith("=")) {
            this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "after-open"
            });
        }
        else if (content.startsWith("=") && content.length > 1 && !content[1].match(/\s/)) {
            this.addOffense(`Add whitespace after \`<%#=\`.`, openTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "after-comment-equals"
            });
        }
        if (!content.endsWith(" ") && !content.endsWith("\n")) {
            this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "before-close"
            });
        }
    }
    checkOpenTagWhitespace(node, openTag, closeTag, content) {
        if (content.startsWith(" ") || content.startsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, {
            node,
            openTag,
            closeTag,
            content,
            fixType: "after-open"
        });
    }
    checkCloseTagWhitespace(node, openTag, closeTag, content) {
        if (content.endsWith(" ") || content.endsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, {
            node,
            openTag,
            closeTag,
            content,
            fixType: "before-close"
        });
    }
}
export class ERBRequireWhitespaceRule extends ParserRule {
    static autocorrectable = true;
    name = "erb-require-whitespace-inside-tags";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new RequireWhitespaceInsideTags(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, fixType } = offense.autofixContext;
        if (!node.content)
            return null;
        const content = node.content.value;
        if (fixType === "before-close") {
            node.content.value = content + " ";
            return result;
        }
        if (fixType === "after-open") {
            node.content.value = " " + content;
            return result;
        }
        if (fixType === "after-comment-equals" && content.startsWith("=")) {
            node.content.value = "= " + content.substring(1);
            return result;
        }
        return null;
    }
}
//# sourceMappingURL=erb-require-whitespace-inside-tags.js.map
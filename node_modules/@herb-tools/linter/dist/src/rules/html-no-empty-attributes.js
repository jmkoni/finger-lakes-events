import { ParserRule } from "../types.js";
import { AttributeVisitorMixin } from "./rule-utils.js";
import { IdentityPrinter } from "@herb-tools/printer";
import { Visitor, isERBOutputNode } from "@herb-tools/core";
const RESTRICTED_ATTRIBUTES = new Set([
    'id',
    'class',
    'name',
    'for',
    'src',
    'href',
    'title',
    'data',
    'role'
]);
function isRestrictedAttribute(attributeName) {
    if (RESTRICTED_ATTRIBUTES.has(attributeName)) {
        return true;
    }
    if (attributeName.startsWith('data-')) {
        return true;
    }
    if (attributeName.startsWith('aria-')) {
        return true;
    }
    return false;
}
function isDataAttribute(attributeName) {
    return attributeName.startsWith('data-');
}
/**
 * Visitor that checks if a node tree contains any output content.
 * Output content includes:
 * - Non-whitespace literal text (LiteralNode)
 * - ERB output tags (<%= %>, <%== %>)
 */
class ContainsOutputContentVisitor extends Visitor {
    hasOutputContent = false;
    visitLiteralNode(node) {
        if (this.hasOutputContent)
            return;
        if (node.content && node.content.trim() !== "") {
            this.hasOutputContent = true;
            return;
        }
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        if (this.hasOutputContent)
            return;
        if (isERBOutputNode(node)) {
            this.hasOutputContent = true;
            return;
        }
        this.visitChildNodes(node);
    }
}
function containsOutputContent(node) {
    const visitor = new ContainsOutputContentVisitor();
    visitor.visit(node);
    return visitor.hasOutputContent;
}
class NoEmptyAttributesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        this.checkEmptyAttribute(attributeName, attributeValue, attributeNode);
    }
    checkDynamicAttributeStaticValue({ combinedName, attributeValue, attributeNode }) {
        const name = (combinedName || "").toLowerCase();
        this.checkEmptyAttribute(name, attributeValue, attributeNode);
    }
    checkEmptyAttribute(attributeName, attributeValue, attributeNode) {
        if (!isRestrictedAttribute(attributeName))
            return;
        if (attributeValue.trim() !== "")
            return;
        if (!attributeNode?.value)
            return;
        if (containsOutputContent(attributeNode.value))
            return;
        const hasExplicitValue = attributeNode.value !== null;
        if (isDataAttribute(attributeName)) {
            if (hasExplicitValue) {
                this.addOffense(`Data attribute \`${attributeName}\` should not have an empty value. Either provide a meaningful value or use \`${attributeName}\` instead of \`${IdentityPrinter.print(attributeNode)}\`.`, attributeNode.location);
            }
            return;
        }
        this.addOffense(`Attribute \`${attributeName}\` must not be empty. Either provide a meaningful value or remove the attribute entirely.`, attributeNode.location);
    }
}
export class HTMLNoEmptyAttributesRule extends ParserRule {
    name = "html-no-empty-attributes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new NoEmptyAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}
//# sourceMappingURL=html-no-empty-attributes.js.map
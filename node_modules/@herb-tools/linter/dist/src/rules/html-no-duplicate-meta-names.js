import { isHTMLElementNode } from "@herb-tools/core";
import { getTagName, getAttributeName, getAttributeValue, forEachAttribute } from "./rule-utils";
import { ControlFlowTrackingVisitor, ControlFlowType } from "./rule-utils";
import { ParserRule } from "../types";
class HTMLNoDuplicateMetaNamesVisitor extends ControlFlowTrackingVisitor {
    elementStack = [];
    documentMetas = [];
    currentBranchMetas = [];
    controlFlowMetas = [];
    visitHTMLElementNode(node) {
        const tagName = getTagName(node)?.toLowerCase();
        if (!tagName)
            return;
        if (tagName === "head") {
            this.documentMetas = [];
            this.currentBranchMetas = [];
            this.controlFlowMetas = [];
        }
        else if (tagName === "meta" && this.insideHead) {
            this.collectAndCheckMetaTag(node);
        }
        this.elementStack.push(tagName);
        this.visitChildNodes(node);
        this.elementStack.pop();
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchMetas: this.currentBranchMetas,
            previousControlFlowMetas: this.controlFlowMetas
        };
        this.currentBranchMetas = [];
        if (!wasAlreadyInControlFlow) {
            this.controlFlowMetas = [];
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowMetas.forEach(meta => this.documentMetas.push(meta));
        }
        this.currentBranchMetas = stateToRestore.previousBranchMetas;
        this.controlFlowMetas = stateToRestore.previousControlFlowMetas;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchMetas: this.currentBranchMetas
        };
        if (this.isInControlFlow) {
            this.currentBranchMetas = [];
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    get insideHead() {
        return this.elementStack.includes("head");
    }
    collectAndCheckMetaTag(node) {
        const metaTag = { node };
        this.extractAttributes(node, metaTag);
        if (!metaTag.nameValue && !metaTag.httpEquivValue)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowMeta(metaTag);
        }
        else {
            this.handleGlobalMeta(metaTag);
        }
        this.currentBranchMetas.push(metaTag);
    }
    extractAttributes(node, metaTag) {
        if (isHTMLElementNode(node) && node.open_tag) {
            forEachAttribute(node.open_tag, (attributeNode) => {
                const name = getAttributeName(attributeNode);
                const value = getAttributeValue(attributeNode)?.trim();
                if (name === "name" && value) {
                    metaTag.nameValue = value;
                }
                else if (name === "http-equiv" && value) {
                    metaTag.httpEquivValue = value;
                }
            });
        }
    }
    handleControlFlowMeta(metaTag) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.checkAgainstMetaList(metaTag, this.currentBranchMetas, "within the same loop iteration");
        }
        else {
            this.checkAgainstMetaList(metaTag, this.currentBranchMetas, "within the same control flow branch");
            this.checkAgainstMetaList(metaTag, this.documentMetas, "");
            this.controlFlowMetas.push(metaTag);
        }
    }
    handleGlobalMeta(metaTag) {
        this.checkAgainstMetaList(metaTag, this.documentMetas, "");
        this.documentMetas.push(metaTag);
    }
    checkAgainstMetaList(metaTag, existingMetas, context) {
        for (const existing of existingMetas) {
            if (this.areMetaTagsDuplicate(metaTag, existing)) {
                const attributeDescription = metaTag.nameValue
                    ? `\`name="${metaTag.nameValue}"\``
                    : `\`http-equiv="${metaTag.httpEquivValue}"\``;
                const attributeType = metaTag.nameValue ? "Meta names" : "`http-equiv` values";
                const contextMsg = context ? ` ${context}` : "";
                this.addOffense(`Duplicate \`<meta>\` tag with ${attributeDescription}${contextMsg}. ${attributeType} should be unique within the \`<head>\` section.`, metaTag.node.location);
                return;
            }
        }
    }
    areMetaTagsDuplicate(meta1, meta2) {
        if (meta1.nameValue && meta2.nameValue) {
            return meta1.nameValue.toLowerCase() === meta2.nameValue.toLowerCase();
        }
        if (meta1.httpEquivValue && meta2.httpEquivValue) {
            return meta1.httpEquivValue.toLowerCase() === meta2.httpEquivValue.toLowerCase();
        }
        return false;
    }
}
export class HTMLNoDuplicateMetaNamesRule extends ParserRule {
    static autocorrectable = false;
    name = "html-no-duplicate-meta-names";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLNoDuplicateMetaNamesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}
//# sourceMappingURL=html-no-duplicate-meta-names.js.map
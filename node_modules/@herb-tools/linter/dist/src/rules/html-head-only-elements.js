import { ParserRule } from "../types";
import { BaseRuleVisitor, getTagName, isHeadOnlyTag, hasAttribute } from "./rule-utils";
class HeadOnlyElementsVisitor extends BaseRuleVisitor {
    elementStack = [];
    visitHTMLElementNode(node) {
        const tagName = getTagName(node)?.toLowerCase();
        if (!tagName)
            return;
        this.checkHeadOnlyElement(node, tagName);
        this.elementStack.push(tagName);
        this.visitChildNodes(node);
        this.elementStack.pop();
    }
    checkHeadOnlyElement(node, tagName) {
        if (this.insideHead)
            return;
        if (!this.insideBody)
            return;
        if (!isHeadOnlyTag(tagName))
            return;
        if (tagName === "title" && this.insideSVG)
            return;
        if (tagName === "meta" && this.hasItempropAttribute(node))
            return;
        this.addOffense(`Element \`<${tagName}>\` must be placed inside the \`<head>\` tag.`, node.location);
    }
    hasItempropAttribute(node) {
        return hasAttribute(node.open_tag, "itemprop");
    }
    get insideHead() {
        return this.elementStack.includes("head");
    }
    get insideBody() {
        return this.elementStack.includes("body");
    }
    get insideSVG() {
        return this.elementStack.includes("svg");
    }
}
export class HTMLHeadOnlyElementsRule extends ParserRule {
    static autocorrectable = false;
    name = "html-head-only-elements";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/*.xml", "**/*.xml.erb"]
        };
    }
    check(result, context) {
        const visitor = new HeadOnlyElementsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}
//# sourceMappingURL=html-head-only-elements.js.map
import { Token, Location, WhitespaceNode } from "@herb-tools/core";
import { ParserRule } from "../types.js";
import { findParent, BaseRuleVisitor } from "./rule-utils.js";
import { filterWhitespaceNodes, isWhitespaceNode, isHTMLOpenTagNode } from "@herb-tools/core";
const MESSAGES = {
    EXTRA_SPACE_NO_SPACE: "Extra space detected where there should be no space.",
    EXTRA_SPACE_SINGLE_SPACE: "Extra space detected where there should be a single space.",
    EXTRA_SPACE_SINGLE_BREAK: "Extra space detected where there should be a single space or a single line break.",
    NO_SPACE_SINGLE_SPACE: "No space detected where there should be a single space.",
};
class HTMLNoSpaceInTagVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        if (node.isSingleLine) {
            this.checkSingleLineTag(node);
        }
        else {
            this.checkMultilineTag(node);
        }
    }
    visitHTMLCloseTagNode(node) {
        this.reportAllWhitespace(node.children, MESSAGES.EXTRA_SPACE_NO_SPACE);
    }
    checkSingleLineTag(node) {
        const { children, tag_closing } = node;
        const isSelfClosing = tag_closing ? this.isSelfClosing(tag_closing) : false;
        this.checkWhitespaceInSingleLineTag(children, isSelfClosing);
        this.checkMissingSpaceBeforeSelfClosing(node, children, isSelfClosing);
    }
    checkWhitespaceInSingleLineTag(children, isSelfClosing) {
        const whitespaceNodes = filterWhitespaceNodes(children);
        whitespaceNodes.forEach((whitespace) => {
            const content = this.getWhitespaceContent(whitespace);
            if (!content)
                return;
            const isLastChild = children[children.length - 1] === whitespace;
            if (isLastChild) {
                this.checkTrailingWhitespace(whitespace, content, isSelfClosing);
                return;
            }
            if (content.length > 1) {
                this.addOffense(MESSAGES.EXTRA_SPACE_SINGLE_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_SINGLE_SPACE });
            }
        });
    }
    checkTrailingWhitespace(whitespace, content, isSelfClosing) {
        if (isSelfClosing && content === ' ')
            return;
        this.addOffense(MESSAGES.EXTRA_SPACE_NO_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_NO_SPACE });
    }
    checkMissingSpaceBeforeSelfClosing(node, children, isSelfClosing) {
        if (!isSelfClosing)
            return;
        const lastChild = children[children.length - 1];
        if (lastChild && isWhitespaceNode(lastChild))
            return;
        const lastNonWhitespace = children.filter(child => !isWhitespaceNode(child)).pop();
        const locationToReport = lastNonWhitespace?.location ?? node.tag_name?.location ?? node.location;
        this.addOffense(MESSAGES.NO_SPACE_SINGLE_SPACE, locationToReport, { node, message: MESSAGES.NO_SPACE_SINGLE_SPACE });
    }
    checkMultilineTag(node) {
        const whitespaceNodes = filterWhitespaceNodes(node.children);
        let previousWhitespace = null;
        whitespaceNodes.forEach((whitespace, index) => {
            const content = this.getWhitespaceContent(whitespace);
            if (!content)
                return;
            if (this.hasConsecutiveNewlines(content, previousWhitespace)) {
                this.addOffense(MESSAGES.EXTRA_SPACE_SINGLE_BREAK, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_SINGLE_BREAK });
                previousWhitespace = whitespace;
                return;
            }
            if (this.isNonNewlineWhitespace(content)) {
                this.checkIndentation(whitespace, index, whitespaceNodes.length, node);
            }
            previousWhitespace = whitespace;
        });
    }
    hasConsecutiveNewlines(content, previousWhitespace) {
        if (content === "\n")
            return previousWhitespace?.value?.value === "\n";
        if (!content.includes("\n"))
            return false;
        const newlines = content.match(/\n/g);
        return (newlines?.length ?? 0) > 1;
    }
    isNonNewlineWhitespace(content) {
        return !content.includes("\n");
    }
    checkIndentation(whitespace, index, totalWhitespaceNodes, node) {
        const isLastWhitespace = index === totalWhitespaceNodes - 1;
        const expectedIndent = isLastWhitespace ? node.location.start.column : node.location.start.column + 2;
        if (whitespace.location.end.column === expectedIndent)
            return;
        this.addOffense(MESSAGES.EXTRA_SPACE_NO_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_NO_SPACE });
    }
    isSelfClosing(tag_closing) {
        return tag_closing?.value?.includes('/') ?? false;
    }
    getWhitespaceContent(whitespace) {
        return whitespace.value?.value ?? null;
    }
    reportAllWhitespace(nodes, message) {
        const whitespaceNodes = Array.isArray(nodes) && nodes.length > 0 && !isWhitespaceNode(nodes[0])
            ? filterWhitespaceNodes(nodes)
            : nodes;
        whitespaceNodes.forEach(whitespace => {
            this.addOffense(message, whitespace.location, { node: whitespace, message });
        });
    }
}
export class HTMLNoSpaceInTagRule extends ParserRule {
    // TODO: enable and fix autofix
    static autocorrectable = false;
    name = "html-no-space-in-tag";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLNoSpaceInTagVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, message } = offense.autofixContext;
        if (!node)
            return null;
        if (isHTMLOpenTagNode(node)) {
            const token = Token.from({ type: "TOKEN_WHITESPACE", value: " ", range: [0, 0], location: Location.zero });
            const whitespace = new WhitespaceNode({ type: "AST_WHITESPACE_NODE", value: token, location: Location.zero, errors: [] });
            node.children.push(whitespace);
            return result;
        }
        if (!isWhitespaceNode(node))
            return null;
        const whitespaceNode = node;
        if (!whitespaceNode.value)
            return null;
        switch (message) {
            case MESSAGES.EXTRA_SPACE_NO_SPACE: {
                let selfClosing = false;
                let beginningOfLine = false;
                const parent = findParent(result.value, node);
                if (parent && isHTMLOpenTagNode(parent)) {
                    selfClosing = parent.tag_closing?.value === "/>";
                    beginningOfLine = node.location.start.column === 0;
                }
                whitespaceNode.value.value = selfClosing && !beginningOfLine ? " " : "";
                return result;
            }
            case MESSAGES.EXTRA_SPACE_SINGLE_BREAK: {
                if (whitespaceNode.value.value.includes("\n")) {
                    whitespaceNode.value.value = "";
                }
                else {
                    whitespaceNode.value.value = " ";
                }
                return result;
            }
            case MESSAGES.EXTRA_SPACE_SINGLE_SPACE:
            case MESSAGES.NO_SPACE_SINGLE_SPACE: {
                whitespaceNode.value.value = " ";
                return result;
            }
            default: return null;
        }
    }
}
//# sourceMappingURL=html-no-space-in-tag.js.map
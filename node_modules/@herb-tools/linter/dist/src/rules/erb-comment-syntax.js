import { BaseRuleVisitor } from "./rule-utils.js";
import { ParserRule } from "../types.js";
class ERBCommentSyntaxVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        const content = node.content?.value || "";
        if (content.match(/^ +#/)) {
            const openingTag = node.tag_opening?.value;
            if (content.includes("herb:disable")) {
                this.addOffense(`Use \`<%#\` instead of \`${openingTag} #\` for \`herb:disable\` directives. Herb directives only work with ERB comment syntax (\`<%# ... %>\`).`, node.location, { node });
            }
            else {
                this.addOffense(`Use \`<%#\` instead of \`${openingTag} #\`. Ruby comments immediately after ERB tags can cause parsing issues.`, node.location, { node });
            }
        }
    }
}
export class ERBCommentSyntax extends ParserRule {
    static autocorrectable = true;
    name = "erb-comment-syntax";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBCommentSyntaxVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node } = offense.autofixContext;
        if (!node.tag_opening)
            return null;
        if (!node.content)
            return null;
        node.tag_opening.value = "<%#";
        const content = node.content.value;
        const match = content.match(/^ +(#)/);
        if (match) {
            node.content.value = content.substring(match[0].length);
        }
        return result;
    }
}
//# sourceMappingURL=erb-comment-syntax.js.map
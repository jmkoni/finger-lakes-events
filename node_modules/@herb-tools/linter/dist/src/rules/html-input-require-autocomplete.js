import { getTagName } from "@herb-tools/core";
import { BaseRuleVisitor, getAttribute, getAttributeValue, getStaticAttributeValueContent } from "./rule-utils.js";
import { ParserRule } from "../types.js";
class HTMLInputRequireAutocompleteVisitor extends BaseRuleVisitor {
    HTML_INPUT_TYPES_REQUIRING_AUTOCOMPLETE = new Set([
        "color",
        "date",
        "datetime-local",
        "email",
        "month",
        "number",
        "password",
        "range",
        "search",
        "tel",
        "text",
        "time",
        "url",
        "week",
    ]);
    visitHTMLOpenTagNode(node) {
        this.checkInputTag(node);
    }
    checkInputTag(node) {
        if (!this.isInputTag(node) || this.hasAutocomplete(node))
            return;
        const typeAttribute = getAttribute(node, "type");
        if (!typeAttribute)
            return;
        const typeValue = getStaticAttributeValueContent(typeAttribute);
        if (!typeValue)
            return;
        if (!this.HTML_INPUT_TYPES_REQUIRING_AUTOCOMPLETE.has(typeValue))
            return;
        this.addOffense("Add an `autocomplete` attribute to improve form accessibility. Use a specific value (e.g., `autocomplete=\"email\"`), `autocomplete=\"on\"` for defaults, or `autocomplete=\"off\"` to disable.", node.location);
    }
    hasAutocomplete(node) {
        const autocompleteAttribute = getAttribute(node, "autocomplete");
        if (!autocompleteAttribute)
            return false;
        const autocompleteValue = getAttributeValue(autocompleteAttribute);
        if (!autocompleteValue)
            return false;
        return true;
    }
    isInputTag(node) {
        const tagName = getTagName(node);
        if (tagName === "input") {
            return true;
        }
        else {
            return false;
        }
    }
}
export class HTMLInputRequireAutocompleteRule extends ParserRule {
    name = "html-input-require-autocomplete";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLInputRequireAutocompleteVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}
//# sourceMappingURL=html-input-require-autocomplete.js.map
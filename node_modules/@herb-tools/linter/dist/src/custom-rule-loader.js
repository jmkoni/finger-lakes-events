import { pathToFileURL } from "url";
import { glob } from "glob";
const DEFAULT_PATTERNS = [
    ".herb/rules/**/*.mjs",
];
/**
 * Loads custom linter rules from the user's project
 */
export class CustomRuleLoader {
    baseDir;
    patterns;
    silent;
    constructor(options = {}) {
        this.baseDir = options.baseDir || process.cwd();
        this.patterns = options.patterns || DEFAULT_PATTERNS;
        this.silent = options.silent || false;
    }
    /**
     * Discovers custom rule files in the project
     */
    async discoverRuleFiles() {
        const allFiles = [];
        for (const pattern of this.patterns) {
            try {
                const files = await glob(pattern, {
                    cwd: this.baseDir,
                    absolute: true,
                    nodir: true
                });
                allFiles.push(...files);
            }
            catch (error) {
                if (!this.silent) {
                    console.warn(`Warning: Failed to search pattern "${pattern}": ${error}`);
                }
            }
        }
        return [...new Set(allFiles)];
    }
    /**
     * Loads a single rule file
     */
    async loadRuleFile(filePath) {
        try {
            const fileUrl = pathToFileURL(filePath).href;
            const cacheBustedUrl = `${fileUrl}?t=${Date.now()}`;
            const module = await import(cacheBustedUrl);
            if (module.default && this.isValidRuleClass(module.default)) {
                return [module.default];
            }
            if (!this.silent) {
                console.warn(`Warning: No valid default export found in "${filePath}". Custom rules must use default export.`);
            }
            return [];
        }
        catch (error) {
            if (!this.silent) {
                console.error(`Error loading rule file "${filePath}": ${error}`);
            }
            return [];
        }
    }
    /**
     * Type guard to check if an export is a valid rule class
     */
    isValidRuleClass(value) {
        if (typeof value !== 'function')
            return false;
        if (!value.prototype)
            return false;
        const instance = new value();
        return typeof instance.check === 'function' && typeof instance.name === 'string';
    }
    /**
     * Loads all custom rules from the project
     */
    async loadRules() {
        const ruleFiles = await this.discoverRuleFiles();
        if (ruleFiles.length === 0) {
            return [];
        }
        const allRules = [];
        for (const filePath of ruleFiles) {
            const rules = await this.loadRuleFile(filePath);
            allRules.push(...rules);
        }
        return allRules;
    }
    /**
     * Loads all custom rules and returns detailed information about each rule
     */
    async loadRulesWithInfo() {
        const ruleFiles = await this.discoverRuleFiles();
        if (ruleFiles.length === 0) {
            return { rules: [], ruleInfo: [], duplicateWarnings: [] };
        }
        const allRules = [];
        const ruleInfo = [];
        const duplicateWarnings = [];
        const seenNames = new Map();
        for (const filePath of ruleFiles) {
            const rules = await this.loadRuleFile(filePath);
            for (const RuleClass of rules) {
                const instance = new RuleClass();
                const ruleName = instance.name;
                if (seenNames.has(ruleName)) {
                    const firstPath = seenNames.get(ruleName);
                    duplicateWarnings.push(`Custom rule "${ruleName}" is defined in multiple files: "${firstPath}" and "${filePath}". The later one will be used.`);
                }
                else {
                    seenNames.set(ruleName, filePath);
                }
                allRules.push(RuleClass);
                ruleInfo.push({
                    name: ruleName,
                    path: filePath
                });
            }
        }
        return { rules: allRules, ruleInfo, duplicateWarnings };
    }
    /**
     * Static helper to check if custom rules exist in a project
     */
    static async hasCustomRules(baseDir = process.cwd()) {
        const loader = new CustomRuleLoader({ baseDir, silent: true });
        const files = await loader.discoverRuleFiles();
        return files.length > 0;
    }
    /**
     * Static helper to load custom rules and merge with default rules
     */
    static async loadAndMergeRules(defaultRules, options = {}) {
        const loader = new CustomRuleLoader(options);
        const customRules = await loader.loadRules();
        return [...defaultRules, ...customRules];
    }
}
//# sourceMappingURL=custom-rule-loader.js.map
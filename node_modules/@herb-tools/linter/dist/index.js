import { getNodesBeforePosition, getNodesAfterPosition, filterNodes, ERBContentNode, isERBOutputNode, Visitor, isToken, isParseResult, getStaticAttributeName, hasDynamicAttributeName as hasDynamicAttributeName$1, getCombinedAttributeName, hasStaticContent, getStaticContentFromNodes, Location, hasERBOutput, isEffectivelyStatic, getValidatableStaticContent, isERBNode, isWhitespaceNode, isCommentNode, isLiteralNode, isHTMLTextNode, Position, filterERBContentNodes, isNode, LiteralNode, didyoumean, filterLiteralNodes, Token, getTagName as getTagName$1, isHTMLElementNode, HTMLCloseTagNode, isHTMLOpenTagNode, WhitespaceNode, filterWhitespaceNodes, HTMLOpenTagNode, isERBCommentNode } from '@herb-tools/core';

class PrintContext {
    output = "";
    indentLevel = 0;
    currentColumn = 0;
    preserveStack = [];
    /**
     * Write text to the output
     */
    write(text) {
        this.output += text;
        this.currentColumn += text.length;
    }
    /**
     * Write text and update column tracking for newlines
     */
    writeWithColumnTracking(text) {
        this.output += text;
        const lines = text.split('\n');
        if (lines.length > 1) {
            this.currentColumn = lines[lines.length - 1].length;
        }
        else {
            this.currentColumn += text.length;
        }
    }
    /**
     * Increase indentation level
     */
    indent() {
        this.indentLevel++;
    }
    /**
     * Decrease indentation level
     */
    dedent() {
        if (this.indentLevel > 0) {
            this.indentLevel--;
        }
    }
    /**
     * Enter a tag that may preserve whitespace
     */
    enterTag(tagName) {
        this.preserveStack.push(tagName.toLowerCase());
    }
    /**
     * Exit the current tag
     */
    exitTag() {
        this.preserveStack.pop();
    }
    /**
     * Check if we're at the start of a line
     */
    isAtStartOfLine() {
        return this.currentColumn === 0;
    }
    /**
     * Get current indentation level
     */
    getCurrentIndentLevel() {
        return this.indentLevel;
    }
    /**
     * Get current column position
     */
    getCurrentColumn() {
        return this.currentColumn;
    }
    /**
     * Get the current tag stack (for debugging)
     */
    getTagStack() {
        return [...this.preserveStack];
    }
    /**
     * Get the complete output string
     */
    getOutput() {
        return this.output;
    }
    /**
     * Reset the context for reuse
     */
    reset() {
        this.output = "";
        this.indentLevel = 0;
        this.currentColumn = 0;
        this.preserveStack = [];
    }
}

/**
 * Default print options used when none are provided
 */
const DEFAULT_PRINT_OPTIONS = {
    ignoreErrors: false
};
class Printer extends Visitor {
    context = new PrintContext();
    /**
     * Static method to print a node without creating an instance
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    static print(input, options = DEFAULT_PRINT_OPTIONS) {
        const printer = new this();
        return printer.print(input, options);
    }
    /**
     * Print a node, token, or parse result to a string
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    print(input, options = DEFAULT_PRINT_OPTIONS) {
        if (!input)
            return "";
        if (isToken(input)) {
            return input.value;
        }
        if (Array.isArray(input)) {
            this.context.reset();
            input.forEach(node => this.visit(node));
            return this.context.getOutput();
        }
        const node = isParseResult(input) ? input.value : input;
        if (options.ignoreErrors === false && node.recursiveErrors().length > 0) {
            throw new Error(`Cannot print the node (${node.type}) since it or any of its children has parse errors. Either pass in a valid Node or call \`print()\` using \`print(node, { ignoreErrors: true })\``);
        }
        this.context.reset();
        this.visit(node);
        return this.context.getOutput();
    }
    write(content) {
        this.context.write(content);
    }
}

/**
 * IdentityPrinter - Provides lossless reconstruction of the original source
 *
 * This printer aims to reconstruct the original input as faithfully as possible,
 * preserving all whitespace, formatting, and structure. It's useful for:
 * - Testing parser accuracy (input should equal output)
 * - Baseline printing before applying transformations
 * - Verifying AST round-trip fidelity
 */
class IdentityPrinter extends Printer {
    static printERBNode(node) {
        const printer = new IdentityPrinter();
        printer.printERBNode(node);
        return printer.context.getOutput();
    }
    visitLiteralNode(node) {
        this.write(node.content);
    }
    visitHTMLTextNode(node) {
        this.write(node.content);
    }
    visitWhitespaceNode(node) {
        if (node.value) {
            this.write(node.value.value);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            this.write(node.tag_name.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLCloseTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            const before = getNodesBeforePosition(node.children, node.tag_name.location.start, true);
            const after = getNodesAfterPosition(node.children, node.tag_name.location.end);
            this.visitAll(before);
            this.write(node.tag_name.value);
            this.visitAll(after);
        }
        else {
            this.visitAll(node.children);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName) {
            this.context.enterTag(tagName);
        }
        if (node.open_tag) {
            this.visit(node.open_tag);
        }
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        if (tagName) {
            this.context.exitTag();
        }
    }
    visitHTMLAttributeNode(node) {
        if (node.name) {
            this.visit(node.name);
        }
        if (node.equals) {
            this.write(node.equals.value);
        }
        if (node.equals && node.value) {
            this.visit(node.value);
        }
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        if (node.quoted && node.open_quote) {
            this.write(node.open_quote.value);
        }
        this.visitChildNodes(node);
        if (node.quoted && node.close_quote) {
            this.write(node.close_quote.value);
        }
    }
    visitHTMLCommentNode(node) {
        if (node.comment_start) {
            this.write(node.comment_start.value);
        }
        this.visitChildNodes(node);
        if (node.comment_end) {
            this.write(node.comment_end.value);
        }
    }
    visitHTMLDoctypeNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitXMLDeclarationNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitCDATANode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitERBContentNode(node) {
        this.printERBNode(node);
    }
    visitERBIfNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.rescue_clause) {
            this.visit(node.rescue_clause);
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.ensure_clause) {
            this.visit(node.ensure_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    /**
     * Print ERB node tags and content
     */
    printERBNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.content) {
            this.write(node.content.value);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
}

const DEFAULT_ERB_TO_RUBY_STRING_OPTIONS = {
    ...DEFAULT_PRINT_OPTIONS,
    forceQuotes: false
};
/**
 * ERBToRubyStringPrinter - Converts ERB snippets to Ruby strings with interpolation
 *
 * This printer transforms ERB templates into Ruby strings by:
 * - Converting literal text to string content
 * - Converting <%= %> tags to #{} interpolation
 * - Converting simple if/else blocks to ternary operators
 * - Ignoring <% %> tags (they don't produce output)
 *
 * Examples:
 * - `hello world <%= hello %>` => `"hello world #{hello}"`
 * - `hello world <% hello %>` => `"hello world "`
 * - `Welcome <%= user.name %>!` => `"Welcome #{user.name}!"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>` => `"logged_in? ? "Welcome" : "Login"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>!` => `"#{logged_in? ? "Welcome" : "Login"}!"`
 */
class ERBToRubyStringPrinter extends IdentityPrinter {
    // TODO: cleanup `.type === "AST_*" checks`
    static print(node, options = DEFAULT_ERB_TO_RUBY_STRING_OPTIONS) {
        const erbNodes = filterNodes([node], ERBContentNode);
        if (erbNodes.length === 1 && isERBOutputNode(erbNodes[0]) && !options.forceQuotes) {
            return (erbNodes[0].content?.value || "").trim();
        }
        if ('children' in node && Array.isArray(node.children)) {
            const childErbNodes = filterNodes(node.children, ERBContentNode);
            const hasOnlyERBContent = node.children.length > 0 && node.children.length === childErbNodes.length;
            if (hasOnlyERBContent && childErbNodes.length === 1 && isERBOutputNode(childErbNodes[0]) && !options.forceQuotes) {
                return (childErbNodes[0].content?.value || "").trim();
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_IF_NODE" && !options.forceQuotes) {
                const ifNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertToTernary(ifNode)) {
                    printer.convertToTernaryWithoutWrapper(ifNode);
                    return printer.context.getOutput();
                }
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_UNLESS_NODE" && !options.forceQuotes) {
                const unlessNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertUnlessToTernary(unlessNode)) {
                    printer.convertUnlessToTernaryWithoutWrapper(unlessNode);
                    return printer.context.getOutput();
                }
            }
        }
        const printer = new ERBToRubyStringPrinter();
        printer.context.write('"');
        printer.visit(node);
        printer.context.write('"');
        return printer.context.getOutput();
    }
    visitHTMLTextNode(node) {
        if (node.content) {
            const escapedContent = node.content.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            this.context.write(escapedContent);
        }
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.context.write("#{");
            if (node.content?.value) {
                this.context.write(node.content.value.trim());
            }
            this.context.write("}");
        }
    }
    visitERBIfNode(node) {
        if (this.canConvertToTernary(node)) {
            this.convertToTernary(node);
        }
    }
    visitERBUnlessNode(node) {
        if (this.canConvertUnlessToTernary(node)) {
            this.convertUnlessToTernary(node);
        }
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    canConvertToTernary(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        const ifOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!ifOnlyText)
            return false;
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE") {
            return node.subsequent.statements
                ? node.subsequent.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertToTernaryWithoutWrapper(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
    canConvertUnlessToTernary(node) {
        const unlessOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!unlessOnlyText)
            return false;
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            return node.else_clause.statements
                ? node.else_clause.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertUnlessToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertUnlessToTernaryWithoutWrapper(node) {
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
}

const balanced = (a, b, str) => {
    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
    const r = ma !== null && mb != null && range(ma, mb, str);
    return (r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + ma.length, r[1]),
        post: str.slice(r[1] + mb.length),
    });
};
const maybeMatch = (reg, str) => {
    const m = str.match(reg);
    return m ? m[0] : null;
};
const range = (a, b, str) => {
    let begs, beg, left, right = undefined, result;
    let ai = str.indexOf(a);
    let bi = str.indexOf(b, ai + 1);
    let i = ai;
    if (ai >= 0 && bi > 0) {
        if (a === b) {
            return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
            if (i === ai) {
                begs.push(i);
                ai = str.indexOf(a, i + 1);
            }
            else if (begs.length === 1) {
                const r = begs.pop();
                if (r !== undefined)
                    result = [r, bi];
            }
            else {
                beg = begs.pop();
                if (beg !== undefined && beg < left) {
                    left = beg;
                    right = bi;
                }
                bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length && right !== undefined) {
            result = [left, right];
        }
    }
    return result;
};

const escSlash = '\0SLASH' + Math.random() + '\0';
const escOpen = '\0OPEN' + Math.random() + '\0';
const escClose = '\0CLOSE' + Math.random() + '\0';
const escComma = '\0COMMA' + Math.random() + '\0';
const escPeriod = '\0PERIOD' + Math.random() + '\0';
const escSlashPattern = new RegExp(escSlash, 'g');
const escOpenPattern = new RegExp(escOpen, 'g');
const escClosePattern = new RegExp(escClose, 'g');
const escCommaPattern = new RegExp(escComma, 'g');
const escPeriodPattern = new RegExp(escPeriod, 'g');
const slashPattern = /\\\\/g;
const openPattern = /\\{/g;
const closePattern = /\\}/g;
const commaPattern = /\\,/g;
const periodPattern = /\\./g;
function numeric(str) {
    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
    return str
        .replace(slashPattern, escSlash)
        .replace(openPattern, escOpen)
        .replace(closePattern, escClose)
        .replace(commaPattern, escComma)
        .replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
    return str
        .replace(escSlashPattern, '\\')
        .replace(escOpenPattern, '{')
        .replace(escClosePattern, '}')
        .replace(escCommaPattern, ',')
        .replace(escPeriodPattern, '.');
}
/**
 * Basically just str.split(","), but handling cases
 * where we have nested braced sections, which should be
 * treated as individual members, like {a,{b,c},d}
 */
function parseCommaParts(str) {
    if (!str) {
        return [''];
    }
    const parts = [];
    const m = balanced('{', '}', str);
    if (!m) {
        return str.split(',');
    }
    const { pre, body, post } = m;
    const p = pre.split(',');
    p[p.length - 1] += '{' + body + '}';
    const postParts = parseCommaParts(post);
    if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
}
function expand(str) {
    if (!str) {
        return [];
    }
    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.slice(0, 2) === '{}') {
        str = '\\{\\}' + str.slice(2);
    }
    return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
    return '{' + str + '}';
}
function isPadded(el) {
    return /^-?0\d/.test(el);
}
function lte(i, y) {
    return i <= y;
}
function gte(i, y) {
    return i >= y;
}
function expand_(str, isTop) {
    /** @type {string[]} */
    const expansions = [];
    const m = balanced('{', '}', str);
    if (!m)
        return [str];
    // no need to expand pre, since it is guaranteed to be free of brace-sets
    const pre = m.pre;
    const post = m.post.length ? expand_(m.post, false) : [''];
    if (/\$$/.test(m.pre)) {
        for (let k = 0; k < post.length; k++) {
            const expansion = pre + '{' + m.body + '}' + post[k];
            expansions.push(expansion);
        }
    }
    else {
        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        const isSequence = isNumericSequence || isAlphaSequence;
        const isOptions = m.body.indexOf(',') >= 0;
        if (!isSequence && !isOptions) {
            // {a},b}
            if (m.post.match(/,(?!,).*\}/)) {
                str = m.pre + '{' + m.body + escClose + m.post;
                return expand_(str);
            }
            return [str];
        }
        let n;
        if (isSequence) {
            n = m.body.split(/\.\./);
        }
        else {
            n = parseCommaParts(m.body);
            if (n.length === 1 && n[0] !== undefined) {
                // x{{a,b}}y ==> x{a}y x{b}y
                n = expand_(n[0], false).map(embrace);
                //XXX is this necessary? Can't seem to hit it in tests.
                /* c8 ignore start */
                if (n.length === 1) {
                    return post.map(p => m.pre + n[0] + p);
                }
                /* c8 ignore stop */
            }
        }
        // at this point, n is the parts, and we know it's not a comma set
        // with a single entry.
        let N;
        if (isSequence && n[0] !== undefined && n[1] !== undefined) {
            const x = numeric(n[0]);
            const y = numeric(n[1]);
            const width = Math.max(n[0].length, n[1].length);
            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;
            let test = lte;
            const reverse = y < x;
            if (reverse) {
                incr *= -1;
                test = gte;
            }
            const pad = n.some(isPadded);
            N = [];
            for (let i = x; test(i, y); i += incr) {
                let c;
                if (isAlphaSequence) {
                    c = String.fromCharCode(i);
                    if (c === '\\') {
                        c = '';
                    }
                }
                else {
                    c = String(i);
                    if (pad) {
                        const need = width - c.length;
                        if (need > 0) {
                            const z = new Array(need + 1).join('0');
                            if (i < 0) {
                                c = '-' + z + c.slice(1);
                            }
                            else {
                                c = z + c;
                            }
                        }
                    }
                }
                N.push(c);
            }
        }
        else {
            N = [];
            for (let j = 0; j < n.length; j++) {
                N.push.apply(N, expand_(n[j], false));
            }
        }
        for (let j = 0; j < N.length; j++) {
            for (let k = 0; k < post.length; k++) {
                const expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion) {
                    expansions.push(expansion);
                }
            }
        }
    }
    return expansions;
}

const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};

// translate the various posix character classes into unicode properties
// this works across all unicode locales
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};

/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link MinimatchOptions.windowsPathsNoEscape} option is used, then
 * square-bracket escapes are removed, but not backslash escapes.
 *
 * For example, it will turn the string `'[*]'` into `*`, but it will not
 * turn `'\\*'` into `'*'`, because `\` is a path separator in
 * `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both square-bracket escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 *
 * When `magicalBraces` is not set, escapes of braces (`{` and `}`) will not be
 * unescaped.
 */
const unescape = (s, { windowsPathsNoEscape = false, magicalBraces = true, } = {}) => {
    if (magicalBraces) {
        return windowsPathsNoEscape
            ? s.replace(/\[([^\/\\])\]/g, '$1')
            : s
                .replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2')
                .replace(/\\([^\/])/g, '$1');
    }
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\{}])\]/g, '$1')
        : s
            .replace(/((?!\\).|^)\[([^\/\\{}])\]/g, '$1$2')
            .replace(/\\([^\/{}])/g, '$1');
};

// parse a single path portion
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark$1 = '[^/]';
// * => any number of characters
const star$1 = qmark$1 + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark$1 + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() &&
                this.isEnd() &&
                !this.#parts.some(s => typeof s !== 'string');
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                unescape(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, unescape(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star$1 +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = parseClass(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                re += noEmpty && glob === '*' ? starNoEmpty : star$1;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark$1;
                hasMagic = true;
                continue;
            }
            re += regExpEscape$1(c);
        }
        return [re, unescape(glob), !!hasMagic, uflag];
    }
}

/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link MinimatchOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 *
 * If the {@link MinimatchOptions.magicalBraces} option is used,
 * then braces (`{` and `}`) will be escaped.
 */
const escape = (s, { windowsPathsNoEscape = false, magicalBraces = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    if (magicalBraces) {
        return windowsPathsNoEscape
            ? s.replace(/[?*()[\]{}]/g, '[$&]')
            : s.replace(/[?*()[\]\\{}]/g, '\\$&');
    }
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};

const minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol('globstar **');
minimatch.GLOBSTAR = GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR,
    });
};
minimatch.defaults = defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return expand(pattern);
};
minimatch.braceExpand = braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // don't need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === GLOBSTAR
                        ? GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR || prev === GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + ')?';
                }
                else if (next !== GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = GLOBSTAR;
                }
            });
            const filtered = pp.filter(p => p !== GLOBSTAR);
            // For partial matches, we need to make the pattern match
            // any prefix of the full path. We do this by generating
            // alternative patterns that match progressively longer prefixes.
            if (this.partial && filtered.length >= 1) {
                const prefixes = [];
                for (let i = 1; i <= filtered.length; i++) {
                    prefixes.push(filtered.slice(0, i).join('/'));
                }
                return '(?:' + prefixes.join('|') + ')';
            }
            return filtered.join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // In partial mode, '/' should always match as it's a valid prefix for any pattern
        if (this.partial) {
            re = '^(?:\\/|' + open + re.slice(1, -1) + close + ')$';
        }
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
/* c8 ignore stop */
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

/**
 * Default configuration for rules when defaultConfig is not specified.
 * Custom rules can omit defaultConfig and will use these defaults.
 */
const DEFAULT_RULE_CONFIG = {
    enabled: true,
    severity: "error",
    exclude: []
};
/**
 * Base class for parser rules.
 */
class ParserRule {
    static type = "parser";
    /** Indicates whether this rule supports autofix. Defaults to false. */
    static autocorrectable = false;
    get defaultConfig() {
        return DEFAULT_RULE_CONFIG;
    }
}
/**
 * Base class for lexer rules.
 */
class LexerRule {
    static type = "lexer";
    /** Indicates whether this rule supports autofix. Defaults to false. */
    static autocorrectable = false;
    get defaultConfig() {
        return DEFAULT_RULE_CONFIG;
    }
}
/**
 * Default context object with all keys defined but set to undefined
 */
const DEFAULT_LINT_CONTEXT = {
    fileName: undefined,
    validRuleNames: undefined,
    ignoredOffensesByLine: undefined,
    ignoreDisableComments: undefined
};
class SourceRule {
    static type = "source";
    /** Indicates whether this rule supports autofix. Defaults to false. */
    static autocorrectable = false;
    get defaultConfig() {
        return DEFAULT_RULE_CONFIG;
    }
}

var ControlFlowType;
(function (ControlFlowType) {
    ControlFlowType[ControlFlowType["CONDITIONAL"] = 0] = "CONDITIONAL";
    ControlFlowType[ControlFlowType["LOOP"] = 1] = "LOOP";
})(ControlFlowType || (ControlFlowType = {}));
/**
 * Base visitor class that provides common functionality for rule visitors
 */
class BaseRuleVisitor extends Visitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        super();
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create an unbound lint offense (without severity).
     * The Linter will bind severity based on the rule's config.
     */
    createOffense(message, location, autofixContext) {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            autofixContext,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, autofixContext) {
        this.offenses.push(this.createOffense(message, location, autofixContext));
    }
}
/**
 * Mixin that adds control flow tracking capabilities to rule visitors
 * This allows rules to track state across different control flow structures
 * like if/else branches, loops, etc.
 *
 * @template TAutofixContext - Type for autofix context (node + custom data)
 * @template TControlFlowState - Type for state passed between onEnterControlFlow and onExitControlFlow
 * @template TBranchState - Type for state passed between onEnterBranch and onExitBranch
 */
class ControlFlowTrackingVisitor extends BaseRuleVisitor {
    isInControlFlow = false;
    currentControlFlowType = null;
    /**
     * Handle visiting a control flow node with proper scope management
     */
    handleControlFlowNode(_node, controlFlowType, visitChildren) {
        const wasInControlFlow = this.isInControlFlow;
        const previousControlFlowType = this.currentControlFlowType;
        this.isInControlFlow = true;
        this.currentControlFlowType = controlFlowType;
        const stateToRestore = this.onEnterControlFlow(controlFlowType, wasInControlFlow);
        visitChildren();
        this.onExitControlFlow(controlFlowType, wasInControlFlow, stateToRestore);
        this.isInControlFlow = wasInControlFlow;
        this.currentControlFlowType = previousControlFlowType;
    }
    /**
     * Handle visiting a branch node (like else, when) with proper scope management
     */
    startNewBranch(visitChildren) {
        const stateToRestore = this.onEnterBranch();
        visitChildren();
        this.onExitBranch(stateToRestore);
    }
    visitERBIfNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBIfNode(node));
    }
    visitERBUnlessNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBUnlessNode(node));
    }
    visitERBCaseNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseNode(node));
    }
    visitERBCaseMatchNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseMatchNode(node));
    }
    visitERBWhileNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBWhileNode(node));
    }
    visitERBForNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBForNode(node));
    }
    visitERBUntilNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBUntilNode(node));
    }
    visitERBBlockNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBBlockNode(node));
    }
    visitERBElseNode(node) {
        this.startNewBranch(() => super.visitERBElseNode(node));
    }
    visitERBWhenNode(node) {
        this.startNewBranch(() => super.visitERBWhenNode(node));
    }
}
/**
 * Gets attributes from an HTMLOpenTagNode
 */
function getAttributes(node) {
    return node.children.filter(node => node.type === "AST_HTML_ATTRIBUTE_NODE");
}
/**
 * Gets the tag name from an HTML tag node (lowercased)
 */
function getTagName(node) {
    if (!node)
        return null;
    return node.tag_name?.value.toLowerCase() || null;
}
/**
 * Gets the attribute name from an HTMLAttributeNode (lowercased)
 * Returns null if the attribute name contains dynamic content (ERB)
 */
function getAttributeName(attributeNode, lowercase = true) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        const staticName = getStaticAttributeName(nameNode);
        if (!lowercase)
            return staticName;
        return staticName ? staticName.toLowerCase() : null;
    }
    return null;
}
/**
 * Checks if an attribute has a dynamic (ERB-containing) name
 */
function hasDynamicAttributeName(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return hasDynamicAttributeName$1(nameNode);
    }
    return false;
}
/**
 * Gets the combined string representation of an attribute name (for debugging)
 * This includes both static content and ERB syntax
 */
function getCombinedAttributeNameString(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return getCombinedAttributeName(nameNode);
    }
    return "";
}
/**
 * Checks if an attribute value contains only static content (no ERB)
 */
function hasStaticAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (!valueNode?.children)
        return false;
    return valueNode.children.every(child => child.type === "AST_LITERAL_NODE");
}
/**
 * Checks if an attribute value contains dynamic content (ERB)
 */
function hasDynamicAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (!valueNode?.children)
        return false;
    return valueNode.children.some(child => child.type === "AST_ERB_CONTENT_NODE");
}
/**
 * Gets the static string value of an attribute (returns null if it contains ERB)
 */
function getStaticAttributeValue(attributeNode) {
    if (!hasStaticAttributeValue(attributeNode))
        return null;
    const valueNode = attributeNode.value;
    const result = valueNode.children
        ?.filter(child => child.type === "AST_LITERAL_NODE")
        .map(child => child.content)
        .join("") || "";
    return result;
}
/**
 * Gets the value nodes array for dynamic inspection
 */
function getAttributeValueNodes(attributeNode) {
    const valueNode = attributeNode.value;
    return valueNode?.children || [];
}
/**
 * Checks if an attribute value contains any static content (for validation purposes)
 */
function hasStaticAttributeValueContent(attributeNode) {
    const valueNodes = getAttributeValueNodes(attributeNode);
    return hasStaticContent(valueNodes);
}
/**
 * Gets the static content of an attribute value (all literal parts combined)
 * Returns the concatenated literal content, or null if no literal nodes exist
 */
function getStaticAttributeValueContent(attributeNode) {
    const valueNodes = getAttributeValueNodes(attributeNode);
    return getStaticContentFromNodes(valueNodes);
}
/**
 * Gets the attribute value content from an HTMLAttributeValueNode
 */
function getAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (valueNode === null)
        return null;
    if (valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE" || !valueNode.children?.length) {
        return null;
    }
    let result = "";
    for (const child of valueNode.children) {
        switch (child.type) {
            case "AST_ERB_CONTENT_NODE": {
                const erbNode = child;
                if (erbNode.content) {
                    result += `${erbNode.tag_opening?.value}${erbNode.content.value}${erbNode.tag_closing?.value}`;
                }
                break;
            }
            case "AST_LITERAL_NODE": {
                result += child.content;
                break;
            }
        }
    }
    return result;
}
/**
 * Checks if an attribute has a value
 */
function hasAttributeValue(attributeNode) {
    return attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Gets the quote type used for an attribute value
 */
function getAttributeValueQuoteType(nodeOrAttribute) {
    let valueNode;
    if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_NODE") {
        const attributeNode = nodeOrAttribute;
        if (attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
            valueNode = attributeNode.value;
        }
    }
    else if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
        valueNode = nodeOrAttribute;
    }
    if (valueNode) {
        if (valueNode.quoted && valueNode.open_quote) {
            return valueNode.open_quote.value === '"' ? "double" : "single";
        }
        return "none";
    }
    return null;
}
/**
 * Finds an attribute by name in a list of attributes
 */
function findAttributeByName(attributes, attributeName) {
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            const attributeNode = child;
            const name = getAttributeName(attributeNode);
            if (name === attributeName.toLowerCase()) {
                return attributeNode;
            }
        }
    }
    return null;
}
/**
 * Checks if a tag has a specific attribute
 */
function hasAttribute(node, attributeName) {
    if (!node)
        return false;
    return getAttribute(node, attributeName) !== null;
}
/**
 * Checks if a tag has a specific attribute
 */
function getAttribute(node, attributeName) {
    const attributes = getAttributes(node);
    return findAttributeByName(attributes, attributeName);
}
/**
 * Common HTML element categorization
 */
const HTML_INLINE_ELEMENTS = new Set([
    "a", "abbr", "acronym", "b", "bdo", "big", "br", "button", "cite", "code",
    "dfn", "em", "i", "img", "input", "kbd", "label", "map", "object", "output",
    "q", "samp", "script", "select", "small", "span", "strong", "sub", "sup",
    "textarea", "time", "tt", "var"
]);
const HTML_BLOCK_ELEMENTS = new Set([
    "address", "article", "aside", "blockquote", "canvas", "dd", "div", "dl",
    "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2",
    "h3", "h4", "h5", "h6", "header", "hr", "li", "main", "nav", "noscript",
    "ol", "p", "pre", "section", "table", "tfoot", "ul", "video"
]);
const HTML_VOID_ELEMENTS = new Set([
    "area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta",
    "param", "source", "track", "wbr",
]);
const HTML_BOOLEAN_ATTRIBUTES = new Set([
    "autofocus", "autoplay", "checked", "controls", "defer", "disabled", "hidden",
    "loop", "multiple", "muted", "readonly", "required", "reversed", "selected",
    "open", "default", "formnovalidate", "novalidate", "itemscope", "scoped",
    "seamless", "allowfullscreen", "async", "compact", "declare", "nohref",
    "noresize", "noshade", "nowrap", "sortable", "truespeed", "typemustmatch"
]);
const HEADING_TAGS = new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
/**
 * SVG elements that use camelCase naming
 */
const SVG_CAMEL_CASE_ELEMENTS = new Set([
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
]);
/**
 * Mapping from lowercase SVG element names to their correct camelCase versions
 * Generated dynamically from SVG_CAMEL_CASE_ELEMENTS
 */
const SVG_LOWERCASE_TO_CAMELCASE = new Map(Array.from(SVG_CAMEL_CASE_ELEMENTS).map(element => [element.toLowerCase(), element]));
const VALID_ARIA_ROLES = new Set([
    "banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search",
    "article", "cell", "columnheader", "definition", "directory", "document", "feed", "figure",
    "group", "heading", "img", "list", "listitem", "math", "none", "note", "presentation",
    "row", "rowgroup", "rowheader", "separator", "table", "term", "tooltip",
    "alert", "alertdialog", "button", "checkbox", "combobox", "dialog", "grid", "gridcell", "link",
    "listbox", "menu", "menubar", "menuitem", "menuitemcheckbox", "menuitemradio", "option",
    "progressbar", "radio", "radiogroup", "scrollbar", "searchbox", "slider", "spinbutton",
    "status", "switch", "tab", "tablist", "tabpanel", "textbox", "timer", "toolbar", "tree",
    "treegrid", "treeitem",
    "log", "marquee"
]);
const ARIA_ATTRIBUTES = new Set([
    'aria-activedescendant',
    'aria-atomic',
    'aria-autocomplete',
    'aria-busy',
    'aria-checked',
    'aria-colcount',
    'aria-colindex',
    'aria-colspan',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-disabled',
    'aria-dropeffect',
    'aria-errormessage',
    'aria-expanded',
    'aria-flowto',
    'aria-grabbed',
    'aria-haspopup',
    'aria-hidden',
    'aria-invalid',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-level',
    'aria-live',
    'aria-modal',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-owns',
    'aria-placeholder',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-roledescription',
    'aria-rowcount',
    'aria-rowindex',
    'aria-rowspan',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
]);
/**
 * Helper function to create a location at the end of the source with a 1-character range
 */
function createEndOfFileLocation(source) {
    const lines = source.split('\n');
    const lastLineNumber = lines.length;
    const lastLine = lines[lines.length - 1];
    const lastColumnNumber = lastLine.length;
    const startColumn = lastColumnNumber > 0 ? lastColumnNumber - 1 : 0;
    return Location.from(lastLineNumber, startColumn, lastLineNumber, lastColumnNumber);
}
/**
 * Checks if an element is inline
 */
function isInlineElement(tagName) {
    return HTML_INLINE_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an element is block-level
 */
function isBlockElement(tagName) {
    return HTML_BLOCK_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an element is a void element
 */
function isVoidElement(tagName) {
    return HTML_VOID_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an attribute is a boolean attribute
 */
function isBooleanAttribute(attributeName) {
    return HTML_BOOLEAN_ATTRIBUTES.has(attributeName.toLowerCase());
}
/**
 * Attribute visitor that provides granular processing based on both
 * attribute name type (static/dynamic) and value type (static/dynamic)
 *
 * This gives you 4 distinct methods to override:
 * - checkStaticAttributeStaticValue()   - name="class" value="foo"
 * - checkStaticAttributeDynamicValue()  - name="class" value="<%= css_class %>"
 * - checkDynamicAttributeStaticValue()  - name="data-<%= key %>" value="foo"
 * - checkDynamicAttributeDynamicValue() - name="data-<%= key %>" value="<%= value %>"
 */
class AttributeVisitorMixin extends BaseRuleVisitor {
    constructor(ruleName, context) {
        super(ruleName, context);
    }
    visitHTMLOpenTagNode(node) {
        this.checkAttributesOnNode(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAttributesOnNode(node) {
        forEachAttribute(node, (attributeNode) => {
            const staticAttributeName = getAttributeName(attributeNode);
            const originalAttributeName = getAttributeName(attributeNode, false) || "";
            const isDynamicName = hasDynamicAttributeName(attributeNode);
            const staticAttributeValue = getStaticAttributeValue(attributeNode);
            const valueNodes = getAttributeValueNodes(attributeNode);
            const hasOutputERB = hasERBOutput(valueNodes);
            const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
            if (staticAttributeName && staticAttributeValue !== null) {
                this.checkStaticAttributeStaticValue({
                    attributeName: staticAttributeName,
                    attributeValue: staticAttributeValue,
                    attributeNode,
                    originalAttributeName,
                    parentNode: node
                });
            }
            else if (staticAttributeName && isEffectivelyStaticValue && !hasOutputERB) {
                const validatableContent = getValidatableStaticContent(valueNodes) || "";
                this.checkStaticAttributeStaticValue({ attributeName: staticAttributeName, attributeValue: validatableContent, attributeNode, originalAttributeName, parentNode: node });
            }
            else if (staticAttributeName && hasOutputERB) {
                const combinedValue = getAttributeValue(attributeNode);
                this.checkStaticAttributeDynamicValue({ attributeName: staticAttributeName, valueNodes, attributeNode, parentNode: node, originalAttributeName, combinedValue });
            }
            else if (isDynamicName && staticAttributeValue !== null) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                this.checkDynamicAttributeStaticValue({ nameNodes, attributeValue: staticAttributeValue, attributeNode, parentNode: node, combinedName });
            }
            else if (isDynamicName) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                const combinedValue = getAttributeValue(attributeNode);
                this.checkDynamicAttributeDynamicValue({ nameNodes, valueNodes, attributeNode, parentNode: node, combinedName, combinedValue });
            }
        });
    }
    /**
     * Static attribute name with static value: class="container"
     */
    checkStaticAttributeStaticValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Static attribute name with dynamic value: class="<%= css_class %>"
     */
    checkStaticAttributeDynamicValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with static value: data-<%= key %>="foo"
     */
    checkDynamicAttributeStaticValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with dynamic value: data-<%= key %>="<%= value %>"
     */
    checkDynamicAttributeDynamicValue(_params) {
        // Default implementation does nothing
    }
}
/**
 * Checks if an attribute value is quoted
 */
function isAttributeValueQuoted(attributeNode) {
    if (attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
        const valueNode = attributeNode.value;
        return !!valueNode.quoted;
    }
    return false;
}
/**
 * Iterates over all attributes of a tag node, calling the callback for each attribute
 */
function forEachAttribute(node, callback) {
    const attributes = getAttributes(node);
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            callback(child);
        }
    }
}
/**
 * Base lexer visitor class that provides common functionality for lexer-based rule visitors
 */
class BaseLexerRuleVisitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create an unbound lint offense (without severity).
     * The Linter will bind severity based on the rule's config.
     */
    createOffense(message, location, autofixContext) {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            autofixContext,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, autofixContext) {
        this.offenses.push(this.createOffense(message, location, autofixContext));
    }
    /**
     * Main entry point for lexer rule visitors
     * @param lexResult - The lexer result containing tokens and source
     */
    visit(lexResult) {
        this.visitTokens(lexResult.value.tokens);
    }
    /**
     * Visit all tokens
     * Override this method to implement token-level checks
     */
    visitTokens(tokens) {
        for (const token of tokens) {
            this.visitToken(token);
        }
    }
    /**
     * Visit individual tokens
     * Override this method to implement per-token checks
     */
    visitToken(_token) {
        // Default implementation does nothing
    }
}
/**
 * Base source visitor class that provides common functionality for source-based rule visitors
 */
class BaseSourceRuleVisitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create an unbound lint offense (without severity).
     * The Linter will bind severity based on the rule's config.
     */
    createOffense(message, location, autofixContext) {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            autofixContext,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, autofixContext) {
        this.offenses.push(this.createOffense(message, location, autofixContext));
    }
    /**
     * Main entry point for source rule visitors
     * @param source - The raw source code
     */
    visit(source) {
        this.visitSource(source);
    }
}
/**
 * Autofix utilities for applying string replacements
 */
/**
 * Checks if two locations are equal
 * @param a - First location
 * @param b - Second location
 * @returns true if locations are equal
 */
function locationsEqual(a, b) {
    return a.start.line === b.start.line &&
        a.start.column === b.start.column &&
        a.end.line === b.end.line &&
        a.end.column === b.end.column;
}
/**
 * Finds a node in the AST that has a specific location
 * Uses direct recursive traversal for reliability
 * @param root - The root node to search from
 * @param location - The location to match
 * @param predicate - Optional predicate function to filter nodes (e.g., isERBNode)
 * @returns The matching node or null if not found
 */
function findNodeByLocation(root, location, predicate) {
    const visited = new Set();
    function search(node) {
        if (!node || visited.has(node))
            return null;
        visited.add(node);
        if (node.location && locationsEqual(node.location, location)) {
            if (!predicate || predicate(node)) {
                return node;
            }
        }
        const propsToCheck = ['tag_opening', 'tag_closing', 'tag_name', 'name', 'equals', 'value', 'content'];
        for (const prop of propsToCheck) {
            if (node[prop]?.location && locationsEqual(node[prop].location, location)) {
                if (!predicate || predicate(node)) {
                    return node;
                }
            }
        }
        if (typeof node.compactChildNodes === 'function') {
            for (const child of node.compactChildNodes()) {
                const found = search(child);
                if (found)
                    return found;
            }
        }
        else {
            if (node.children && Array.isArray(node.children)) {
                for (const child of node.children) {
                    const found = search(child);
                    if (found)
                        return found;
                }
            }
            if (node.body && Array.isArray(node.body)) {
                for (const child of node.body) {
                    const found = search(child);
                    if (found)
                        return found;
                }
            }
        }
        return null;
    }
    return search(root);
}
/**
 * AST Navigation Utilities
 * These utilities help navigate the AST tree for complex autofix operations
 */
/**
 * Finds the parent node of a given child node in the AST
 * @param root - The root node to search from (typically the document node)
 * @param target - The child node to find the parent of
 * @returns The parent node, or null if not found
 *
 * @example
 * const parent = findParent(result.value, offense.autofixContext.node)
 * if (parent?.type === "AST_HTML_ELEMENT_NODE") {
 *   // Modify parent...
 * }
 */
function findParent(root, target) {
    let parentNode = null;
    const search = (node, _parent = null) => {
        if (parentNode)
            return;
        const nodeAny = node;
        if (nodeAny.children) {
            for (const child of nodeAny.children) {
                if (child === target) {
                    parentNode = node;
                    return;
                }
            }
        }
        const propsToCheck = ['open_tag', 'close_tag', 'body', 'name', 'value'];
        for (const prop of propsToCheck) {
            const value = node[prop];
            if (value === target) {
                parentNode = node;
                return;
            }
            if (Array.isArray(value) && value.includes(target)) {
                parentNode = node;
                return;
            }
        }
        if (nodeAny.children) {
            for (const child of nodeAny.children) {
                search(child, node);
                if (parentNode)
                    return;
            }
        }
        for (const prop of propsToCheck) {
            const value = node[prop];
            if (Array.isArray(value)) {
                for (const item of value) {
                    if (item && typeof item === 'object' && 'type' in item) {
                        search(item, node);
                        if (parentNode)
                            return;
                    }
                }
            }
            else if (value && typeof value === 'object' && 'type' in value) {
                search(value, node);
                if (parentNode)
                    return;
            }
        }
    };
    search(root);
    return parentNode;
}
const DOCUMENT_ONLY_TAG_NAMES = new Set([
    "html"
]);
const HTML_ONLY_TAG_NAMES = new Set([
    "head", "body"
]);
const HEAD_ONLY_TAG_NAMES = new Set([
    "base",
    "title",
    "style",
    "meta",
    "link",
]);
const HEAD_AND_BODY_TAG_NAMES = new Set([
    "script",
    "noscript",
    "template",
]);
function isDocumentOnlyTag(tagName) {
    return DOCUMENT_ONLY_TAG_NAMES.has(tagName.toLowerCase());
}
function isHtmlOnlyTag(tagName) {
    return HTML_ONLY_TAG_NAMES.has(tagName.toLowerCase());
}
function isHeadOnlyTag(tagName) {
    return HEAD_ONLY_TAG_NAMES.has(tagName.toLowerCase());
}
function isHeadAndBodyTag(tagName) {
    return HEAD_AND_BODY_TAG_NAMES.has(tagName.toLowerCase());
}
function isBodyOnlyTag(tagName) {
    const tag = tagName.toLowerCase();
    return (!isDocumentOnlyTag(tag) &&
        !isHtmlOnlyTag(tag) &&
        !isHeadOnlyTag(tag) &&
        !isHeadAndBodyTag(tag));
}
function isBodyTag(tagName) {
    const tag = tagName.toLowerCase();
    return (!isDocumentOnlyTag(tag) &&
        !isHtmlOnlyTag(tag) &&
        (isBodyOnlyTag(tag) || isHeadAndBodyTag(tag)));
}
function isHeadTag(tagName) {
    const tag = tagName.toLowerCase();
    return (!isDocumentOnlyTag(tag) &&
        !isHtmlOnlyTag(tag) &&
        (isHeadOnlyTag(tag) || isHeadAndBodyTag(tag)));
}

class ERBCommentSyntaxVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        const content = node.content?.value || "";
        if (content.match(/^ +#/)) {
            const openingTag = node.tag_opening?.value;
            if (content.includes("herb:disable")) {
                this.addOffense(`Use \`<%#\` instead of \`${openingTag} #\` for \`herb:disable\` directives. Herb directives only work with ERB comment syntax (\`<%# ... %>\`).`, node.location, { node });
            }
            else {
                this.addOffense(`Use \`<%#\` instead of \`${openingTag} #\`. Ruby comments immediately after ERB tags can cause parsing issues.`, node.location, { node });
            }
        }
    }
}
class ERBCommentSyntax extends ParserRule {
    static autocorrectable = true;
    name = "erb-comment-syntax";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBCommentSyntaxVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node } = offense.autofixContext;
        if (!node.tag_opening)
            return null;
        if (!node.content)
            return null;
        node.tag_opening.value = "<%#";
        const content = node.content.value;
        const match = content.match(/^ +(#)/);
        if (match) {
            node.content.value = content.substring(match[0].length);
        }
        return result;
    }
}

class ERBNoCaseNodeChildrenVisitor extends BaseRuleVisitor {
    visitERBCaseNode(node) {
        this.checkCaseNodeChildren(node, "when");
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.checkCaseNodeChildren(node, "in");
        this.visitChildNodes(node);
    }
    checkCaseNodeChildren(node, type) {
        if (!node.children || node.children.length === 0)
            return;
        const caseCode = IdentityPrinter.printERBNode(node);
        const firstCondition = node.conditions?.[0];
        const conditionCode = firstCondition && isERBNode(firstCondition) ? IdentityPrinter.printERBNode(firstCondition) : `<% ${type} ... %>`;
        for (const child of node.children) {
            if (!this.isAllowedContent(child)) {
                const childCode = IdentityPrinter.print(child).trim();
                this.addOffense(`Do not place \`${childCode}\` between \`${caseCode}\` and \`${conditionCode}\`. Content here is not part of any branch and will not be rendered.`, child.location);
            }
        }
    }
    isAllowedContent(node) {
        if (isWhitespaceNode(node))
            return true;
        if (isCommentNode(node))
            return true;
        if (isLiteralNode(node) || isHTMLTextNode(node)) {
            return /^\s*$/.test(node.content);
        }
        return false;
    }
}
class ERBNoCaseNodeChildrenRule extends ParserRule {
    name = "erb-no-case-node-children";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoCaseNodeChildrenVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoEmptyTagsVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        this.visitChildNodes(node);
        const { content, tag_closing } = node;
        if (!content)
            return;
        if (tag_closing?.value === "")
            return;
        if (content.value.trim().length > 0)
            return;
        this.addOffense("ERB tag should not be empty. Remove empty ERB tags or add content.", node.location);
    }
}
class ERBNoEmptyTagsRule extends ParserRule {
    name = "erb-no-empty-tags";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoEmptyTagsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

function positionFromOffset(source, offset) {
    let line = 1;
    let column = 0;
    let currentOffset = 0;
    for (let i = 0; i < source.length && currentOffset < offset; i++) {
        const char = source[i];
        currentOffset++;
        if (char === "\n") {
            line++;
            column = 0;
        }
        else {
            column++;
        }
    }
    return new Position(line, column);
}
class ERBNoExtraNewLineVisitor extends BaseSourceRuleVisitor {
    visitSource(source) {
        if (source.length === 0)
            return;
        const regex = /\n{4,}/g;
        let match;
        while ((match = regex.exec(source)) !== null) {
            const startOffset = match.index + 3;
            const endOffset = match.index + match[0].length;
            const start = positionFromOffset(source, startOffset);
            const end = positionFromOffset(source, endOffset);
            const location = new Location(start, end);
            const extraLines = match[0].length - 3;
            this.addOffense(`Extra blank line detected. Remove ${extraLines} blank ${extraLines === 1 ? "line" : "lines"} to maintain consistent spacing (max 2 allowed).`, location, {
                node: null,
                startOffset,
                endOffset
            });
        }
    }
}
class ERBNoExtraNewLineRule extends SourceRule {
    static autocorrectable = true;
    name = "erb-no-extra-newline";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(source, context) {
        const visitor = new ERBNoExtraNewLineVisitor(this.name, context);
        visitor.visit(source);
        return visitor.offenses;
    }
    autofix(offense, source, _context) {
        if (!offense.autofixContext)
            return null;
        const { startOffset, endOffset } = offense.autofixContext;
        const before = source.substring(0, startOffset);
        const after = source.substring(endOffset);
        return before + after;
    }
}

class ERBNoExtraWhitespaceInsideTagsVisitor extends BaseRuleVisitor {
    visitERBNode(node) {
        const openTag = node.tag_opening;
        const closeTag = node.tag_closing;
        const { value } = node.content ?? {};
        if (!openTag || !closeTag || !value)
            return;
        if (this.hasExtraLeadingWhitespace(value)) {
            this.reportWhitespace(node, openTag, closeTag, value, "start", 0, `Remove extra whitespace after \`${openTag.value}\`.`, "after-open");
        }
        if (openTag.value === "<%#" && value.startsWith("=") && value.length > 1) {
            const afterEquals = value.substring(1);
            if (afterEquals.match(/^\s{2,}/) && !afterEquals.startsWith("  \n") && !afterEquals.startsWith("\n")) {
                this.reportWhitespace(node, openTag, closeTag, value, "start", 1, `Remove extra whitespace after \`<%#=\`.`, "after-comment-equals");
            }
        }
        if (this.hasExtraTrailingWhitespace(value)) {
            this.reportWhitespace(node, openTag, closeTag, value, "end", 0, `Remove extra whitespace before \`${closeTag.value}\`.`, "before-close");
        }
    }
    hasExtraLeadingWhitespace(content) {
        return content.startsWith("  ") && !content.startsWith("  \n");
    }
    hasExtraTrailingWhitespace(content) {
        return !content.includes("\n") && /\s{2,}$/.test(content);
    }
    getWhitespaceLocation(node, content, position, offset = 0) {
        const contentLocation = node.content.location;
        if (position === "start") {
            const match = content.substring(offset).match(/^\s+/);
            const length = match ? match[0].length : 0;
            const startColumn = contentLocation.start.column + offset;
            return Location.from(contentLocation.start.line, startColumn, contentLocation.start.line, startColumn + length);
        }
        else {
            const match = content.match(/\s+$/);
            const length = match ? match[0].length : 0;
            return Location.from(contentLocation.end.line, contentLocation.end.column - length, contentLocation.end.line, contentLocation.end.column);
        }
    }
    reportWhitespace(node, openTag, closeTag, content, position, offset, message, fixType) {
        const location = this.getWhitespaceLocation(node, content, position, offset);
        this.addOffense(message, location, {
            node,
            openTag,
            closeTag,
            content,
            fixType
        });
    }
}
class ERBNoExtraWhitespaceRule extends ParserRule {
    static autocorrectable = true;
    name = "erb-no-extra-whitespace-inside-tags";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoExtraWhitespaceInsideTagsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, fixType } = offense.autofixContext;
        if (!node.content)
            return null;
        const content = node.content.value;
        switch (fixType) {
            case "before-close":
                node.content.value = content.replace(/\s{2,}$/, " ");
                break;
            case "after-open":
                node.content.value = content.replace(/^\s{2,}/, " ");
                break;
            case "after-comment-equals":
                if (content.startsWith("=")) {
                    const afterEquals = content.substring(1);
                    node.content.value = "= " + afterEquals.replace(/^\s{2,}/, "");
                }
                break;
            default:
                return null;
        }
        return result;
    }
}

class ERBNoOutputControlFlowRuleVisitor extends BaseRuleVisitor {
    visitERBIfNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    checkOutputControlFlow(controlBlock) {
        const openTag = controlBlock.tag_opening;
        if (!openTag) {
            return;
        }
        if (openTag.value === "<%=") {
            let controlBlockType = controlBlock.type;
            if (controlBlock.type === "AST_ERB_IF_NODE")
                controlBlockType = "if";
            if (controlBlock.type === "AST_ERB_ELSE_NODE")
                controlBlockType = "else";
            if (controlBlock.type === "AST_ERB_END_NODE")
                controlBlockType = "end";
            if (controlBlock.type === "AST_ERB_UNLESS_NODE")
                controlBlockType = "unless";
            this.addOffense(`Control flow statements like \`${controlBlockType}\` should not be used with output tags. Use \`<% ${controlBlockType} ... %>\` instead.`, openTag.location);
        }
        return;
    }
}
class ERBNoOutputControlFlowRule extends ParserRule {
    name = "erb-no-output-control-flow";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoOutputControlFlowRuleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoSilentTagInAttributeNameVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNameNode(node) {
        const erbNodes = filterERBContentNodes(node.children);
        const silentNodes = erbNodes.filter(this.isSilentERBTag);
        for (const node of silentNodes) {
            this.addOffense(`Remove silent ERB tag from HTML attribute name. Silent ERB tags (\`${node.tag_opening?.value}\`) do not output content and should not be used in attribute names.`, node.location);
        }
    }
    // TODO: might be worth to extract
    isSilentERBTag(node) {
        const silentTags = ["<%", "<%-", "<%#"];
        return silentTags.includes(node.tag_opening?.value || "");
    }
}
class ERBNoSilentTagInAttributeNameRule extends ParserRule {
    name = "erb-no-silent-tag-in-attribute-name";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoSilentTagInAttributeNameVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBPreferImageTagHelperVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(openTag) {
        const tagName = getTagName(openTag);
        if (tagName !== "img")
            return;
        const attributes = getAttributes(openTag);
        const srcAttribute = findAttributeByName(attributes, "src");
        if (!srcAttribute)
            return;
        if (!srcAttribute.value)
            return;
        const node = srcAttribute.value;
        const hasERBContent = this.containsERBContent(node);
        if (hasERBContent) {
            if (this.isDataUri(node))
                return;
            if (this.shouldFlagAsImageTagCandidate(node)) {
                const suggestedExpression = this.buildSuggestedExpression(node);
                this.addOffense(`Prefer \`image_tag\` helper over manual \`<img>\` with dynamic ERB expressions. Use \`<%= image_tag ${suggestedExpression}, alt: "..." %>\` instead.`, srcAttribute.location);
            }
        }
    }
    containsERBContent(node) {
        return filterNodes(node.children, ERBContentNode).length > 0;
    }
    isOnlyERBContent(node) {
        return node.children.length > 0 && node.children.length === filterNodes(node.children, ERBContentNode).length;
    }
    getContentofFirstChild(node) {
        if (!node.children || node.children.length === 0)
            return "";
        const firstChild = node.children[0];
        if (isNode(firstChild, LiteralNode)) {
            return (firstChild.content || "").trim();
        }
        return "";
    }
    isDataUri(node) {
        return this.getContentofFirstChild(node).startsWith("data:");
    }
    isFullUrl(node) {
        const content = this.getContentofFirstChild(node);
        return content.startsWith("http://") || content.startsWith("https://");
    }
    shouldFlagAsImageTagCandidate(node) {
        if (this.isOnlyERBContent(node))
            return true;
        if (this.isFullUrl(node))
            return false;
        return true;
    }
    buildSuggestedExpression(node) {
        if (!node.children)
            return "expression";
        try {
            return ERBToRubyStringPrinter.print(node, { ignoreErrors: false });
        }
        catch {
            return "expression";
        }
    }
}
class ERBPreferImageTagHelperRule extends ParserRule {
    name = "erb-prefer-image-tag-helper";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new ERBPreferImageTagHelperVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBRequireTrailingNewlineVisitor extends BaseSourceRuleVisitor {
    visitSource(source) {
        if (source.length === 0)
            return;
        if (!this.context.fileName)
            return;
        if (!source.endsWith('\n')) {
            this.addOffense("File must end with trailing newline.", createEndOfFileLocation(source));
        }
        else if (source.endsWith('\n\n')) {
            this.addOffense("File must end with exactly one trailing newline.", createEndOfFileLocation(source));
        }
    }
}
class ERBRequireTrailingNewlineRule extends SourceRule {
    static autocorrectable = true;
    name = "erb-require-trailing-newline";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(source, context) {
        const visitor = new ERBRequireTrailingNewlineVisitor(this.name, context);
        visitor.visit(source);
        return visitor.offenses;
    }
    autofix(_offense, source, _context) {
        return source.trimEnd() + "\n";
    }
}

class RequireWhitespaceInsideTags extends BaseRuleVisitor {
    visitERBNode(node) {
        const openTag = node.tag_opening;
        const closeTag = node.tag_closing;
        const content = node.content;
        if (!openTag || !closeTag || !content) {
            return;
        }
        const value = content.value;
        if (openTag.value === "<%#") {
            this.checkCommentTagWhitespace(node, openTag, closeTag, value);
        }
        else {
            this.checkOpenTagWhitespace(node, openTag, closeTag, value);
            this.checkCloseTagWhitespace(node, openTag, closeTag, value);
        }
    }
    checkCommentTagWhitespace(node, openTag, closeTag, content) {
        if (!content.startsWith(" ") && !content.startsWith("\n") && !content.startsWith("=")) {
            this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "after-open"
            });
        }
        else if (content.startsWith("=") && content.length > 1 && !content[1].match(/\s/)) {
            this.addOffense(`Add whitespace after \`<%#=\`.`, openTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "after-comment-equals"
            });
        }
        if (!content.endsWith(" ") && !content.endsWith("\n")) {
            this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "before-close"
            });
        }
    }
    checkOpenTagWhitespace(node, openTag, closeTag, content) {
        if (content.startsWith(" ") || content.startsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, {
            node,
            openTag,
            closeTag,
            content,
            fixType: "after-open"
        });
    }
    checkCloseTagWhitespace(node, openTag, closeTag, content) {
        if (content.endsWith(" ") || content.endsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, {
            node,
            openTag,
            closeTag,
            content,
            fixType: "before-close"
        });
    }
}
class ERBRequireWhitespaceRule extends ParserRule {
    static autocorrectable = true;
    name = "erb-require-whitespace-inside-tags";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new RequireWhitespaceInsideTags(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, fixType } = offense.autofixContext;
        if (!node.content)
            return null;
        const content = node.content.value;
        if (fixType === "before-close") {
            node.content.value = content + " ";
            return result;
        }
        if (fixType === "after-open") {
            node.content.value = " " + content;
            return result;
        }
        if (fixType === "after-comment-equals" && content.startsWith("=")) {
            node.content.value = "= " + content.substring(1);
            return result;
        }
        return null;
    }
}

class ERBRightTrimVisitor extends BaseRuleVisitor {
    visitERBNode(node) {
        if (!node.tag_closing)
            return;
        const trimClosing = node.tag_closing.value;
        if (trimClosing !== "=%>")
            return;
        this.addOffense("Use `-%>` instead of `=%>` for right-trimming. The `=%>` syntax is obscure and not well-supported in most ERB engines.", node.tag_closing.location, { node });
    }
}
class ERBRightTrimRule extends ParserRule {
    static autocorrectable = true;
    name = "erb-right-trim";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBRightTrimVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node } = offense.autofixContext;
        if (!node.tag_closing)
            return null;
        const closing = node.tag_closing;
        if (closing.value === "=%>") {
            closing.value = "-%>";
            return result;
        }
        if (closing.value === "-%>") {
            closing.value = "%>";
            return result;
        }
        return null;
    }
}

/**
 * Utilities for parsing herb:disable comments
 */
/**
 * Prefix for herb:disable comments
 */
const HERB_DISABLE_PREFIX = "herb:disable";
/**
 * Parse a herb:disable comment from ERB comment content.
 * Use this when you have the content inside <%# ... %> (e.g., from ERBContentNode.content.value)
 *
 * @param content - The content string (without <%# %> delimiters)
 * @returns Parsed comment data or null if not a valid herb:disable comment
 *
 * @example
 * ```ts
 * const result = parseHerbDisableContent("herb:disable rule1, rule2")
 * // { match: "herb:disable rule1, rule2", ruleNames: ["rule1", "rule2"], rulesString: "rule1, rule2" }
 * ```
 */
function parseHerbDisableContent(content) {
    const trimmed = content.trim();
    if (!trimmed.startsWith(HERB_DISABLE_PREFIX))
        return null;
    const afterPrefix = trimmed.substring(HERB_DISABLE_PREFIX.length).trimStart();
    if (afterPrefix.length === 0)
        return null;
    const rulesString = afterPrefix.trimEnd();
    const ruleNames = rulesString.split(',').map(name => name.trim());
    if (ruleNames.some(name => name.length === 0))
        return null;
    if (ruleNames.length === 0)
        return null;
    const herbDisablePrefix = content.indexOf(HERB_DISABLE_PREFIX);
    const searchStart = herbDisablePrefix + HERB_DISABLE_PREFIX.length;
    const rulesStringOffset = content.indexOf(rulesString, searchStart);
    const ruleNameDetails = [];
    let currentOffset = 0;
    for (const ruleName of ruleNames) {
        const ruleOffset = rulesString.indexOf(ruleName, currentOffset);
        ruleNameDetails.push({
            name: ruleName,
            offset: rulesStringOffset + ruleOffset,
            length: ruleName.length
        });
        currentOffset = ruleOffset + ruleName.length;
    }
    return {
        match: trimmed,
        ruleNames,
        ruleNameDetails,
        rulesString
    };
}
/**
 * Parse a herb:disable comment from a full source line.
 * Use this when you have a complete line that may contain <%# herb:disable ... %>
 *
 * @param line - The source line that may contain a herb:disable comment
 * @returns Parsed comment data or null if not a valid herb:disable comment
 *
 * @example
 * ```ts
 * const result = parseHerbDisableLine("<div>test</div> <%# herb:disable rule1, rule2 %>")
 * // { match: "<%# herb:disable rule1, rule2 %>", ruleNames: ["rule1", "rule2"], rulesString: "rule1, rule2" }
 * ```
 */
function parseHerbDisableLine(line) {
    const startTag = "<%#";
    const endTag = "%>";
    const startIndex = line.indexOf(startTag);
    if (startIndex === -1)
        return null;
    const endIndex = line.indexOf(endTag, startIndex);
    if (endIndex === -1)
        return null;
    const content = line.substring(startIndex + startTag.length, endIndex).trim();
    if (!content.startsWith(HERB_DISABLE_PREFIX))
        return null;
    const afterPrefix = content.substring(HERB_DISABLE_PREFIX.length).trimStart();
    if (afterPrefix.length === 0)
        return null;
    const rulesString = afterPrefix.trimEnd();
    const ruleNames = rulesString.split(',').map(name => name.trim());
    if (ruleNames.some(name => name.length === 0))
        return null;
    if (ruleNames.length === 0)
        return null;
    const herbDisablePrefix = line.indexOf(HERB_DISABLE_PREFIX);
    const searchStart = herbDisablePrefix + HERB_DISABLE_PREFIX.length;
    const rulesStringOffset = line.indexOf(rulesString, searchStart);
    const ruleNameDetails = [];
    let currentOffset = 0;
    for (const ruleName of ruleNames) {
        const ruleOffset = rulesString.indexOf(ruleName, currentOffset);
        ruleNameDetails.push({
            name: ruleName,
            offset: rulesStringOffset + ruleOffset,
            length: ruleName.length
        });
        currentOffset = ruleOffset + ruleName.length;
    }
    const fullMatch = line.substring(startIndex, endIndex + endTag.length);
    return {
        match: fullMatch,
        ruleNames,
        ruleNameDetails,
        rulesString
    };
}

/**
 * Base visitor class for herb:disable comment validation rules.
 * Handles common patterns like checking ERB comments and parsing herb:disable content.
 */
class HerbDisableCommentBaseVisitor extends BaseRuleVisitor {
    constructor(ruleName, context) {
        super(ruleName, context);
    }
    visitERBContentNode(node) {
        if (node.tag_opening?.value !== "<%#")
            return;
        const content = node.content?.value;
        if (!content)
            return;
        this.checkHerbDisableComment(node, content);
    }
    /**
     * Helper to create a precise location for a specific rule name within the comment.
     * Returns null if content location is not available.
     */
    createRuleNameLocation(node, ruleDetail) {
        const contentLocation = node.content?.location;
        if (!contentLocation)
            return null;
        const startLine = contentLocation.start.line;
        const startColumn = contentLocation.start.column + ruleDetail.offset;
        return Location.from(startLine, startColumn, startLine, startColumn + ruleDetail.length);
    }
    /**
     * Helper to add an offense with a fallback to node location if precise location unavailable.
     */
    addOffenseWithFallback(message, preciseLocation, node) {
        this.addOffense(message, preciseLocation || node.location);
    }
}
/**
 * Base visitor for rules that need to process parsed herb:disable comments.
 * Only calls the abstract method if the content successfully parses as a herb:disable comment.
 */
class HerbDisableCommentParsedVisitor extends HerbDisableCommentBaseVisitor {
    checkHerbDisableComment(node, content) {
        const herbDisable = parseHerbDisableContent(content);
        if (!herbDisable)
            return;
        this.checkParsedHerbDisable(node, content, herbDisable);
    }
}

class HerbDisableCommentValidRuleNameVisitor extends HerbDisableCommentParsedVisitor {
    validRuleNames = new Set();
    validRuleNamesList = [];
    constructor(ruleName, validRuleNames, context) {
        super(ruleName, context);
        this.validRuleNames = new Set([...validRuleNames, "all"]);
        this.validRuleNamesList = Array.from(this.validRuleNames);
    }
    checkParsedHerbDisable(node, _content, herbDisable) {
        herbDisable.ruleNameDetails.forEach(ruleDetail => {
            if (this.validRuleNames.has(ruleDetail.name))
                return;
            const suggestion = didyoumean(ruleDetail.name, this.validRuleNamesList);
            const message = suggestion
                ? `Unknown rule \`${ruleDetail.name}\`. Did you mean \`${suggestion}\`?`
                : `Unknown rule \`${ruleDetail.name}\`.`;
            const location = this.createRuleNameLocation(node, ruleDetail);
            this.addOffenseWithFallback(message, location, node);
        });
    }
}
class HerbDisableCommentValidRuleNameRule extends ParserRule {
    name = "herb-disable-comment-valid-rule-name";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const validRuleNames = context?.validRuleNames;
        if (!validRuleNames)
            return [];
        if (validRuleNames.length === 0)
            return [];
        const visitor = new HerbDisableCommentValidRuleNameVisitor(this.name, validRuleNames, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentNoRedundantAllVisitor extends HerbDisableCommentParsedVisitor {
    checkParsedHerbDisable(node, _content, herbDisable) {
        if (!herbDisable.ruleNames.includes("all"))
            return;
        if (herbDisable.ruleNames.length <= 1)
            return;
        const allDetail = herbDisable.ruleNameDetails.find(detail => detail.name === "all");
        if (!allDetail)
            return;
        const location = this.createRuleNameLocation(node, allDetail);
        const message = `Using \`all\` with specific rules is redundant. Use \`herb:disable all\` by itself or list only specific rules.`;
        this.addOffenseWithFallback(message, location, node);
    }
}
class HerbDisableCommentNoRedundantAllRule extends ParserRule {
    name = "herb-disable-comment-no-redundant-all";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new HerbDisableCommentNoRedundantAllVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentNoDuplicateRulesVisitor extends HerbDisableCommentParsedVisitor {
    checkParsedHerbDisable(node, _content, herbDisable) {
        const seenRules = new Map();
        herbDisable.ruleNameDetails.forEach((ruleDetail, index) => {
            const firstIndex = seenRules.get(ruleDetail.name);
            if (firstIndex !== undefined) {
                const location = this.createRuleNameLocation(node, ruleDetail);
                const message = `Duplicate rule \`${ruleDetail.name}\` in \`herb:disable\` comment. Remove the duplicate.`;
                this.addOffenseWithFallback(message, location, node);
                return;
            }
            seenRules.set(ruleDetail.name, index);
        });
    }
}
class HerbDisableCommentNoDuplicateRulesRule extends ParserRule {
    name = "herb-disable-comment-no-duplicate-rules";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new HerbDisableCommentNoDuplicateRulesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentMissingRulesVisitor extends HerbDisableCommentBaseVisitor {
    checkHerbDisableComment(node, content) {
        const herbDisable = parseHerbDisableContent(content);
        if (herbDisable)
            return;
        const emptyFormat = /^\s*herb:disable\s*$/;
        if (!emptyFormat.test(content))
            return;
        this.addOffense(`\`herb:disable\` comment is missing rule names. Specify \`all\` or list specific rules to disable.`, node.location);
    }
}
class HerbDisableCommentMissingRulesRule extends ParserRule {
    name = "herb-disable-comment-missing-rules";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HerbDisableCommentMissingRulesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentMalformedVisitor extends HerbDisableCommentBaseVisitor {
    checkHerbDisableComment(node, content) {
        const trimmed = content.trim();
        const looksLikeHerbDisable = trimmed.startsWith("herb:disable");
        if (!looksLikeHerbDisable)
            return;
        if (trimmed.length > "herb:disable".length) {
            const charAfterPrefix = trimmed["herb:disable".length];
            if (charAfterPrefix !== ' ' && charAfterPrefix !== '\t' && charAfterPrefix !== '\n') {
                this.addOffense("`herb:disable` comment is missing a space after `herb:disable`. Add a space before the rule names.", node.location);
                return;
            }
        }
        const afterPrefix = trimmed.substring("herb:disable".length).trim();
        if (afterPrefix.length === 0)
            return;
        const parsed = parseHerbDisableContent(content);
        if (parsed !== null)
            return;
        let message = "`herb:disable` comment is malformed.";
        const rulesString = afterPrefix.trim();
        if (rulesString.endsWith(',')) {
            message = "`herb:disable` comment has a trailing comma. Remove the trailing comma.";
        }
        else if (rulesString.includes(',,') || rulesString.match(/,\s*,/)) {
            message = "`herb:disable` comment has consecutive commas. Remove extra commas.";
        }
        else if (rulesString.startsWith(',')) {
            message = "`herb:disable` comment starts with a comma. Remove the leading comma.";
        }
        this.addOffense(message, node.location);
    }
}
class HerbDisableCommentMalformedRule extends ParserRule {
    name = "herb-disable-comment-malformed";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HerbDisableCommentMalformedVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentUnnecessaryVisitor extends HerbDisableCommentParsedVisitor {
    ignoredOffensesByLine;
    validRuleNames;
    constructor(ruleName, ignoredOffensesByLine, validRuleNames, context) {
        super(ruleName, context);
        this.ignoredOffensesByLine = ignoredOffensesByLine;
        this.validRuleNames = new Set([...validRuleNames, "all"]);
    }
    checkParsedHerbDisable(node, _content, herbDisable) {
        const line = node.location.start.line;
        const usedRuleNames = this.ignoredOffensesByLine.get(line) || new Set();
        if (herbDisable.ruleNames.includes("all")) {
            if (herbDisable.ruleNames.length > 1)
                return;
            if (usedRuleNames.size > 0)
                return;
            this.addOffense(`No offenses to disable on this line. Remove the \`herb:disable all\` comment.`, node.location);
            return;
        }
        const unnecessaryRules = herbDisable.ruleNameDetails.filter(detail => this.validRuleNames.has(detail.name) && !usedRuleNames.has(detail.name));
        if (unnecessaryRules.length === 0)
            return;
        const validRuleCount = herbDisable.ruleNames.filter(name => this.validRuleNames.has(name)).length;
        if (unnecessaryRules.length === validRuleCount) {
            if (unnecessaryRules.length === 1) {
                const ruleName = unnecessaryRules[0].name;
                this.addOffense(`No offenses from \`${ruleName}\` on this line. Remove the \`herb:disable\` comment.`, node.location);
                return;
            }
            const unnecessaryRuleNames = unnecessaryRules.map(rule => `\`${rule.name}\``).join(", ");
            this.addOffense(`No offenses from rules ${unnecessaryRuleNames} on this line. Remove them from the \`herb:disable\` comment.`, node.location);
            return;
        }
        for (const unnecessaryRule of unnecessaryRules) {
            const location = this.createRuleNameLocation(node, unnecessaryRule);
            const message = `No offenses from \`${unnecessaryRule.name}\` on this line. Remove it from the \`herb:disable\` comment.`;
            this.addOffenseWithFallback(message, location, node);
        }
    }
}
class HerbDisableCommentUnnecessaryRule extends ParserRule {
    name = "herb-disable-comment-unnecessary";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const validRuleNames = context?.validRuleNames;
        const ignoredOffensesByLine = context?.ignoredOffensesByLine;
        if (!validRuleNames)
            return [];
        if (validRuleNames.length === 0)
            return [];
        if (!ignoredOffensesByLine)
            return [];
        const visitor = new HerbDisableCommentUnnecessaryVisitor(this.name, ignoredOffensesByLine, validRuleNames, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AnchorRechireHrefVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkATag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkATag(node) {
        const tagName = getTagName(node);
        if (tagName !== "a") {
            return;
        }
        if (!hasAttribute(node, "href")) {
            this.addOffense("Add an `href` attribute to `<a>` to ensure it is focusable and accessible.", node.tag_name.location);
        }
    }
}
class HTMLAnchorRequireHrefRule extends ParserRule {
    name = "html-anchor-require-href";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AnchorRechireHrefVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaAttributeMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    check(attributeName, attributeNode) {
        if (!attributeName.startsWith("aria-"))
            return;
        if (ARIA_ATTRIBUTES.has(attributeName))
            return;
        this.addOffense(`The attribute \`${attributeName}\` is not a valid ARIA attribute. ARIA attributes must match the WAI-ARIA specification.`, attributeNode.location);
    }
}
class HTMLAriaAttributeMustBeValid extends ParserRule {
    name = "html-aria-attribute-must-be-valid";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AriaAttributeMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaLabelIsWellFormattedVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-label")
            return;
        if (attributeValue.match(/[\r\n]+/) || attributeValue.match(/&#10;|&#13;|&#x0A;|&#x0D;/i)) {
            this.addOffense("The `aria-label` attribute value text should not contain line breaks. Use concise, single-line descriptions.", attributeNode.location);
            return;
        }
        if (this.looksLikeId(attributeValue)) {
            this.addOffense("The `aria-label` attribute value should not be formatted like an ID. Use natural, sentence-case text instead.", attributeNode.location);
            return;
        }
        if (attributeValue.match(/^[a-z]/)) {
            this.addOffense("The `aria-label` attribute value text should be formatted like visual text. Use sentence case (capitalize the first letter).", attributeNode.location);
        }
    }
    looksLikeId(text) {
        return (text.includes('_') ||
            text.includes('-') ||
            /^[a-z]+([A-Z][a-z]*)*$/.test(text)) && !text.includes(' ');
    }
}
class HTMLAriaLabelIsWellFormattedRule extends ParserRule {
    name = "html-aria-label-is-well-formatted";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AriaLabelIsWellFormattedVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLAriaLevelMustBeValidVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        this.validateAriaLevel(attributeValue, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        const validatableContent = getValidatableStaticContent(valueNodes);
        if (validatableContent !== null) {
            this.validateAriaLevel(validatableContent, attributeNode);
            return;
        }
        if (!hasERBOutput(valueNodes))
            return;
        const literalNodes = filterLiteralNodes(valueNodes);
        const erbOutputNodes = filterERBContentNodes(valueNodes).filter(isERBOutputNode);
        if (literalNodes.length > 0 && erbOutputNodes.length > 0) {
            const staticPart = literalNodes.map(node => node.content).join("");
            // TODO: this can be cleaned up using @herb-tools/printer
            const erbPart = erbOutputNodes[0];
            const erbText = `${erbPart.tag_opening?.value || ""}${erbPart.content?.value || ""}${erbPart.tag_closing?.value || ""}`;
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${staticPart}\` and the ERB expression \`${erbText}\`.`, attributeNode.location);
        }
    }
    validateAriaLevel(attributeValue, attributeNode) {
        if (!attributeValue || attributeValue === "") {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got an empty value.`, attributeNode.location);
            return;
        }
        const number = parseInt(attributeValue);
        if (isNaN(number) || number < 1 || number > 6 || attributeValue !== number.toString()) {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${attributeValue}\`.`, attributeNode.location);
        }
    }
}
class HTMLAriaLevelMustBeValidRule extends ParserRule {
    name = "html-aria-level-must-be-valid";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLAriaLevelMustBeValidVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleHeadingRequiresLevel extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode, parentNode }) {
        if (!(attributeName === "role" && attributeValue === "heading"))
            return;
        const ariaLevelAttributes = getAttributes(parentNode).find(attribute => getAttributeName(attribute) === "aria-level");
        if (ariaLevelAttributes)
            return;
        this.addOffense(`Element with \`role="heading"\` must have an \`aria-level\` attribute.`, attributeNode.location);
    }
}
class HTMLAriaRoleHeadingRequiresLevelRule extends ParserRule {
    name = "html-aria-role-heading-requires-level";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AriaRoleHeadingRequiresLevel(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "role")
            return;
        if (!attributeValue)
            return;
        if (VALID_ARIA_ROLES.has(attributeValue))
            return;
        this.addOffense(`The \`role\` attribute must be a valid ARIA role. Role \`${attributeValue}\` is not recognized.`, attributeNode.location);
    }
}
class HTMLAriaRoleMustBeValidRule extends ParserRule {
    name = "html-aria-role-must-be-valid";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AriaRoleMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AttributeDoubleQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (attributeValue?.includes('"'))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${attributeValue}"\`.`, attributeNode.value.location, {
            node: attributeNode,
            valueContent: attributeValue
        });
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode, combinedValue }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (filterLiteralNodes(valueNodes).some(node => node.content?.includes('"')))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${combinedValue}"\`.`, attributeNode.value.location, {
            node: attributeNode,
            valueContent: combinedValue || ""
        });
    }
}
class HTMLAttributeDoubleQuotesRule extends ParserRule {
    static autocorrectable = true;
    name = "html-attribute-double-quotes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new AttributeDoubleQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { value } } = offense.autofixContext;
        if (!value)
            return null;
        if (!value.open_quote)
            return null;
        if (!value.close_quote)
            return null;
        value.open_quote.value = '"';
        value.close_quote.value = '"';
        return result;
    }
}

class HTMLAttributeEqualsSpacingVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNode(attribute) {
        if (!attribute.equals || !attribute.name || !attribute.value) {
            return;
        }
        if (attribute.equals.value.startsWith(" ")) {
            this.addOffense("Remove whitespace before `=` in HTML attribute", attribute.equals.location, { node: attribute });
        }
        if (attribute.equals.value.endsWith(" ")) {
            this.addOffense("Remove whitespace after `=` in HTML attribute", attribute.equals.location, { node: attribute });
        }
    }
}
class HTMLAttributeEqualsSpacingRule extends ParserRule {
    static autocorrectable = true;
    name = "html-attribute-equals-spacing";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLAttributeEqualsSpacingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { equals } } = offense.autofixContext;
        if (!equals)
            return null;
        equals.value = "=";
        return result;
    }
}

class AttributeValuesRequireQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${attributeValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, {
            node: attributeNode,
            unquotedValue: attributeValue
        });
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode, combinedValue }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${combinedValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, {
            node: attributeNode,
            unquotedValue: combinedValue || ""
        });
    }
    hasAttributeValue(attributeNode) {
        return attributeNode.value?.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    isQuoted(attributeNode) {
        const valueNode = attributeNode.value;
        return valueNode ? valueNode.quoted : false;
    }
}
class HTMLAttributeValuesRequireQuotesRule extends ParserRule {
    static autocorrectable = true;
    name = "html-attribute-values-require-quotes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AttributeValuesRequireQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { value } } = offense.autofixContext;
        if (!value)
            return null;
        const quote = Token.from({ type: "TOKEN_QUOTE", value: '"', location: Location.zero, range: [0, 0] });
        if (value.open_quote) {
            value.open_quote.value = '"';
        }
        else {
            value.open_quote = quote;
        }
        if (value.close_quote) {
            value.close_quote.value = '"';
        }
        else {
            value.close_quote = quote;
        }
        value.quoted = true;
        return result;
    }
}

const ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT = new Set([
    "button", "fieldset", "input", "optgroup", "option", "select", "textarea"
]);
class AvoidBothDisabledAndAriaDisabledVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkElement(node) {
        const tagName = getTagName(node);
        if (!tagName || !ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT.has(tagName)) {
            return;
        }
        const hasDisabled = hasAttribute(node, "disabled");
        const hasAriaDisabled = hasAttribute(node, "aria-disabled");
        if ((hasDisabled && this.hasERBContent(node, "disabled")) || (hasAriaDisabled && this.hasERBContent(node, "aria-disabled"))) {
            return;
        }
        if (hasDisabled && hasAriaDisabled) {
            this.addOffense("aria-disabled may be used in place of native HTML disabled to allow tab-focus on an otherwise ignored element. Setting both attributes is contradictory and confusing. Choose either disabled or aria-disabled, not both.", node.tag_name.location);
        }
    }
    hasERBContent(node, attributeName) {
        const attributes = getAttributes(node);
        const attribute = findAttributeByName(attributes, attributeName);
        if (!attribute)
            return false;
        const valueNode = attribute.value;
        if (!valueNode || valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE")
            return false;
        const htmlValueNode = valueNode;
        if (!htmlValueNode.children)
            return false;
        return htmlValueNode.children.some((child) => child.type === "AST_ERB_CONTENT_NODE");
    }
}
class HTMLAvoidBothDisabledAndAriaDisabledRule extends ParserRule {
    name = "html-avoid-both-disabled-and-aria-disabled";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AvoidBothDisabledAndAriaDisabledVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLBodyOnlyElementsVisitor extends BaseRuleVisitor {
    elementStack = [];
    visitHTMLElementNode(node) {
        const tagName = getTagName(node.open_tag)?.toLowerCase();
        if (!tagName)
            return;
        this.checkBodyOnlyElement(node, tagName);
        this.elementStack.push(tagName);
        this.visitChildNodes(node);
        this.elementStack.pop();
    }
    checkBodyOnlyElement(node, tagName) {
        if (this.insideBody)
            return;
        if (!this.insideHead)
            return;
        if (!isBodyOnlyTag(tagName))
            return;
        this.addOffense(`Element \`<${tagName}>\` must be placed inside the \`<body>\` tag.`, node.location);
    }
    get insideBody() {
        return this.elementStack.includes("body");
    }
    get insideHead() {
        return this.elementStack.includes("head");
    }
}
class HTMLBodyOnlyElementsRule extends ParserRule {
    static autocorrectable = false;
    name = "html-body-only-elements";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/*.xml", "**/*.xml.erb"]
        };
    }
    check(result, context) {
        const visitor = new HTMLBodyOnlyElementsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class BooleanAttributesNoValueVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ originalAttributeName, attributeNode }) {
        this.checkAttribute(originalAttributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ originalAttributeName, attributeNode }) {
        this.checkAttribute(originalAttributeName, attributeNode);
    }
    checkAttribute(attributeName, attributeNode) {
        if (!isBooleanAttribute(attributeName))
            return;
        if (!hasAttributeValue(attributeNode))
            return;
        this.addOffense(`Boolean attribute \`${IdentityPrinter.print(attributeNode.name)}\` should not have a value. Use \`${attributeName.toLowerCase()}\` instead of \`${IdentityPrinter.print(attributeNode)}\`.`, attributeNode.value.location, {
            node: attributeNode
        });
    }
}
class HTMLBooleanAttributesNoValueRule extends ParserRule {
    static autocorrectable = true;
    name = "html-boolean-attributes-no-value";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new BooleanAttributesNoValueVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node } = offense.autofixContext;
        node.equals = null;
        node.value = null;
        return result;
    }
}

class HeadOnlyElementsVisitor extends BaseRuleVisitor {
    elementStack = [];
    visitHTMLElementNode(node) {
        const tagName = getTagName(node)?.toLowerCase();
        if (!tagName)
            return;
        this.checkHeadOnlyElement(node, tagName);
        this.elementStack.push(tagName);
        this.visitChildNodes(node);
        this.elementStack.pop();
    }
    checkHeadOnlyElement(node, tagName) {
        if (this.insideHead)
            return;
        if (!this.insideBody)
            return;
        if (!isHeadOnlyTag(tagName))
            return;
        if (tagName === "title" && this.insideSVG)
            return;
        if (tagName === "meta" && this.hasItempropAttribute(node))
            return;
        this.addOffense(`Element \`<${tagName}>\` must be placed inside the \`<head>\` tag.`, node.location);
    }
    hasItempropAttribute(node) {
        return hasAttribute(node.open_tag, "itemprop");
    }
    get insideHead() {
        return this.elementStack.includes("head");
    }
    get insideBody() {
        return this.elementStack.includes("body");
    }
    get insideSVG() {
        return this.elementStack.includes("svg");
    }
}
class HTMLHeadOnlyElementsRule extends ParserRule {
    static autocorrectable = false;
    name = "html-head-only-elements";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/*.xml", "**/*.xml.erb"]
        };
    }
    check(result, context) {
        const visitor = new HeadOnlyElementsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class IframeHasTitleVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkIframeElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkIframeElement(node) {
        const tagName = getTagName(node);
        if (tagName !== "iframe") {
            return;
        }
        const ariaHiddenAttribute = getAttribute(node, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return;
            }
        }
        const attribute = getAttribute(node, "title");
        if (!attribute) {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location);
            return;
        }
        const value = getAttributeValue(attribute);
        if (!value || value.trim() === "") {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location);
        }
    }
}
class HTMLIframeHasTitleRule extends ParserRule {
    name = "html-iframe-has-title";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new IframeHasTitleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ImgRequireAltVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(node) {
        const tagName = getTagName(node);
        if (tagName !== "img") {
            return;
        }
        if (!hasAttribute(node, "alt")) {
            this.addOffense('Missing required `alt` attribute on `<img>` tag. Add `alt=""` for decorative images or `alt="description"` for informative images.', node.tag_name.location);
        }
    }
}
class HTMLImgRequireAltRule extends ParserRule {
    name = "html-img-require-alt";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ImgRequireAltVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLInputRequireAutocompleteVisitor extends BaseRuleVisitor {
    HTML_INPUT_TYPES_REQUIRING_AUTOCOMPLETE = new Set([
        "color",
        "date",
        "datetime-local",
        "email",
        "month",
        "number",
        "password",
        "range",
        "search",
        "tel",
        "text",
        "time",
        "url",
        "week",
    ]);
    visitHTMLOpenTagNode(node) {
        this.checkInputTag(node);
    }
    checkInputTag(node) {
        if (!this.isInputTag(node) || this.hasAutocomplete(node))
            return;
        const typeAttribute = getAttribute(node, "type");
        if (!typeAttribute)
            return;
        const typeValue = getStaticAttributeValueContent(typeAttribute);
        if (!typeValue)
            return;
        if (!this.HTML_INPUT_TYPES_REQUIRING_AUTOCOMPLETE.has(typeValue))
            return;
        this.addOffense("Add an `autocomplete` attribute to improve form accessibility. Use a specific value (e.g., `autocomplete=\"email\"`), `autocomplete=\"on\"` for defaults, or `autocomplete=\"off\"` to disable.", node.location);
    }
    hasAutocomplete(node) {
        const autocompleteAttribute = getAttribute(node, "autocomplete");
        if (!autocompleteAttribute)
            return false;
        const autocompleteValue = getAttributeValue(autocompleteAttribute);
        if (!autocompleteValue)
            return false;
        return true;
    }
    isInputTag(node) {
        const tagName = getTagName$1(node);
        if (tagName === "input") {
            return true;
        }
        else {
            return false;
        }
    }
}
class HTMLInputRequireAutocompleteRule extends ParserRule {
    name = "html-input-require-autocomplete";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLInputRequireAutocompleteVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NavigationHasLabelVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkNavigationElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkNavigationElement(node) {
        const tagName = getTagName(node);
        const isNavElement = tagName === "nav";
        const hasNavigationRole = this.hasRoleNavigation(node);
        if (!isNavElement && !hasNavigationRole) {
            return;
        }
        const hasAriaLabel = hasAttribute(node, "aria-label");
        const hasAriaLabelledby = hasAttribute(node, "aria-labelledby");
        if (!hasAriaLabel && !hasAriaLabelledby) {
            let message = `The navigation landmark should have a unique accessible name via \`aria-label\` or \`aria-labelledby\`. Remember that the name does not need to include "navigation" or "nav" since it will already be announced.`;
            if (hasNavigationRole && !isNavElement) {
                message += ` Additionally, you can safely drop the \`role="navigation"\` and replace it with the native HTML \`<nav>\` element.`;
            }
            this.addOffense(message, node.tag_name.location);
        }
    }
    hasRoleNavigation(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "navigation";
    }
}
class HTMLNavigationHasLabelRule extends ParserRule {
    name = "html-navigation-has-label";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NavigationHasLabelVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const INTERACTIVE_ELEMENTS = new Set([
    "button", "summary", "input", "select", "textarea", "a"
]);
class NoAriaHiddenOnFocusableVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkAriaHiddenOnFocusable(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAriaHiddenOnFocusable(node) {
        if (!this.hasAriaHiddenTrue(node))
            return;
        if (this.isFocusable(node)) {
            this.addOffense(`Elements that are focusable should not have \`aria-hidden="true"\` because it will cause confusion for assistive technology users.`, node.tag_name.location);
        }
    }
    hasAriaHiddenTrue(node) {
        const attributes = getAttributes(node);
        const ariaHiddenAttr = findAttributeByName(attributes, "aria-hidden");
        if (!ariaHiddenAttr)
            return false;
        const value = getAttributeValue(ariaHiddenAttr);
        return value === "true";
    }
    isFocusable(node) {
        const tagName = getTagName(node);
        if (!tagName)
            return false;
        const tabIndexValue = this.getTabIndexValue(node);
        if (tagName === "a") {
            const hasHref = hasAttribute(node, "href");
            if (!hasHref) {
                return tabIndexValue !== null && tabIndexValue >= 0;
            }
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        if (INTERACTIVE_ELEMENTS.has(tagName)) {
            // Interactive elements are focusable unless tabindex is negative
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        else {
            // Non-interactive elements are focusable only if tabindex >= 0
            return tabIndexValue !== null && tabIndexValue >= 0;
        }
    }
    getTabIndexValue(node) {
        const attributes = getAttributes(node);
        const tabIndexAttribute = findAttributeByName(attributes, "tabindex");
        if (!tabIndexAttribute)
            return null;
        const value = getAttributeValue(tabIndexAttribute);
        if (!value)
            return null;
        const parsed = parseInt(value, 10);
        return isNaN(parsed) ? null : parsed;
    }
}
class HTMLNoAriaHiddenOnFocusableRule extends ParserRule {
    name = "html-no-aria-hidden-on-focusable";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoAriaHiddenOnFocusableVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class BlockInsideInlineVisitor extends BaseRuleVisitor {
    inlineStack = [];
    isValidHTMLOpenTag(node) {
        return !!(node.open_tag && node.open_tag.type === "AST_HTML_OPEN_TAG_NODE");
    }
    getElementType(tagName) {
        const isInline = isInlineElement(tagName);
        const isBlock = isBlockElement(tagName);
        const isUnknown = !isInline && !isBlock;
        return { isInline, isBlock, isUnknown };
    }
    addOffenseMessage(tagName, isBlock, openTag) {
        const parentInline = this.inlineStack[this.inlineStack.length - 1];
        const elementType = isBlock ? "Block-level" : "Unknown";
        this.addOffense(`${elementType} element \`<${tagName}>\` cannot be placed inside inline element \`<${parentInline}>\`.`, openTag.tag_name.location);
    }
    visitInlineElement(node, tagName) {
        this.inlineStack.push(tagName);
        super.visitHTMLElementNode(node);
        this.inlineStack.pop();
    }
    visitBlockElement(node) {
        const savedStack = [...this.inlineStack];
        this.inlineStack = [];
        super.visitHTMLElementNode(node);
        this.inlineStack = savedStack;
    }
    visitHTMLElementNode(node) {
        if (!this.isValidHTMLOpenTag(node)) {
            super.visitHTMLElementNode(node);
            return;
        }
        const openTag = node.open_tag;
        const tagName = openTag.tag_name?.value.toLowerCase();
        if (!tagName) {
            super.visitHTMLElementNode(node);
            return;
        }
        const { isInline, isBlock, isUnknown } = this.getElementType(tagName);
        if ((isBlock || isUnknown) && this.inlineStack.length > 0) {
            this.addOffenseMessage(tagName, isBlock, openTag);
        }
        if (isInline) {
            this.visitInlineElement(node, tagName);
            return;
        }
        this.visitBlockElement(node);
    }
}
class HTMLNoBlockInsideInlineRule extends ParserRule {
    name = "html-no-block-inside-inline";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new BlockInsideInlineVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoDuplicateAttributesVisitor extends AttributeVisitorMixin {
    attributeNames = new Map();
    visitHTMLOpenTagNode(node) {
        this.attributeNames.clear();
        super.visitHTMLOpenTagNode(node);
        this.reportDuplicates();
    }
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    trackAttributeName(attributeName, attributeNode) {
        if (!this.attributeNames.has(attributeName)) {
            this.attributeNames.set(attributeName, []);
        }
        this.attributeNames.get(attributeName).push(attributeNode);
    }
    reportDuplicates() {
        for (const [attributeName, attributeNodes] of this.attributeNames) {
            if (attributeNodes.length > 1) {
                for (let i = 1; i < attributeNodes.length; i++) {
                    const attributeNode = attributeNodes[i];
                    this.addOffense(`Duplicate attribute \`${attributeName}\` found on tag. Remove the duplicate occurrence.`, attributeNode.name.location);
                }
            }
        }
    }
}
class HTMLNoDuplicateAttributesRule extends ParserRule {
    name = "html-no-duplicate-attributes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoDuplicateAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class OutputPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(IdentityPrinter.print(node));
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.write(IdentityPrinter.print(node));
        }
    }
}
class NoDuplicateIdsVisitor extends ControlFlowTrackingVisitor {
    documentIds = new Set();
    currentBranchIds = new Set();
    controlFlowIds = new Set();
    visitHTMLAttributeNode(node) {
        this.checkAttribute(node);
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds,
            previousControlFlowIds: this.controlFlowIds
        };
        this.currentBranchIds = new Set();
        if (!wasAlreadyInControlFlow) {
            this.controlFlowIds = new Set();
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowIds.forEach(id => this.documentIds.add(id));
        }
        this.currentBranchIds = stateToRestore.previousBranchIds;
        this.controlFlowIds = stateToRestore.previousControlFlowIds;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds
        };
        if (this.isInControlFlow) {
            this.currentBranchIds = new Set();
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    checkAttribute(attributeNode) {
        if (!this.isIdAttribute(attributeNode))
            return;
        const idValue = this.extractIdValue(attributeNode);
        if (!idValue)
            return;
        if (this.isWhitespaceOnlyId(idValue.identifier))
            return;
        this.processIdDuplicate(idValue, attributeNode);
    }
    isIdAttribute(attributeNode) {
        if (!attributeNode.name?.children || !attributeNode.value)
            return false;
        return getStaticAttributeName(attributeNode.name) === "id";
    }
    extractIdValue(attributeNode) {
        const valueNodes = attributeNode.value?.children || [];
        if (hasERBOutput(valueNodes) && this.isInControlFlow && this.currentControlFlowType === ControlFlowType.LOOP) {
            return null;
        }
        const identifier = isEffectivelyStatic(valueNodes) ? getValidatableStaticContent(valueNodes) : OutputPrinter.print(valueNodes);
        if (!identifier)
            return null;
        return { identifier, shouldTrackDuplicates: true };
    }
    isWhitespaceOnlyId(identifier) {
        return identifier !== '' && identifier.trim() === '';
    }
    processIdDuplicate(idValue, attributeNode) {
        const { identifier, shouldTrackDuplicates } = idValue;
        if (!shouldTrackDuplicates)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowId(identifier, attributeNode);
        }
        else {
            this.handleGlobalId(identifier, attributeNode);
        }
    }
    handleControlFlowId(identifier, attributeNode) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.handleLoopId(identifier, attributeNode);
        }
        else {
            this.handleConditionalId(identifier, attributeNode);
        }
        this.currentBranchIds.add(identifier);
    }
    handleLoopId(identifier, attributeNode) {
        const isStaticId = this.isStaticId(attributeNode);
        if (isStaticId) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        if (this.currentBranchIds.has(identifier)) {
            this.addSameLoopIterationOffense(identifier, attributeNode.location);
        }
    }
    handleConditionalId(identifier, attributeNode) {
        if (this.currentBranchIds.has(identifier)) {
            this.addSameBranchOffense(identifier, attributeNode.location);
            return;
        }
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.controlFlowIds.add(identifier);
    }
    handleGlobalId(identifier, attributeNode) {
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.documentIds.add(identifier);
    }
    isStaticId(attributeNode) {
        const valueNodes = attributeNode.value.children;
        const isCompletelyStatic = valueNodes.every(child => isNode(child, LiteralNode));
        const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
        return isCompletelyStatic || isEffectivelyStaticValue;
    }
    addDuplicateIdOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found. IDs must be unique within a document.`, location);
    }
    addSameLoopIterationOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same loop iteration. IDs must be unique within the same loop iteration.`, location);
    }
    addSameBranchOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same control flow branch. IDs must be unique within the same control flow branch.`, location);
    }
}
class HTMLNoDuplicateIdsRule extends ParserRule {
    name = "html-no-duplicate-ids";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoDuplicateIdsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLNoDuplicateMetaNamesVisitor extends ControlFlowTrackingVisitor {
    elementStack = [];
    documentMetas = [];
    currentBranchMetas = [];
    controlFlowMetas = [];
    visitHTMLElementNode(node) {
        const tagName = getTagName(node)?.toLowerCase();
        if (!tagName)
            return;
        if (tagName === "head") {
            this.documentMetas = [];
            this.currentBranchMetas = [];
            this.controlFlowMetas = [];
        }
        else if (tagName === "meta" && this.insideHead) {
            this.collectAndCheckMetaTag(node);
        }
        this.elementStack.push(tagName);
        this.visitChildNodes(node);
        this.elementStack.pop();
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchMetas: this.currentBranchMetas,
            previousControlFlowMetas: this.controlFlowMetas
        };
        this.currentBranchMetas = [];
        if (!wasAlreadyInControlFlow) {
            this.controlFlowMetas = [];
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowMetas.forEach(meta => this.documentMetas.push(meta));
        }
        this.currentBranchMetas = stateToRestore.previousBranchMetas;
        this.controlFlowMetas = stateToRestore.previousControlFlowMetas;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchMetas: this.currentBranchMetas
        };
        if (this.isInControlFlow) {
            this.currentBranchMetas = [];
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    get insideHead() {
        return this.elementStack.includes("head");
    }
    collectAndCheckMetaTag(node) {
        const metaTag = { node };
        this.extractAttributes(node, metaTag);
        if (!metaTag.nameValue && !metaTag.httpEquivValue)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowMeta(metaTag);
        }
        else {
            this.handleGlobalMeta(metaTag);
        }
        this.currentBranchMetas.push(metaTag);
    }
    extractAttributes(node, metaTag) {
        if (isHTMLElementNode(node) && node.open_tag) {
            forEachAttribute(node.open_tag, (attributeNode) => {
                const name = getAttributeName(attributeNode);
                const value = getAttributeValue(attributeNode)?.trim();
                if (name === "name" && value) {
                    metaTag.nameValue = value;
                }
                else if (name === "http-equiv" && value) {
                    metaTag.httpEquivValue = value;
                }
            });
        }
    }
    handleControlFlowMeta(metaTag) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.checkAgainstMetaList(metaTag, this.currentBranchMetas, "within the same loop iteration");
        }
        else {
            this.checkAgainstMetaList(metaTag, this.currentBranchMetas, "within the same control flow branch");
            this.checkAgainstMetaList(metaTag, this.documentMetas, "");
            this.controlFlowMetas.push(metaTag);
        }
    }
    handleGlobalMeta(metaTag) {
        this.checkAgainstMetaList(metaTag, this.documentMetas, "");
        this.documentMetas.push(metaTag);
    }
    checkAgainstMetaList(metaTag, existingMetas, context) {
        for (const existing of existingMetas) {
            if (this.areMetaTagsDuplicate(metaTag, existing)) {
                const attributeDescription = metaTag.nameValue
                    ? `\`name="${metaTag.nameValue}"\``
                    : `\`http-equiv="${metaTag.httpEquivValue}"\``;
                const attributeType = metaTag.nameValue ? "Meta names" : "`http-equiv` values";
                const contextMsg = context ? ` ${context}` : "";
                this.addOffense(`Duplicate \`<meta>\` tag with ${attributeDescription}${contextMsg}. ${attributeType} should be unique within the \`<head>\` section.`, metaTag.node.location);
                return;
            }
        }
    }
    areMetaTagsDuplicate(meta1, meta2) {
        if (meta1.nameValue && meta2.nameValue) {
            return meta1.nameValue.toLowerCase() === meta2.nameValue.toLowerCase();
        }
        if (meta1.httpEquivValue && meta2.httpEquivValue) {
            return meta1.httpEquivValue.toLowerCase() === meta2.httpEquivValue.toLowerCase();
        }
        return false;
    }
}
class HTMLNoDuplicateMetaNamesRule extends ParserRule {
    static autocorrectable = false;
    name = "html-no-duplicate-meta-names";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLNoDuplicateMetaNamesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const RESTRICTED_ATTRIBUTES = new Set([
    'id',
    'class',
    'name',
    'for',
    'src',
    'href',
    'title',
    'data',
    'role'
]);
function isRestrictedAttribute(attributeName) {
    if (RESTRICTED_ATTRIBUTES.has(attributeName)) {
        return true;
    }
    if (attributeName.startsWith('data-')) {
        return true;
    }
    if (attributeName.startsWith('aria-')) {
        return true;
    }
    return false;
}
function isDataAttribute(attributeName) {
    return attributeName.startsWith('data-');
}
/**
 * Visitor that checks if a node tree contains any output content.
 * Output content includes:
 * - Non-whitespace literal text (LiteralNode)
 * - ERB output tags (<%= %>, <%== %>)
 */
class ContainsOutputContentVisitor extends Visitor {
    hasOutputContent = false;
    visitLiteralNode(node) {
        if (this.hasOutputContent)
            return;
        if (node.content && node.content.trim() !== "") {
            this.hasOutputContent = true;
            return;
        }
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        if (this.hasOutputContent)
            return;
        if (isERBOutputNode(node)) {
            this.hasOutputContent = true;
            return;
        }
        this.visitChildNodes(node);
    }
}
function containsOutputContent(node) {
    const visitor = new ContainsOutputContentVisitor();
    visitor.visit(node);
    return visitor.hasOutputContent;
}
class NoEmptyAttributesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        this.checkEmptyAttribute(attributeName, attributeValue, attributeNode);
    }
    checkDynamicAttributeStaticValue({ combinedName, attributeValue, attributeNode }) {
        const name = (combinedName || "").toLowerCase();
        this.checkEmptyAttribute(name, attributeValue, attributeNode);
    }
    checkEmptyAttribute(attributeName, attributeValue, attributeNode) {
        if (!isRestrictedAttribute(attributeName))
            return;
        if (attributeValue.trim() !== "")
            return;
        if (!attributeNode?.value)
            return;
        if (containsOutputContent(attributeNode.value))
            return;
        const hasExplicitValue = attributeNode.value !== null;
        if (isDataAttribute(attributeName)) {
            if (hasExplicitValue) {
                this.addOffense(`Data attribute \`${attributeName}\` should not have an empty value. Either provide a meaningful value or use \`${attributeName}\` instead of \`${IdentityPrinter.print(attributeNode)}\`.`, attributeNode.location);
            }
            return;
        }
        this.addOffense(`Attribute \`${attributeName}\` must not be empty. Either provide a meaningful value or remove the attribute entirely.`, attributeNode.location);
    }
}
class HTMLNoEmptyAttributesRule extends ParserRule {
    name = "html-no-empty-attributes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new NoEmptyAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoEmptyHeadingsVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        this.checkHeadingElement(node);
        super.visitHTMLElementNode(node);
    }
    checkHeadingElement(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (!tagName) {
            return;
        }
        const isStandardHeading = HEADING_TAGS.has(tagName);
        const isAriaHeading = this.hasHeadingRole(openTag);
        if (!isStandardHeading && !isAriaHeading) {
            return;
        }
        if (this.isEmptyHeading(node)) {
            const elementDescription = isStandardHeading
                ? `\`<${tagName}>\``
                : `\`<${tagName} role="heading">\``;
            this.addOffense(`Heading element ${elementDescription} must not be empty. Provide accessible text content for screen readers and SEO.`, node.location);
        }
    }
    isEmptyHeading(node) {
        if (!node.body || node.body.length === 0) {
            return true;
        }
        let hasAccessibleContent = false;
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                if (this.isElementAccessible(elementNode)) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else {
                hasAccessibleContent = true;
                break;
            }
        }
        return !hasAccessibleContent;
    }
    hasHeadingRole(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "heading";
    }
    isElementAccessible(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return true;
        }
        const openTag = node.open_tag;
        const attributes = getAttributes(openTag);
        const ariaHiddenAttribute = findAttributeByName(attributes, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return false;
            }
        }
        if (!node.body || node.body.length === 0) {
            return false;
        }
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                if (this.isElementAccessible(elementNode)) {
                    return true;
                }
            }
            else {
                // If there's any non-literal/non-text/non-element content (like ERB), consider it accessible
                return true;
            }
        }
        return false;
    }
}
class HTMLNoEmptyHeadingsRule extends ParserRule {
    name = "html-no-empty-headings";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoEmptyHeadingsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NestedLinkVisitor extends BaseRuleVisitor {
    linkStack = [];
    checkNestedLink(openTag) {
        if (this.linkStack.length > 0) {
            this.addOffense("Nested `<a>` elements are not allowed. Links cannot contain other links.", openTag.tag_name.location);
            return true;
        }
        return false;
    }
    visitHTMLElementNode(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            super.visitHTMLElementNode(node);
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (tagName !== "a") {
            super.visitHTMLElementNode(node);
            return;
        }
        // If we're already inside a link, this is a nested link
        this.checkNestedLink(openTag);
        this.linkStack.push(openTag);
        super.visitHTMLElementNode(node);
        this.linkStack.pop();
    }
    // Handle self-closing <a> tags (though they're not valid HTML, they might exist)
    visitHTMLOpenTagNode(node) {
        const tagName = getTagName(node);
        if (tagName === "a" && node.is_void) {
            this.checkNestedLink(node);
        }
        super.visitHTMLOpenTagNode(node);
    }
}
class HTMLNoNestedLinksRule extends ParserRule {
    name = "html-no-nested-links";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NestedLinkVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoPositiveTabIndexVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "tabindex")
            return;
        const tabIndexValue = parseInt(attributeValue, 10);
        if (!isNaN(tabIndexValue) && tabIndexValue > 0) {
            this.addOffense(`Do not use positive \`tabindex\` values as they are error prone and can severely disrupt navigation experience for keyboard users. Use \`tabindex="0"\` to make an element focusable or \`tabindex="-1"\` to remove it from the tab sequence.`, attributeNode.location);
        }
    }
}
class HTMLNoPositiveTabIndexRule extends ParserRule {
    name = "html-no-positive-tab-index";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoPositiveTabIndexVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoSelfClosingVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (getTagName$1(node) === "svg") {
            this.visit(node.open_tag);
        }
        else {
            this.visitChildNodes(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_closing?.value === "/>") {
            const tagName = getTagName$1(node);
            const instead = isVoidElement(tagName) ? `<${tagName}>` : `<${tagName}></${tagName}>`;
            this.addOffense(`Use \`${instead}\` instead of self-closing \`<${tagName} />\` for HTML compatibility.`, node.location, {
                node,
                tagName,
                isVoid: isVoidElement(tagName)
            });
        }
    }
}
class HTMLNoSelfClosingRule extends ParserRule {
    static autocorrectable = true;
    name = "html-no-self-closing";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/views/**/*_mailer/**/*"]
        };
    }
    check(result, context) {
        const visitor = new NoSelfClosingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, tagName, isVoid } = offense.autofixContext;
        const { tag_closing } = node;
        if (!tag_closing)
            return null;
        tag_closing.value = ">";
        if (node.children && Array.isArray(node.children)) {
            const children = node.children;
            if (children.length > 0 && isWhitespaceNode(children[children.length - 1])) {
                node.children = children.slice(0, -1);
            }
        }
        if (!isVoid) {
            const parent = findParent(result.value, node);
            if (parent && parent.type === "AST_HTML_ELEMENT_NODE") {
                const tag_opening = { type: "TOKEN_HTML_TAG_START_CLOSE", value: "</", location: Location.zero, range: [0, 0] };
                const tag_name = { type: "TOKEN_IDENTIFIER", value: tagName, location: Location.zero, range: [0, 0] };
                const tag_closing = { type: "TOKEN_HTML_TAG_END", value: ">", location: Location.zero, range: [0, 0] };
                parent.close_tag = HTMLCloseTagNode.from({
                    type: "AST_HTML_CLOSE_TAG_NODE",
                    tag_opening,
                    tag_name,
                    tag_closing,
                    children: [],
                    errors: [],
                    location: Location.zero,
                });
            }
        }
        return result;
    }
}

const MESSAGES = {
    EXTRA_SPACE_NO_SPACE: "Extra space detected where there should be no space.",
    EXTRA_SPACE_SINGLE_SPACE: "Extra space detected where there should be a single space.",
    EXTRA_SPACE_SINGLE_BREAK: "Extra space detected where there should be a single space or a single line break.",
    NO_SPACE_SINGLE_SPACE: "No space detected where there should be a single space.",
};
class HTMLNoSpaceInTagVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        if (node.isSingleLine) {
            this.checkSingleLineTag(node);
        }
        else {
            this.checkMultilineTag(node);
        }
    }
    visitHTMLCloseTagNode(node) {
        this.reportAllWhitespace(node.children, MESSAGES.EXTRA_SPACE_NO_SPACE);
    }
    checkSingleLineTag(node) {
        const { children, tag_closing } = node;
        const isSelfClosing = tag_closing ? this.isSelfClosing(tag_closing) : false;
        this.checkWhitespaceInSingleLineTag(children, isSelfClosing);
        this.checkMissingSpaceBeforeSelfClosing(node, children, isSelfClosing);
    }
    checkWhitespaceInSingleLineTag(children, isSelfClosing) {
        const whitespaceNodes = filterWhitespaceNodes(children);
        whitespaceNodes.forEach((whitespace) => {
            const content = this.getWhitespaceContent(whitespace);
            if (!content)
                return;
            const isLastChild = children[children.length - 1] === whitespace;
            if (isLastChild) {
                this.checkTrailingWhitespace(whitespace, content, isSelfClosing);
                return;
            }
            if (content.length > 1) {
                this.addOffense(MESSAGES.EXTRA_SPACE_SINGLE_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_SINGLE_SPACE });
            }
        });
    }
    checkTrailingWhitespace(whitespace, content, isSelfClosing) {
        if (isSelfClosing && content === ' ')
            return;
        this.addOffense(MESSAGES.EXTRA_SPACE_NO_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_NO_SPACE });
    }
    checkMissingSpaceBeforeSelfClosing(node, children, isSelfClosing) {
        if (!isSelfClosing)
            return;
        const lastChild = children[children.length - 1];
        if (lastChild && isWhitespaceNode(lastChild))
            return;
        const lastNonWhitespace = children.filter(child => !isWhitespaceNode(child)).pop();
        const locationToReport = lastNonWhitespace?.location ?? node.tag_name?.location ?? node.location;
        this.addOffense(MESSAGES.NO_SPACE_SINGLE_SPACE, locationToReport, { node, message: MESSAGES.NO_SPACE_SINGLE_SPACE });
    }
    checkMultilineTag(node) {
        const whitespaceNodes = filterWhitespaceNodes(node.children);
        let previousWhitespace = null;
        whitespaceNodes.forEach((whitespace, index) => {
            const content = this.getWhitespaceContent(whitespace);
            if (!content)
                return;
            if (this.hasConsecutiveNewlines(content, previousWhitespace)) {
                this.addOffense(MESSAGES.EXTRA_SPACE_SINGLE_BREAK, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_SINGLE_BREAK });
                previousWhitespace = whitespace;
                return;
            }
            if (this.isNonNewlineWhitespace(content)) {
                this.checkIndentation(whitespace, index, whitespaceNodes.length, node);
            }
            previousWhitespace = whitespace;
        });
    }
    hasConsecutiveNewlines(content, previousWhitespace) {
        if (content === "\n")
            return previousWhitespace?.value?.value === "\n";
        if (!content.includes("\n"))
            return false;
        const newlines = content.match(/\n/g);
        return (newlines?.length ?? 0) > 1;
    }
    isNonNewlineWhitespace(content) {
        return !content.includes("\n");
    }
    checkIndentation(whitespace, index, totalWhitespaceNodes, node) {
        const isLastWhitespace = index === totalWhitespaceNodes - 1;
        const expectedIndent = isLastWhitespace ? node.location.start.column : node.location.start.column + 2;
        if (whitespace.location.end.column === expectedIndent)
            return;
        this.addOffense(MESSAGES.EXTRA_SPACE_NO_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_NO_SPACE });
    }
    isSelfClosing(tag_closing) {
        return tag_closing?.value?.includes('/') ?? false;
    }
    getWhitespaceContent(whitespace) {
        return whitespace.value?.value ?? null;
    }
    reportAllWhitespace(nodes, message) {
        const whitespaceNodes = Array.isArray(nodes) && nodes.length > 0 && !isWhitespaceNode(nodes[0])
            ? filterWhitespaceNodes(nodes)
            : nodes;
        whitespaceNodes.forEach(whitespace => {
            this.addOffense(message, whitespace.location, { node: whitespace, message });
        });
    }
}
class HTMLNoSpaceInTagRule extends ParserRule {
    // TODO: enable and fix autofix
    static autocorrectable = false;
    name = "html-no-space-in-tag";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLNoSpaceInTagVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, message } = offense.autofixContext;
        if (!node)
            return null;
        if (isHTMLOpenTagNode(node)) {
            const token = Token.from({ type: "TOKEN_WHITESPACE", value: " ", range: [0, 0], location: Location.zero });
            const whitespace = new WhitespaceNode({ type: "AST_WHITESPACE_NODE", value: token, location: Location.zero, errors: [] });
            node.children.push(whitespace);
            return result;
        }
        if (!isWhitespaceNode(node))
            return null;
        const whitespaceNode = node;
        if (!whitespaceNode.value)
            return null;
        switch (message) {
            case MESSAGES.EXTRA_SPACE_NO_SPACE: {
                let selfClosing = false;
                let beginningOfLine = false;
                const parent = findParent(result.value, node);
                if (parent && isHTMLOpenTagNode(parent)) {
                    selfClosing = parent.tag_closing?.value === "/>";
                    beginningOfLine = node.location.start.column === 0;
                }
                whitespaceNode.value.value = selfClosing && !beginningOfLine ? " " : "";
                return result;
            }
            case MESSAGES.EXTRA_SPACE_SINGLE_BREAK: {
                if (whitespaceNode.value.value.includes("\n")) {
                    whitespaceNode.value.value = "";
                }
                else {
                    whitespaceNode.value.value = " ";
                }
                return result;
            }
            case MESSAGES.EXTRA_SPACE_SINGLE_SPACE:
            case MESSAGES.NO_SPACE_SINGLE_SPACE: {
                whitespaceNode.value.value = " ";
                return result;
            }
            default: return null;
        }
    }
}

class NoTitleAttributeVisitor extends BaseRuleVisitor {
    ALLOWED_ELEMENTS_WITH_TITLE = new Set(["iframe", "link"]);
    visitHTMLOpenTagNode(node) {
        this.checkTitleAttribute(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkTitleAttribute(node) {
        const tagName = getTagName(node);
        if (!tagName || this.ALLOWED_ELEMENTS_WITH_TITLE.has(tagName)) {
            return;
        }
        if (hasAttribute(node, "title")) {
            this.addOffense("The `title` attribute should never be used as it is inaccessible for several groups of users. Use `aria-label` or `aria-describedby` instead. Exceptions are provided for `<iframe>` and `<link>` elements.", node.tag_name.location);
        }
    }
}
class HTMLNoTitleAttributeRule extends ParserRule {
    name = "html-no-title-attribute";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoTitleAttributeVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLNoUnderscoresInAttributeNamesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkDynamicAttributeStaticValue({ nameNodes, attributeNode }) {
        const attributeName = getStaticContentFromNodes(nameNodes);
        this.check(attributeName, attributeNode);
    }
    checkDynamicAttributeDynamicValue({ nameNodes, attributeNode }) {
        const attributeName = getStaticContentFromNodes(nameNodes);
        this.check(attributeName, attributeNode);
    }
    check(attributeName, attributeNode) {
        if (!attributeName)
            return;
        if (attributeName.includes("_")) {
            this.addOffense(`Attribute \`${IdentityPrinter.print(attributeNode.name)}\` should not contain underscores. Use hyphens (-) instead.`, attributeNode.name?.location ?? attributeNode.location);
        }
    }
}
class HTMLNoUnderscoresInAttributeNamesRule extends ParserRule {
    name = "html-no-underscores-in-attribute-names";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new HTMLNoUnderscoresInAttributeNamesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class XMLDeclarationChecker extends BaseRuleVisitor {
    hasXMLDeclaration = false;
    visitXMLDeclarationNode(_node) {
        this.hasXMLDeclaration = true;
    }
    visitChildNodes(node) {
        if (this.hasXMLDeclaration)
            return;
        super.visitChildNodes(node);
    }
}
class TagNameLowercaseVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (getTagName$1(node).toLowerCase() === "svg") {
            this.checkTagName(node.open_tag);
            this.checkTagName(node.close_tag);
        }
        else {
            super.visitHTMLElementNode(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        this.checkTagName(node);
    }
    visitHTMLCloseTagNode(node) {
        this.checkTagName(node);
    }
    checkTagName(node) {
        if (!node)
            return;
        const tagName = getTagName$1(node);
        if (!tagName)
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const type = isNode(node, HTMLOpenTagNode) ? "Opening" : "Closing";
        const open = isNode(node, HTMLOpenTagNode) ? "<" : "</";
        if (tagName !== lowercaseTagName) {
            this.addOffense(`${type} tag name \`${open}${tagName}>\` should be lowercase. Use \`${open}${lowercaseTagName}>\` instead.`, node.tag_name.location, {
                node,
                tagName,
                correctedTagName: lowercaseTagName
            });
        }
    }
}
class HTMLTagNameLowercaseRule extends ParserRule {
    static autocorrectable = true;
    name = "html-tag-name-lowercase";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/*.xml", "**/*.xml.erb"]
        };
    }
    isEnabled(result, _context) {
        const checker = new XMLDeclarationChecker(this.name);
        checker.visit(result.value);
        return !checker.hasXMLDeclaration;
    }
    check(result, context) {
        const visitor = new TagNameLowercaseVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { tag_name }, correctedTagName } = offense.autofixContext;
        if (!tag_name)
            return null;
        tag_name.value = correctedTagName;
        return result;
    }
}

class SVGTagNameCapitalizationVisitor extends BaseRuleVisitor {
    insideSVG = false;
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName && ["svg"].includes(tagName.toLowerCase())) {
            const wasInsideSVG = this.insideSVG;
            this.insideSVG = true;
            this.visitChildNodes(node);
            this.insideSVG = wasInsideSVG;
            return;
        }
        if (this.insideSVG) {
            if (node.open_tag) {
                this.checkTagName(node.open_tag);
            }
            if (node.close_tag) {
                this.checkTagName(node.close_tag);
            }
        }
        this.visitChildNodes(node);
    }
    checkTagName(node) {
        const tagName = node.tag_name?.value;
        if (!tagName)
            return;
        if (SVG_CAMEL_CASE_ELEMENTS.has(tagName))
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const correctCamelCase = SVG_LOWERCASE_TO_CAMELCASE.get(lowercaseTagName);
        if (correctCamelCase && tagName !== correctCamelCase) {
            let type = node.type;
            if (node.type === "AST_HTML_OPEN_TAG_NODE")
                type = "Opening";
            if (node.type === "AST_HTML_CLOSE_TAG_NODE")
                type = "Closing";
            this.addOffense(`${type} SVG tag name \`${tagName}\` should use proper capitalization. Use \`${correctCamelCase}\` instead.`, node.tag_name.location, {
                node,
                currentTagName: tagName,
                correctCamelCase
            });
        }
    }
}
class SVGTagNameCapitalizationRule extends ParserRule {
    static autocorrectable = true;
    name = "svg-tag-name-capitalization";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new SVGTagNameCapitalizationVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { tag_name }, correctCamelCase } = offense.autofixContext;
        if (!tag_name)
            return null;
        tag_name.value = correctCamelCase;
        return result;
    }
}

class ParserNoErrorsRule extends ParserRule {
    name = "parser-no-errors";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result) {
        return result.recursiveErrors().map(error => this.herbErrorToLintOffense(error));
    }
    herbErrorToLintOffense(error) {
        return {
            message: `${error.message} (\`${error.type}\`)`,
            location: error.location,
            severity: error.severity,
            rule: this.name,
            code: this.name,
            source: "linter"
        };
    }
}

const rules = [
    ERBCommentSyntax,
    ERBNoCaseNodeChildrenRule,
    ERBNoEmptyTagsRule,
    ERBNoExtraNewLineRule,
    ERBNoExtraWhitespaceRule,
    ERBNoOutputControlFlowRule,
    ERBNoSilentTagInAttributeNameRule,
    ERBPreferImageTagHelperRule,
    ERBRequireTrailingNewlineRule,
    ERBRequireWhitespaceRule,
    ERBRightTrimRule,
    HerbDisableCommentValidRuleNameRule,
    HerbDisableCommentNoRedundantAllRule,
    HerbDisableCommentNoDuplicateRulesRule,
    HerbDisableCommentMissingRulesRule,
    HerbDisableCommentMalformedRule,
    HerbDisableCommentUnnecessaryRule,
    HTMLAnchorRequireHrefRule,
    HTMLAriaAttributeMustBeValid,
    HTMLAriaLabelIsWellFormattedRule,
    HTMLAriaLevelMustBeValidRule,
    HTMLAriaRoleHeadingRequiresLevelRule,
    HTMLAriaRoleMustBeValidRule,
    HTMLAttributeDoubleQuotesRule,
    HTMLAttributeEqualsSpacingRule,
    HTMLAttributeValuesRequireQuotesRule,
    HTMLAvoidBothDisabledAndAriaDisabledRule,
    HTMLBodyOnlyElementsRule,
    HTMLBooleanAttributesNoValueRule,
    HTMLHeadOnlyElementsRule,
    HTMLIframeHasTitleRule,
    HTMLImgRequireAltRule,
    HTMLInputRequireAutocompleteRule,
    HTMLNavigationHasLabelRule,
    HTMLNoAriaHiddenOnFocusableRule,
    HTMLNoBlockInsideInlineRule,
    HTMLNoDuplicateAttributesRule,
    HTMLNoDuplicateIdsRule,
    HTMLNoDuplicateMetaNamesRule,
    HTMLNoEmptyAttributesRule,
    HTMLNoEmptyHeadingsRule,
    HTMLNoNestedLinksRule,
    HTMLNoPositiveTabIndexRule,
    HTMLNoSelfClosingRule,
    HTMLNoSpaceInTagRule,
    HTMLNoTitleAttributeRule,
    HTMLNoUnderscoresInAttributeNamesRule,
    HTMLTagNameLowercaseRule,
    SVGTagNameCapitalizationRule,
    ParserNoErrorsRule,
];

const HERB_LINTER_PREFIX = "herb:linter";
const HERB_LINTER_IGNORE_PREFIX = `${HERB_LINTER_PREFIX} ignore`;
/**
 * Check if an ERB content node is a herb:linter ignore comment.
 *
 * @param node - The ERB content node to check
 * @returns true if this is a linter ignore directive
 */
function isHerbLinterIgnoreComment(node) {
    if (!isERBCommentNode(node))
        return false;
    const content = node?.content?.value || "";
    return content.trim() === HERB_LINTER_IGNORE_PREFIX;
}
/**
 * Check if the document contains a herb:linter ignore directive anywhere.
 */
function hasLinterIgnoreDirective(parseResult) {
    if (parseResult.failed)
        return false;
    const detector = new LinterIgnoreDetector();
    detector.visit(parseResult.value);
    return detector.hasIgnoreDirective;
}
/**
 * Visitor that detects if the AST contains a herb:linter ignore directive.
 */
class LinterIgnoreDetector extends Visitor {
    hasIgnoreDirective = false;
    visitERBContentNode(node) {
        if (isHerbLinterIgnoreComment(node)) {
            this.hasIgnoreDirective = true;
            return;
        }
        if (this.hasIgnoreDirective)
            return;
        this.visitChildNodes(node);
    }
}

class Linter {
    rules;
    allAvailableRules;
    herb;
    offenses;
    config;
    /**
     * Creates a new Linter instance with automatic rule filtering based on config.
     *
     * @param herb - The Herb backend instance for parsing and lexing
     * @param config - Optional full Config instance for rule filtering, severity overrides, and path-based filtering
     * @param customRules - Optional array of custom rules to include alongside built-in rules
     * @returns A configured Linter instance
     */
    static from(herb, config, customRules) {
        const allRules = customRules ? [...rules, ...customRules] : rules;
        const filteredRules = config?.linter?.rules
            ? Linter.filterRulesByConfig(allRules, config.linter.rules)
            : undefined;
        return new Linter(herb, filteredRules, config, allRules);
    }
    /**
     * Creates a new Linter instance.
     *
     * For most use cases, prefer `Linter.from()` which handles config-based filtering.
     * Use this constructor directly when you need explicit control over rules.
     *
     * @param herb - The Herb backend instance for parsing and lexing
     * @param rules - Array of rule classes (Parser/AST or Lexer) to use. If not provided, uses default rules.
     * @param config - Optional full Config instance for severity overrides and path-based rule filtering
     * @param allAvailableRules - Optional array of ALL available rules (including disabled) for herb:disable validation
     */
    constructor(herb, rules, config, allAvailableRules) {
        this.herb = herb;
        this.config = config;
        this.rules = rules !== undefined ? rules : this.getDefaultRules();
        this.allAvailableRules = allAvailableRules !== undefined ? allAvailableRules : this.rules;
        this.offenses = [];
    }
    /**
     * Filters rules based on default config and optional user config overrides.
     *
     * Priority:
     * 1. User config override (if rule config exists in userRulesConfig)
     * 2. Default config from rule's defaultConfig getter
     *
     * @param allRules - All available rule classes to filter from
     * @param userRulesConfig - Optional user configuration for rules
     * @returns Filtered array of rule classes that should be enabled
     */
    static filterRulesByConfig(allRules, userRulesConfig) {
        return allRules.filter(ruleClass => {
            const instance = new ruleClass();
            const ruleName = instance.name;
            const defaultEnabled = instance.defaultConfig?.enabled ?? DEFAULT_RULE_CONFIG.enabled;
            const userRuleConfig = userRulesConfig?.[ruleName];
            if (userRuleConfig !== undefined) {
                return userRuleConfig.enabled !== false;
            }
            return defaultEnabled;
        });
    }
    /**
     * Returns the default set of rule classes used by the linter.
     * These are the rules enabled when no custom rules are provided.
     * Filters all available rules to only include those enabled by default.
     * @returns Array of default rule classes
     */
    getDefaultRules() {
        return Linter.filterRulesByConfig(rules);
    }
    /**
     * Returns all available rule classes that can be referenced in herb:disable comments.
     * This includes all rules that exist, regardless of whether they're currently enabled.
     * Includes both built-in rules and any loaded custom rules.
     * @returns Array of all available rule classes
     */
    getAvailableRules() {
        return this.allAvailableRules;
    }
    /**
     * Meta-linting rules for herb:disable comments cannot be disabled
     * This ensures that invalid herb:disable comments are always caught
     */
    get nonExcludableRules() {
        return [
            "herb-disable-comment-valid-rule-name",
            "herb-disable-comment-no-redundant-all",
            "herb-disable-comment-no-duplicate-rules",
            "herb-disable-comment-malformed",
            "herb-disable-comment-missing-rules",
            "herb-disable-comment-unnecessary"
        ];
    }
    getRuleCount() {
        return this.rules.length;
    }
    /**
     * Type guard to check if a rule is a LexerRule
     */
    isLexerRule(rule) {
        return rule.constructor.type === "lexer";
    }
    /**
     * Type guard to check if a rule is a SourceRule
     */
    isSourceRule(rule) {
        return rule.constructor.type === "source";
    }
    /**
     * Execute a single rule and return its unbound offenses.
     * Handles rule type checking (Lexer/Parser/Source) and isEnabled checks.
     */
    executeRule(rule, parseResult, lexResult, source, context) {
        if (this.config && context?.fileName) {
            if (!this.config.isRuleEnabledForPath(rule.name, context.fileName)) {
                return [];
            }
        }
        if (context?.fileName && !this.config?.linter?.rules?.[rule.name]?.exclude) {
            const defaultExclude = rule.defaultConfig?.exclude ?? DEFAULT_RULE_CONFIG.exclude;
            if (defaultExclude && defaultExclude.length > 0) {
                const isExcluded = defaultExclude.some((pattern) => minimatch(context.fileName, pattern));
                if (isExcluded) {
                    return [];
                }
            }
        }
        let isEnabled = true;
        let ruleOffenses;
        if (this.isLexerRule(rule)) {
            if (rule.isEnabled) {
                isEnabled = rule.isEnabled(lexResult, context);
            }
            if (isEnabled) {
                ruleOffenses = rule.check(lexResult, context);
            }
            else {
                ruleOffenses = [];
            }
        }
        else if (this.isSourceRule(rule)) {
            if (rule.isEnabled) {
                isEnabled = rule.isEnabled(source, context);
            }
            if (isEnabled) {
                ruleOffenses = rule.check(source, context);
            }
            else {
                ruleOffenses = [];
            }
        }
        else {
            if (rule.isEnabled) {
                isEnabled = rule.isEnabled(parseResult, context);
            }
            if (isEnabled) {
                ruleOffenses = rule.check(parseResult, context);
            }
            else {
                ruleOffenses = [];
            }
        }
        return ruleOffenses;
    }
    filterOffenses(ruleOffenses, ruleName, ignoredOffensesByLine, herbDisableCache, ignoreDisableComments) {
        const kept = [];
        const ignored = [];
        const wouldBeIgnored = [];
        if (this.nonExcludableRules.includes(ruleName)) {
            return { kept: ruleOffenses, ignored: [], wouldBeIgnored: [] };
        }
        if (ignoreDisableComments) {
            for (const offense of ruleOffenses) {
                const line = offense.location.start.line;
                const disabledRules = herbDisableCache?.get(line) || [];
                if (disabledRules.includes(ruleName) || disabledRules.includes("all")) {
                    wouldBeIgnored.push(offense);
                }
            }
            return { kept: ruleOffenses, ignored: [], wouldBeIgnored };
        }
        for (const offense of ruleOffenses) {
            const line = offense.location.start.line;
            const disabledRules = herbDisableCache?.get(line) || [];
            if (disabledRules.includes(ruleName) || disabledRules.includes("all")) {
                ignored.push(offense);
                if (ignoredOffensesByLine) {
                    if (!ignoredOffensesByLine.has(line)) {
                        ignoredOffensesByLine.set(line, new Set());
                    }
                    const usedRuleName = disabledRules.includes(ruleName) ? ruleName : "all";
                    ignoredOffensesByLine.get(line).add(usedRuleName);
                }
                continue;
            }
            kept.push(offense);
        }
        return { kept, ignored, wouldBeIgnored: [] };
    }
    /**
     * Lint source code using Parser/AST, Lexer, and Source rules.
     * @param source - The source code to lint
     * @param context - Optional context for linting (e.g., fileName for distinguishing files vs snippets)
     */
    lint(source, context) {
        this.offenses = [];
        let ignoredCount = 0;
        let wouldBeIgnoredCount = 0;
        const parseResult = this.herb.parse(source, { track_whitespace: true });
        // Check for file-level ignore directive using visitor
        if (hasLinterIgnoreDirective(parseResult)) {
            return {
                offenses: [],
                errors: 0,
                warnings: 0,
                info: 0,
                hints: 0,
                ignored: 0
            };
        }
        const lexResult = this.herb.lex(source);
        const hasParserErrors = parseResult.recursiveErrors().length > 0;
        const sourceLines = source.split("\n");
        const ignoredOffensesByLine = new Map();
        const herbDisableCache = new Map();
        if (hasParserErrors) {
            const hasParserRule = this.rules.find(RuleClass => (new RuleClass()).name === "parser-no-errors");
            if (hasParserRule) {
                const rule = new ParserNoErrorsRule();
                const offenses = rule.check(parseResult);
                this.offenses.push(...offenses);
            }
            return {
                offenses: this.offenses,
                errors: this.offenses.filter(o => o.severity === "error").length,
                warnings: this.offenses.filter(o => o.severity === "warning").length,
                info: this.offenses.filter(o => o.severity === "info").length,
                hints: this.offenses.filter(o => o.severity === "hint").length,
                ignored: 0
            };
        }
        for (let i = 0; i < sourceLines.length; i++) {
            const line = sourceLines[i];
            if (line.includes("herb:disable")) {
                const herbDisable = parseHerbDisableLine(line);
                herbDisableCache.set(i + 1, herbDisable?.ruleNames || []);
            }
        }
        context = {
            ...context,
            validRuleNames: this.getAvailableRules().map(RuleClass => new RuleClass().name),
            ignoredOffensesByLine
        };
        const regularRules = this.rules.filter(RuleClass => {
            const rule = new RuleClass();
            return rule.name !== "herb-disable-comment-unnecessary";
        });
        for (const RuleClass of regularRules) {
            const rule = new RuleClass();
            const unboundOffenses = this.executeRule(rule, parseResult, lexResult, source, context);
            const boundOffenses = this.bindSeverity(unboundOffenses, rule.name);
            const { kept, ignored, wouldBeIgnored } = this.filterOffenses(boundOffenses, rule.name, ignoredOffensesByLine, herbDisableCache, context?.ignoreDisableComments);
            ignoredCount += ignored.length;
            wouldBeIgnoredCount += wouldBeIgnored.length;
            this.offenses.push(...kept);
        }
        const unnecessaryRuleClass = this.rules.find(RuleClass => {
            const rule = new RuleClass();
            return rule.name === "herb-disable-comment-unnecessary";
        });
        if (unnecessaryRuleClass) {
            const unnecessaryRule = new unnecessaryRuleClass();
            const unboundOffenses = unnecessaryRule.check(parseResult, context);
            const boundOffenses = this.bindSeverity(unboundOffenses, unnecessaryRule.name);
            this.offenses.push(...boundOffenses);
        }
        const finalOffenses = this.offenses;
        const errors = finalOffenses.filter(offense => offense.severity === "error").length;
        const warnings = finalOffenses.filter(offense => offense.severity === "warning").length;
        const info = finalOffenses.filter(offense => offense.severity === "info").length;
        const hints = finalOffenses.filter(offense => offense.severity === "hint").length;
        const result = {
            offenses: finalOffenses,
            errors,
            warnings,
            info,
            hints,
            ignored: ignoredCount
        };
        if (wouldBeIgnoredCount > 0) {
            result.wouldBeIgnored = wouldBeIgnoredCount;
        }
        return result;
    }
    /**
     * Bind severity to unbound offenses based on rule's defaultConfig and user config overrides.
     *
     * Priority:
     * 1. User config severity override (if specified in config)
     * 2. Rule's default severity (from defaultConfig.severity)
     *
     * @param unboundOffenses - Array of offenses without severity
     * @param ruleName - Name of the rule that produced the offenses
     * @returns Array of offenses with severity bound
     */
    bindSeverity(unboundOffenses, ruleName) {
        const RuleClass = this.rules.find(rule => {
            const instance = new rule();
            return instance.name === ruleName;
        });
        if (!RuleClass) {
            return unboundOffenses.map(offense => ({
                ...offense,
                severity: "error"
            }));
        }
        const ruleInstance = new RuleClass();
        const defaultSeverity = ruleInstance.defaultConfig?.severity ?? DEFAULT_RULE_CONFIG.severity;
        const userRuleConfig = this.config?.linter?.rules?.[ruleName];
        const severity = userRuleConfig?.severity ?? defaultSeverity;
        return unboundOffenses.map(offense => ({
            ...offense,
            severity
        }));
    }
    /**
     * Automatically fix offenses in the source code.
     * Uses AST mutation for parser rules and token mutation for lexer rules.
     * @param source - The source code to fix
     * @param context - Optional context for linting (e.g., fileName)
     * @param offensesToFix - Optional array of specific offenses to fix. If not provided, all fixable offenses will be fixed.
     * @returns AutofixResult containing the corrected source and lists of fixed/unfixed offenses
     */
    autofix(source, context, offensesToFix) {
        const lintResult = offensesToFix ? { offenses: offensesToFix } : this.lint(source, context);
        const parserOffenses = [];
        const sourceOffenses = [];
        for (const offense of lintResult.offenses) {
            const RuleClass = this.rules.find(rule => {
                const instance = new rule();
                return instance.name === offense.rule;
            });
            if (!RuleClass)
                continue;
            if (RuleClass.type === "lexer") ;
            else if (RuleClass.type === "source") {
                sourceOffenses.push(offense);
            }
            else {
                parserOffenses.push(offense);
            }
        }
        let currentSource = source;
        const fixed = [];
        const unfixed = [];
        if (parserOffenses.length > 0) {
            const parseResult = this.herb.parse(currentSource, { track_whitespace: true });
            for (const offense of parserOffenses) {
                const RuleClass = this.rules.find(rule => new rule().name === offense.rule);
                if (!RuleClass) {
                    unfixed.push(offense);
                    continue;
                }
                const rule = new RuleClass();
                if (!rule.autofix) {
                    unfixed.push(offense);
                    continue;
                }
                if (offense.autofixContext) {
                    const originalNodeType = offense.autofixContext.node.type;
                    const location = offense.autofixContext.node.location ? Location.from(offense.autofixContext.node.location) : offense.location;
                    const freshNode = findNodeByLocation(parseResult.value, location, (node) => node.type === originalNodeType);
                    if (freshNode) {
                        offense.autofixContext.node = freshNode;
                    }
                    else {
                        unfixed.push(offense);
                        continue;
                    }
                }
                const fixedResult = rule.autofix(offense, parseResult, context);
                if (fixedResult) {
                    fixed.push(offense);
                }
                else {
                    unfixed.push(offense);
                }
            }
            if (fixed.length > 0) {
                const printer = new IdentityPrinter();
                currentSource = printer.print(parseResult.value);
            }
        }
        if (sourceOffenses.length > 0) {
            const sortedSourceOffenses = sourceOffenses.sort((a, b) => {
                if (a.location.start.line !== b.location.start.line) {
                    return b.location.start.line - a.location.start.line;
                }
                return b.location.start.column - a.location.start.column;
            });
            for (const offense of sortedSourceOffenses) {
                const RuleClass = this.rules.find(rule => new rule().name === offense.rule);
                if (!RuleClass) {
                    unfixed.push(offense);
                    continue;
                }
                const rule = new RuleClass();
                if (!rule.autofix) {
                    unfixed.push(offense);
                    continue;
                }
                const correctedSource = rule.autofix(offense, currentSource, context);
                if (correctedSource) {
                    currentSource = correctedSource;
                    fixed.push(offense);
                }
                else {
                    unfixed.push(offense);
                }
            }
        }
        return {
            source: currentSource,
            fixed,
            unfixed
        };
    }
}

export { ARIA_ATTRIBUTES, AttributeVisitorMixin, BaseLexerRuleVisitor, BaseRuleVisitor, BaseSourceRuleVisitor, ControlFlowTrackingVisitor, ControlFlowType, DEFAULT_LINT_CONTEXT, DEFAULT_RULE_CONFIG, DOCUMENT_ONLY_TAG_NAMES, ERBCommentSyntax, ERBNoCaseNodeChildrenRule, ERBNoEmptyTagsRule, ERBNoExtraNewLineRule, ERBNoExtraWhitespaceRule, ERBNoOutputControlFlowRule, ERBNoSilentTagInAttributeNameRule, ERBPreferImageTagHelperRule, ERBRequireTrailingNewlineRule, ERBRequireWhitespaceRule, ERBRightTrimRule, HEADING_TAGS, HEAD_AND_BODY_TAG_NAMES, HEAD_ONLY_TAG_NAMES, HTMLAnchorRequireHrefRule, HTMLAriaLabelIsWellFormattedRule, HTMLAriaLevelMustBeValidRule, HTMLAriaRoleHeadingRequiresLevelRule, HTMLAriaRoleMustBeValidRule, HTMLAttributeDoubleQuotesRule, HTMLAttributeEqualsSpacingRule, HTMLAttributeValuesRequireQuotesRule, HTMLAvoidBothDisabledAndAriaDisabledRule, HTMLBodyOnlyElementsRule, HTMLBooleanAttributesNoValueRule, HTMLHeadOnlyElementsRule, HTMLIframeHasTitleRule, HTMLImgRequireAltRule, HTMLInputRequireAutocompleteRule, HTMLNavigationHasLabelRule, HTMLNoAriaHiddenOnFocusableRule, HTMLNoBlockInsideInlineRule, HTMLNoDuplicateAttributesRule, HTMLNoDuplicateIdsRule, HTMLNoDuplicateMetaNamesRule, HTMLNoEmptyAttributesRule, HTMLNoEmptyHeadingsRule, HTMLNoNestedLinksRule, HTMLNoPositiveTabIndexRule, HTMLNoSelfClosingRule, HTMLNoSpaceInTagRule, HTMLNoTitleAttributeRule, HTMLNoUnderscoresInAttributeNamesRule, HTMLTagNameLowercaseRule, HTML_BLOCK_ELEMENTS, HTML_BOOLEAN_ATTRIBUTES, HTML_INLINE_ELEMENTS, HTML_ONLY_TAG_NAMES, HTML_VOID_ELEMENTS, HerbDisableCommentBaseVisitor, HerbDisableCommentMalformedRule, HerbDisableCommentMissingRulesRule, HerbDisableCommentNoDuplicateRulesRule, HerbDisableCommentNoRedundantAllRule, HerbDisableCommentParsedVisitor, HerbDisableCommentUnnecessaryRule, HerbDisableCommentValidRuleNameRule, LexerRule, Linter, ParserRule, SVGTagNameCapitalizationRule, SVG_CAMEL_CASE_ELEMENTS, SVG_LOWERCASE_TO_CAMELCASE, SourceRule, VALID_ARIA_ROLES, createEndOfFileLocation, findAttributeByName, findNodeByLocation, findParent, forEachAttribute, getAttribute, getAttributeName, getAttributeValue, getAttributeValueNodes, getAttributeValueQuoteType, getAttributes, getCombinedAttributeNameString, getStaticAttributeValue, getStaticAttributeValueContent, getTagName, hasAttribute, hasAttributeValue, hasDynamicAttributeName, hasDynamicAttributeValue, hasStaticAttributeValue, hasStaticAttributeValueContent, isAttributeValueQuoted, isBlockElement, isBodyOnlyTag, isBodyTag, isBooleanAttribute, isDocumentOnlyTag, isHeadAndBodyTag, isHeadOnlyTag, isHeadTag, isHtmlOnlyTag, isInlineElement, isVoidElement, locationsEqual, rules };
//# sourceMappingURL=index.js.map

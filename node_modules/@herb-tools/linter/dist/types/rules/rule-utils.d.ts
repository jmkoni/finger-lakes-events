import { Visitor, Location } from "@herb-tools/core";
import type { HTMLAttributeNode, HTMLAttributeValueNode, HTMLElementNode, HTMLOpenTagNode, LexResult, Token, Node } from "@herb-tools/core";
import type * as Nodes from "@herb-tools/core";
import type { UnboundLintOffense, LintContext, BaseAutofixContext } from "../types.js";
export declare enum ControlFlowType {
    CONDITIONAL = 0,
    LOOP = 1
}
/**
 * Base visitor class that provides common functionality for rule visitors
 */
export declare abstract class BaseRuleVisitor<TAutofixContext extends BaseAutofixContext = BaseAutofixContext> extends Visitor {
    readonly offenses: UnboundLintOffense<TAutofixContext>[];
    protected ruleName: string;
    protected context: LintContext;
    constructor(ruleName: string, context?: Partial<LintContext>);
    /**
     * Helper method to create an unbound lint offense (without severity).
     * The Linter will bind severity based on the rule's config.
     */
    protected createOffense(message: string, location: Location, autofixContext?: TAutofixContext): UnboundLintOffense<TAutofixContext>;
    /**
     * Helper method to add an offense to the offenses array
     */
    protected addOffense(message: string, location: Location, autofixContext?: TAutofixContext): void;
}
/**
 * Mixin that adds control flow tracking capabilities to rule visitors
 * This allows rules to track state across different control flow structures
 * like if/else branches, loops, etc.
 *
 * @template TAutofixContext - Type for autofix context (node + custom data)
 * @template TControlFlowState - Type for state passed between onEnterControlFlow and onExitControlFlow
 * @template TBranchState - Type for state passed between onEnterBranch and onExitBranch
 */
export declare abstract class ControlFlowTrackingVisitor<TAutofixContext extends BaseAutofixContext = BaseAutofixContext, TControlFlowState = any, TBranchState = any> extends BaseRuleVisitor<TAutofixContext> {
    protected isInControlFlow: boolean;
    protected currentControlFlowType: ControlFlowType | null;
    /**
     * Handle visiting a control flow node with proper scope management
     */
    protected handleControlFlowNode(_node: Node, controlFlowType: ControlFlowType, visitChildren: () => void): void;
    /**
     * Handle visiting a branch node (like else, when) with proper scope management
     */
    protected startNewBranch(visitChildren: () => void): void;
    visitERBIfNode(node: Nodes.ERBIfNode): void;
    visitERBUnlessNode(node: Nodes.ERBUnlessNode): void;
    visitERBCaseNode(node: Nodes.ERBCaseNode): void;
    visitERBCaseMatchNode(node: Nodes.ERBCaseMatchNode): void;
    visitERBWhileNode(node: Nodes.ERBWhileNode): void;
    visitERBForNode(node: Nodes.ERBForNode): void;
    visitERBUntilNode(node: Nodes.ERBUntilNode): void;
    visitERBBlockNode(node: Nodes.ERBBlockNode): void;
    visitERBElseNode(node: Nodes.ERBElseNode): void;
    visitERBWhenNode(node: Nodes.ERBWhenNode): void;
    protected abstract onEnterControlFlow(controlFlowType: ControlFlowType, wasAlreadyInControlFlow: boolean): TControlFlowState;
    protected abstract onExitControlFlow(controlFlowType: ControlFlowType, wasAlreadyInControlFlow: boolean, stateToRestore: TControlFlowState): void;
    protected abstract onEnterBranch(): TBranchState;
    protected abstract onExitBranch(stateToRestore: TBranchState): void;
}
/**
 * Gets attributes from an HTMLOpenTagNode
 */
export declare function getAttributes(node: HTMLOpenTagNode): HTMLAttributeNode[];
/**
 * Gets the tag name from an HTML tag node (lowercased)
 */
export declare function getTagName(node: HTMLElementNode | HTMLOpenTagNode | null | undefined): string | null;
/**
 * Gets the attribute name from an HTMLAttributeNode (lowercased)
 * Returns null if the attribute name contains dynamic content (ERB)
 */
export declare function getAttributeName(attributeNode: HTMLAttributeNode, lowercase?: boolean): string | null;
/**
 * Checks if an attribute has a dynamic (ERB-containing) name
 */
export declare function hasDynamicAttributeName(attributeNode: HTMLAttributeNode): boolean;
/**
 * Gets the combined string representation of an attribute name (for debugging)
 * This includes both static content and ERB syntax
 */
export declare function getCombinedAttributeNameString(attributeNode: HTMLAttributeNode): string;
/**
 * Checks if an attribute value contains only static content (no ERB)
 */
export declare function hasStaticAttributeValue(attributeNode: HTMLAttributeNode): boolean;
/**
 * Checks if an attribute value contains dynamic content (ERB)
 */
export declare function hasDynamicAttributeValue(attributeNode: HTMLAttributeNode): boolean;
/**
 * Gets the static string value of an attribute (returns null if it contains ERB)
 */
export declare function getStaticAttributeValue(attributeNode: HTMLAttributeNode): string | null;
/**
 * Gets the value nodes array for dynamic inspection
 */
export declare function getAttributeValueNodes(attributeNode: HTMLAttributeNode): Node[];
/**
 * Checks if an attribute value contains any static content (for validation purposes)
 */
export declare function hasStaticAttributeValueContent(attributeNode: HTMLAttributeNode): boolean;
/**
 * Gets the static content of an attribute value (all literal parts combined)
 * Returns the concatenated literal content, or null if no literal nodes exist
 */
export declare function getStaticAttributeValueContent(attributeNode: HTMLAttributeNode): string | null;
/**
 * Gets the attribute value content from an HTMLAttributeValueNode
 */
export declare function getAttributeValue(attributeNode: HTMLAttributeNode): string | null;
/**
 * Checks if an attribute has a value
 */
export declare function hasAttributeValue(attributeNode: HTMLAttributeNode): boolean;
/**
 * Gets the quote type used for an attribute value
 */
export declare function getAttributeValueQuoteType(nodeOrAttribute: HTMLAttributeNode | HTMLAttributeValueNode): "single" | "double" | "none" | null;
/**
 * Finds an attribute by name in a list of attributes
 */
export declare function findAttributeByName(attributes: Node[], attributeName: string): HTMLAttributeNode | null;
/**
 * Checks if a tag has a specific attribute
 */
export declare function hasAttribute(node: HTMLOpenTagNode | null | undefined, attributeName: string): boolean;
/**
 * Checks if a tag has a specific attribute
 */
export declare function getAttribute(node: HTMLOpenTagNode, attributeName: string): HTMLAttributeNode | null;
/**
 * Common HTML element categorization
 */
export declare const HTML_INLINE_ELEMENTS: Set<string>;
export declare const HTML_BLOCK_ELEMENTS: Set<string>;
export declare const HTML_VOID_ELEMENTS: Set<string>;
export declare const HTML_BOOLEAN_ATTRIBUTES: Set<string>;
export declare const HEADING_TAGS: Set<string>;
/**
 * SVG elements that use camelCase naming
 */
export declare const SVG_CAMEL_CASE_ELEMENTS: Set<string>;
/**
 * Mapping from lowercase SVG element names to their correct camelCase versions
 * Generated dynamically from SVG_CAMEL_CASE_ELEMENTS
 */
export declare const SVG_LOWERCASE_TO_CAMELCASE: Map<string, string>;
export declare const VALID_ARIA_ROLES: Set<string>;
/**
 * Parameter types for AttributeVisitorMixin methods
 */
export interface StaticAttributeStaticValueParams {
    attributeName: string;
    attributeValue: string;
    attributeNode: HTMLAttributeNode;
    originalAttributeName: string;
    parentNode: HTMLOpenTagNode;
}
export interface StaticAttributeDynamicValueParams {
    attributeName: string;
    valueNodes: Node[];
    attributeNode: HTMLAttributeNode;
    originalAttributeName: string;
    parentNode: HTMLOpenTagNode;
    combinedValue?: string | null;
}
export interface DynamicAttributeStaticValueParams {
    nameNodes: Node[];
    attributeValue: string;
    attributeNode: HTMLAttributeNode;
    parentNode: HTMLOpenTagNode;
    combinedName?: string;
}
export interface DynamicAttributeDynamicValueParams {
    nameNodes: Node[];
    valueNodes: Node[];
    attributeNode: HTMLAttributeNode;
    parentNode: HTMLOpenTagNode;
    combinedName?: string;
    combinedValue?: string | null;
}
export declare const ARIA_ATTRIBUTES: Set<string>;
/**
 * Helper function to create a location at the end of the source with a 1-character range
 */
export declare function createEndOfFileLocation(source: string): Location;
/**
 * Checks if an element is inline
 */
export declare function isInlineElement(tagName: string): boolean;
/**
 * Checks if an element is block-level
 */
export declare function isBlockElement(tagName: string): boolean;
/**
 * Checks if an element is a void element
 */
export declare function isVoidElement(tagName: string): boolean;
/**
 * Checks if an attribute is a boolean attribute
 */
export declare function isBooleanAttribute(attributeName: string): boolean;
/**
 * Attribute visitor that provides granular processing based on both
 * attribute name type (static/dynamic) and value type (static/dynamic)
 *
 * This gives you 4 distinct methods to override:
 * - checkStaticAttributeStaticValue()   - name="class" value="foo"
 * - checkStaticAttributeDynamicValue()  - name="class" value="<%= css_class %>"
 * - checkDynamicAttributeStaticValue()  - name="data-<%= key %>" value="foo"
 * - checkDynamicAttributeDynamicValue() - name="data-<%= key %>" value="<%= value %>"
 */
export declare abstract class AttributeVisitorMixin<TAutofixContext extends BaseAutofixContext = BaseAutofixContext> extends BaseRuleVisitor<TAutofixContext> {
    constructor(ruleName: string, context?: Partial<LintContext>);
    visitHTMLOpenTagNode(node: HTMLOpenTagNode): void;
    private checkAttributesOnNode;
    /**
     * Static attribute name with static value: class="container"
     */
    protected checkStaticAttributeStaticValue(_params: StaticAttributeStaticValueParams): void;
    /**
     * Static attribute name with dynamic value: class="<%= css_class %>"
     */
    protected checkStaticAttributeDynamicValue(_params: StaticAttributeDynamicValueParams): void;
    /**
     * Dynamic attribute name with static value: data-<%= key %>="foo"
     */
    protected checkDynamicAttributeStaticValue(_params: DynamicAttributeStaticValueParams): void;
    /**
     * Dynamic attribute name with dynamic value: data-<%= key %>="<%= value %>"
     */
    protected checkDynamicAttributeDynamicValue(_params: DynamicAttributeDynamicValueParams): void;
}
/**
 * Checks if an attribute value is quoted
 */
export declare function isAttributeValueQuoted(attributeNode: HTMLAttributeNode): boolean;
/**
 * Iterates over all attributes of a tag node, calling the callback for each attribute
 */
export declare function forEachAttribute(node: HTMLOpenTagNode, callback: (attributeNode: HTMLAttributeNode) => void): void;
/**
 * Base lexer visitor class that provides common functionality for lexer-based rule visitors
 */
export declare abstract class BaseLexerRuleVisitor<TAutofixContext extends BaseAutofixContext = BaseAutofixContext> {
    readonly offenses: UnboundLintOffense<TAutofixContext>[];
    protected ruleName: string;
    protected context: LintContext;
    constructor(ruleName: string, context?: Partial<LintContext>);
    /**
     * Helper method to create an unbound lint offense (without severity).
     * The Linter will bind severity based on the rule's config.
     */
    protected createOffense(message: string, location: Location, autofixContext?: TAutofixContext): UnboundLintOffense<TAutofixContext>;
    /**
     * Helper method to add an offense to the offenses array
     */
    protected addOffense(message: string, location: Location, autofixContext?: TAutofixContext): void;
    /**
     * Main entry point for lexer rule visitors
     * @param lexResult - The lexer result containing tokens and source
     */
    visit(lexResult: LexResult): void;
    /**
     * Visit all tokens
     * Override this method to implement token-level checks
     */
    protected visitTokens(tokens: Token[]): void;
    /**
     * Visit individual tokens
     * Override this method to implement per-token checks
     */
    protected visitToken(_token: Token): void;
}
/**
 * Base source visitor class that provides common functionality for source-based rule visitors
 */
export declare abstract class BaseSourceRuleVisitor<TAutofixContext extends BaseAutofixContext = BaseAutofixContext> {
    readonly offenses: UnboundLintOffense<TAutofixContext>[];
    protected ruleName: string;
    protected context: LintContext;
    constructor(ruleName: string, context?: Partial<LintContext>);
    /**
     * Helper method to create an unbound lint offense (without severity).
     * The Linter will bind severity based on the rule's config.
     */
    protected createOffense(message: string, location: Location, autofixContext?: TAutofixContext): UnboundLintOffense<TAutofixContext>;
    /**
     * Helper method to add an offense to the offenses array
     */
    protected addOffense(message: string, location: Location, autofixContext?: TAutofixContext): void;
    /**
     * Main entry point for source rule visitors
     * @param source - The raw source code
     */
    visit(source: string): void;
    /**
     * Visit the source code directly
     * Override this method to implement source-level checks
     */
    protected abstract visitSource(source: string): void;
}
/**
 * Autofix utilities for applying string replacements
 */
/**
 * Checks if two locations are equal
 * @param a - First location
 * @param b - Second location
 * @returns true if locations are equal
 */
export declare function locationsEqual(a: Location, b: Location): boolean;
/**
 * Finds a node in the AST that has a specific location
 * Uses direct recursive traversal for reliability
 * @param root - The root node to search from
 * @param location - The location to match
 * @param predicate - Optional predicate function to filter nodes (e.g., isERBNode)
 * @returns The matching node or null if not found
 */
export declare function findNodeByLocation(root: Node, location: Location, predicate?: (node: Node) => boolean): any;
/**
 * AST Navigation Utilities
 * These utilities help navigate the AST tree for complex autofix operations
 */
/**
 * Finds the parent node of a given child node in the AST
 * @param root - The root node to search from (typically the document node)
 * @param target - The child node to find the parent of
 * @returns The parent node, or null if not found
 *
 * @example
 * const parent = findParent(result.value, offense.autofixContext.node)
 * if (parent?.type === "AST_HTML_ELEMENT_NODE") {
 *   // Modify parent...
 * }
 */
export declare function findParent(root: Node, target: Node): Node | null;
export declare const DOCUMENT_ONLY_TAG_NAMES: Set<string>;
export declare const HTML_ONLY_TAG_NAMES: Set<string>;
export declare const HEAD_ONLY_TAG_NAMES: Set<string>;
export declare const HEAD_AND_BODY_TAG_NAMES: Set<string>;
export declare function isDocumentOnlyTag(tagName: string): boolean;
export declare function isHtmlOnlyTag(tagName: string): boolean;
export declare function isHeadOnlyTag(tagName: string): boolean;
export declare function isHeadAndBodyTag(tagName: string): boolean;
export declare function isBodyOnlyTag(tagName: string): boolean;
export declare function isBodyTag(tagName: string): boolean;
export declare function isHeadTag(tagName: string): boolean;

import type { RuleClass, Rule, LexerRule, SourceRule, LintResult, LintOffense, UnboundLintOffense, LintContext, AutofixResult } from "./types.js";
import type { HerbBackend } from "@herb-tools/core";
import type { RuleConfig, Config } from "@herb-tools/config";
export interface LinterOptions {
    /**
     * Array of rule classes to use. If not provided, uses default rules.
     */
    rules?: RuleClass[];
    /**
     * Whether to load custom rules from the project.
     * Defaults to false for backward compatibility.
     */
    loadCustomRules?: boolean;
    /**
     * Base directory to search for custom rules.
     * Defaults to current working directory.
     */
    customRulesBaseDir?: string;
    /**
     * Custom glob patterns to search for rule files.
     */
    customRulesPatterns?: string[];
    /**
     * Whether to suppress custom rule loading errors.
     * Defaults to false.
     */
    silentCustomRules?: boolean;
}
export declare class Linter {
    protected rules: RuleClass[];
    protected allAvailableRules: RuleClass[];
    protected herb: HerbBackend;
    protected offenses: LintOffense[];
    protected config?: Config;
    /**
     * Creates a new Linter instance with automatic rule filtering based on config.
     *
     * @param herb - The Herb backend instance for parsing and lexing
     * @param config - Optional full Config instance for rule filtering, severity overrides, and path-based filtering
     * @param customRules - Optional array of custom rules to include alongside built-in rules
     * @returns A configured Linter instance
     */
    static from(herb: HerbBackend, config?: Config, customRules?: RuleClass[]): Linter;
    /**
     * Creates a new Linter instance.
     *
     * For most use cases, prefer `Linter.from()` which handles config-based filtering.
     * Use this constructor directly when you need explicit control over rules.
     *
     * @param herb - The Herb backend instance for parsing and lexing
     * @param rules - Array of rule classes (Parser/AST or Lexer) to use. If not provided, uses default rules.
     * @param config - Optional full Config instance for severity overrides and path-based rule filtering
     * @param allAvailableRules - Optional array of ALL available rules (including disabled) for herb:disable validation
     */
    constructor(herb: HerbBackend, rules?: RuleClass[], config?: Config, allAvailableRules?: RuleClass[]);
    /**
     * Filters rules based on default config and optional user config overrides.
     *
     * Priority:
     * 1. User config override (if rule config exists in userRulesConfig)
     * 2. Default config from rule's defaultConfig getter
     *
     * @param allRules - All available rule classes to filter from
     * @param userRulesConfig - Optional user configuration for rules
     * @returns Filtered array of rule classes that should be enabled
     */
    static filterRulesByConfig(allRules: RuleClass[], userRulesConfig?: Record<string, RuleConfig>): RuleClass[];
    /**
     * Returns the default set of rule classes used by the linter.
     * These are the rules enabled when no custom rules are provided.
     * Filters all available rules to only include those enabled by default.
     * @returns Array of default rule classes
     */
    protected getDefaultRules(): RuleClass[];
    /**
     * Returns all available rule classes that can be referenced in herb:disable comments.
     * This includes all rules that exist, regardless of whether they're currently enabled.
     * Includes both built-in rules and any loaded custom rules.
     * @returns Array of all available rule classes
     */
    protected getAvailableRules(): RuleClass[];
    /**
     * Meta-linting rules for herb:disable comments cannot be disabled
     * This ensures that invalid herb:disable comments are always caught
     */
    protected get nonExcludableRules(): string[];
    getRuleCount(): number;
    /**
     * Type guard to check if a rule is a LexerRule
     */
    protected isLexerRule(rule: Rule): rule is LexerRule;
    /**
     * Type guard to check if a rule is a SourceRule
     */
    protected isSourceRule(rule: Rule): rule is SourceRule;
    /**
     * Execute a single rule and return its unbound offenses.
     * Handles rule type checking (Lexer/Parser/Source) and isEnabled checks.
     */
    private executeRule;
    private filterOffenses;
    /**
     * Lint source code using Parser/AST, Lexer, and Source rules.
     * @param source - The source code to lint
     * @param context - Optional context for linting (e.g., fileName for distinguishing files vs snippets)
     */
    lint(source: string, context?: Partial<LintContext>): LintResult;
    /**
     * Bind severity to unbound offenses based on rule's defaultConfig and user config overrides.
     *
     * Priority:
     * 1. User config severity override (if specified in config)
     * 2. Rule's default severity (from defaultConfig.severity)
     *
     * @param unboundOffenses - Array of offenses without severity
     * @param ruleName - Name of the rule that produced the offenses
     * @returns Array of offenses with severity bound
     */
    protected bindSeverity(unboundOffenses: UnboundLintOffense[], ruleName: string): LintOffense[];
    /**
     * Automatically fix offenses in the source code.
     * Uses AST mutation for parser rules and token mutation for lexer rules.
     * @param source - The source code to fix
     * @param context - Optional context for linting (e.g., fileName)
     * @param offensesToFix - Optional array of specific offenses to fix. If not provided, all fixable offenses will be fixed.
     * @returns AutofixResult containing the corrected source and lists of fixed/unfixed offenses
     */
    autofix(source: string, context?: Partial<LintContext>, offensesToFix?: LintOffense[]): AutofixResult;
}

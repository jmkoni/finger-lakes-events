#!/usr/bin/env node
'use strict';

var node_url = require('node:url');
var node_path = require('node:path');
var fs = require('fs');
var actualFS = require('node:fs');
var promises = require('node:fs/promises');
var node_events = require('node:events');
var Stream = require('node:stream');
var node_string_decoder = require('node:string_decoder');
var path$1$1 = require('path');
var util = require('util');
var url = require('url');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var actualFS__namespace = /*#__PURE__*/_interopNamespaceDefault(actualFS);

const balanced$1 = (a, b, str) => {
    const ma = a instanceof RegExp ? maybeMatch$1(a, str) : a;
    const mb = b instanceof RegExp ? maybeMatch$1(b, str) : b;
    const r = ma !== null && mb != null && range$1(ma, mb, str);
    return (r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + ma.length, r[1]),
        post: str.slice(r[1] + mb.length),
    });
};
const maybeMatch$1 = (reg, str) => {
    const m = str.match(reg);
    return m ? m[0] : null;
};
const range$1 = (a, b, str) => {
    let begs, beg, left, right = undefined, result;
    let ai = str.indexOf(a);
    let bi = str.indexOf(b, ai + 1);
    let i = ai;
    if (ai >= 0 && bi > 0) {
        if (a === b) {
            return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
            if (i === ai) {
                begs.push(i);
                ai = str.indexOf(a, i + 1);
            }
            else if (begs.length === 1) {
                const r = begs.pop();
                if (r !== undefined)
                    result = [r, bi];
            }
            else {
                beg = begs.pop();
                if (beg !== undefined && beg < left) {
                    left = beg;
                    right = bi;
                }
                bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length && right !== undefined) {
            result = [left, right];
        }
    }
    return result;
};

const escSlash$1 = '\0SLASH' + Math.random() + '\0';
const escOpen$1 = '\0OPEN' + Math.random() + '\0';
const escClose$1 = '\0CLOSE' + Math.random() + '\0';
const escComma$1 = '\0COMMA' + Math.random() + '\0';
const escPeriod$1 = '\0PERIOD' + Math.random() + '\0';
const escSlashPattern$1 = new RegExp(escSlash$1, 'g');
const escOpenPattern$1 = new RegExp(escOpen$1, 'g');
const escClosePattern$1 = new RegExp(escClose$1, 'g');
const escCommaPattern$1 = new RegExp(escComma$1, 'g');
const escPeriodPattern$1 = new RegExp(escPeriod$1, 'g');
const slashPattern$1 = /\\\\/g;
const openPattern$1 = /\\{/g;
const closePattern$1 = /\\}/g;
const commaPattern$1 = /\\,/g;
const periodPattern$1 = /\\./g;
function numeric$1(str) {
    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces$1(str) {
    return str
        .replace(slashPattern$1, escSlash$1)
        .replace(openPattern$1, escOpen$1)
        .replace(closePattern$1, escClose$1)
        .replace(commaPattern$1, escComma$1)
        .replace(periodPattern$1, escPeriod$1);
}
function unescapeBraces$1(str) {
    return str
        .replace(escSlashPattern$1, '\\')
        .replace(escOpenPattern$1, '{')
        .replace(escClosePattern$1, '}')
        .replace(escCommaPattern$1, ',')
        .replace(escPeriodPattern$1, '.');
}
/**
 * Basically just str.split(","), but handling cases
 * where we have nested braced sections, which should be
 * treated as individual members, like {a,{b,c},d}
 */
function parseCommaParts$1(str) {
    if (!str) {
        return [''];
    }
    const parts = [];
    const m = balanced$1('{', '}', str);
    if (!m) {
        return str.split(',');
    }
    const { pre, body, post } = m;
    const p = pre.split(',');
    p[p.length - 1] += '{' + body + '}';
    const postParts = parseCommaParts$1(post);
    if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
}
function expand$1(str) {
    if (!str) {
        return [];
    }
    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.slice(0, 2) === '{}') {
        str = '\\{\\}' + str.slice(2);
    }
    return expand_$1(escapeBraces$1(str), true).map(unescapeBraces$1);
}
function embrace$1(str) {
    return '{' + str + '}';
}
function isPadded$1(el) {
    return /^-?0\d/.test(el);
}
function lte$1(i, y) {
    return i <= y;
}
function gte$1(i, y) {
    return i >= y;
}
function expand_$1(str, isTop) {
    /** @type {string[]} */
    const expansions = [];
    const m = balanced$1('{', '}', str);
    if (!m)
        return [str];
    // no need to expand pre, since it is guaranteed to be free of brace-sets
    const pre = m.pre;
    const post = m.post.length ? expand_$1(m.post, false) : [''];
    if (/\$$/.test(m.pre)) {
        for (let k = 0; k < post.length; k++) {
            const expansion = pre + '{' + m.body + '}' + post[k];
            expansions.push(expansion);
        }
    }
    else {
        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        const isSequence = isNumericSequence || isAlphaSequence;
        const isOptions = m.body.indexOf(',') >= 0;
        if (!isSequence && !isOptions) {
            // {a},b}
            if (m.post.match(/,(?!,).*\}/)) {
                str = m.pre + '{' + m.body + escClose$1 + m.post;
                return expand_$1(str);
            }
            return [str];
        }
        let n;
        if (isSequence) {
            n = m.body.split(/\.\./);
        }
        else {
            n = parseCommaParts$1(m.body);
            if (n.length === 1 && n[0] !== undefined) {
                // x{{a,b}}y ==> x{a}y x{b}y
                n = expand_$1(n[0], false).map(embrace$1);
                //XXX is this necessary? Can't seem to hit it in tests.
                /* c8 ignore start */
                if (n.length === 1) {
                    return post.map(p => m.pre + n[0] + p);
                }
                /* c8 ignore stop */
            }
        }
        // at this point, n is the parts, and we know it's not a comma set
        // with a single entry.
        let N;
        if (isSequence && n[0] !== undefined && n[1] !== undefined) {
            const x = numeric$1(n[0]);
            const y = numeric$1(n[1]);
            const width = Math.max(n[0].length, n[1].length);
            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric$1(n[2])) : 1;
            let test = lte$1;
            const reverse = y < x;
            if (reverse) {
                incr *= -1;
                test = gte$1;
            }
            const pad = n.some(isPadded$1);
            N = [];
            for (let i = x; test(i, y); i += incr) {
                let c;
                if (isAlphaSequence) {
                    c = String.fromCharCode(i);
                    if (c === '\\') {
                        c = '';
                    }
                }
                else {
                    c = String(i);
                    if (pad) {
                        const need = width - c.length;
                        if (need > 0) {
                            const z = new Array(need + 1).join('0');
                            if (i < 0) {
                                c = '-' + z + c.slice(1);
                            }
                            else {
                                c = z + c;
                            }
                        }
                    }
                }
                N.push(c);
            }
        }
        else {
            N = [];
            for (let j = 0; j < n.length; j++) {
                N.push.apply(N, expand_$1(n[j], false));
            }
        }
        for (let j = 0; j < N.length; j++) {
            for (let k = 0; k < post.length; k++) {
                const expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion) {
                    expansions.push(expansion);
                }
            }
        }
    }
    return expansions;
}

const MAX_PATTERN_LENGTH$1 = 1024 * 64;
const assertValidPattern$1 = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH$1) {
        throw new TypeError('pattern is too long');
    }
};

// translate the various posix character classes into unicode properties
// this works across all unicode locales
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses$1 = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape$1 = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString$1 = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass$1 = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses$1)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape$1(rangeStart) + '-' + braceEscape$1(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape$1(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape$1(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape$1(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape$1(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString$1(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString$1(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};

/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link MinimatchOptions.windowsPathsNoEscape} option is used, then
 * square-bracket escapes are removed, but not backslash escapes.
 *
 * For example, it will turn the string `'[*]'` into `*`, but it will not
 * turn `'\\*'` into `'*'`, because `\` is a path separator in
 * `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both square-bracket escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 *
 * When `magicalBraces` is not set, escapes of braces (`{` and `}`) will not be
 * unescaped.
 */
const unescape$1 = (s, { windowsPathsNoEscape = false, magicalBraces = true, } = {}) => {
    if (magicalBraces) {
        return windowsPathsNoEscape
            ? s.replace(/\[([^\/\\])\]/g, '$1')
            : s
                .replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2')
                .replace(/\\([^\/])/g, '$1');
    }
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\{}])\]/g, '$1')
        : s
            .replace(/((?!\\).|^)\[([^\/\\{}])\]/g, '$1$2')
            .replace(/\\([^\/{}])/g, '$1');
};

// parse a single path portion
const types$1 = new Set(['!', '?', '+', '*', '@']);
const isExtglobType$1 = (c) => types$1.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal$1 = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot$1 = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart$1 = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots$1 = new Set(['..', '.']);
const reSpecials$1 = new Set('().*{}+?[]^$\\!');
const regExpEscape$3 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark$3 = '[^/]';
// * => any number of characters
const star$3 = qmark$3 + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty$1 = qmark$3 + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
let AST$1 = class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType$1(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType$1(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() &&
                this.isEnd() &&
                !this.#parts.some(s => typeof s !== 'string');
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots$1.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart$1;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal$1 : needNoDot ? startNoDot$1 : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                unescape$1(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, unescape$1(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot$1
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot$1 : '') + starNoEmpty$1;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot$1 : '') +
                        star$3 +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape$1(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials$1.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = parseClass$1(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                re += noEmpty && glob === '*' ? starNoEmpty$1 : star$3;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark$3;
                hasMagic = true;
                continue;
            }
            re += regExpEscape$3(c);
        }
        return [re, unescape$1(glob), !!hasMagic, uflag];
    }
};

/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link MinimatchOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 *
 * If the {@link MinimatchOptions.magicalBraces} option is used,
 * then braces (`{` and `}`) will be escaped.
 */
const escape$1 = (s, { windowsPathsNoEscape = false, magicalBraces = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    if (magicalBraces) {
        return windowsPathsNoEscape
            ? s.replace(/[?*()[\]{}]/g, '[$&]')
            : s.replace(/[?*()[\]\\{}]/g, '\\$&');
    }
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};

const minimatch$1 = (p, pattern, options = {}) => {
    assertValidPattern$1(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch$1(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE$1 = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest$1 = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot$1 = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase$1 = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot$1 = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE$1 = /^\*+\.\*+$/;
const starDotStarTest$1 = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot$1 = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE$1 = /^\.\*+$/;
const dotStarTest$1 = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE$1 = /^\*+$/;
const starTest$1 = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot$1 = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE$1 = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase$1 = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt$1([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot$1 = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot$1([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot$1 = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot$1([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest$1 = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt$1([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt$1 = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot$1 = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform$5 = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path$1 = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
const sep$1 = defaultPlatform$5 === 'win32' ? path$1.win32.sep : path$1.posix.sep;
minimatch$1.sep = sep$1;
const GLOBSTAR$1 = Symbol('globstar **');
minimatch$1.GLOBSTAR = GLOBSTAR$1;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark$2 = '[^/]';
// * => any number of characters
const star$2 = qmark$2 + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot$1 = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot$1 = '(?:(?!(?:\\/|^)\\.).)*?';
const filter$1 = (pattern, options = {}) => (p) => minimatch$1(p, pattern, options);
minimatch$1.filter = filter$1;
const ext$1 = (a, b = {}) => Object.assign({}, a, b);
const defaults$1 = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return minimatch$1;
    }
    const orig = minimatch$1;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext$1(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext$1(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext$1(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext$1(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext$1(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext$1(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext$1(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext$1(def, options)),
        defaults: (options) => orig.defaults(ext$1(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext$1(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext$1(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext$1(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR$1,
    });
};
minimatch$1.defaults = defaults$1;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand$1 = (pattern, options = {}) => {
    assertValidPattern$1(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return expand$1(pattern);
};
minimatch$1.braceExpand = braceExpand$1;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe$1 = (pattern, options = {}) => new Minimatch$1(pattern, options).makeRe();
minimatch$1.makeRe = makeRe$1;
const match$1 = (list, pattern, options = {}) => {
    const mm = new Minimatch$1(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch$1.match = match$1;
// replace stuff like \* with *
const globMagic$1 = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape$2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
let Minimatch$1 = class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        assertValidPattern$1(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform$5;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic$1.test(s[2])) &&
                    !globMagic$1.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // don't need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === GLOBSTAR$1) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return braceExpand$1(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern$1(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return GLOBSTAR$1;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE$1))) {
            fastTest = options.dot ? starTestDot$1 : starTest$1;
        }
        else if ((m = pattern.match(starDotExtRE$1))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot$1
                    : starDotExtTestNocase$1
                : options.dot
                    ? starDotExtTestDot$1
                    : starDotExtTest$1)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE$1))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot$1
                    : qmarksTestNocase$1
                : options.dot
                    ? qmarksTestDot$1
                    : qmarksTest$1)(m);
        }
        else if ((m = pattern.match(starDotStarRE$1))) {
            fastTest = options.dot ? starDotStarTestDot$1 : starDotStarTest$1;
        }
        else if ((m = pattern.match(dotStarRE$1))) {
            fastTest = dotStarTest$1;
        }
        const re = AST$1.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star$2
            : options.dot
                ? twoStarDot$1
                : twoStarNoDot$1;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape$2(p)
                    : p === GLOBSTAR$1
                        ? GLOBSTAR$1
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR$1 || prev === GLOBSTAR$1) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== GLOBSTAR$1) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + ')?';
                }
                else if (next !== GLOBSTAR$1) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = GLOBSTAR$1;
                }
            });
            const filtered = pp.filter(p => p !== GLOBSTAR$1);
            // For partial matches, we need to make the pattern match
            // any prefix of the full path. We do this by generating
            // alternative patterns that match progressively longer prefixes.
            if (this.partial && filtered.length >= 1) {
                const prefixes = [];
                for (let i = 1; i <= filtered.length; i++) {
                    prefixes.push(filtered.slice(0, i).join('/'));
                }
                return '(?:' + prefixes.join('|') + ')';
            }
            return filtered.join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // In partial mode, '/' should always match as it's a valid prefix for any pattern
        if (this.partial) {
            re = '^(?:\\/|' + open + re.slice(1, -1) + close + ')$';
        }
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch$1.defaults(def).Minimatch;
    }
};
/* c8 ignore stop */
minimatch$1.AST = AST$1;
minimatch$1.Minimatch = Minimatch$1;
minimatch$1.escape = escape$1;
minimatch$1.unescape = unescape$1;

/**
 * @module LRUCache
 */
const perf$1 = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned$1 = new Set();
/* c8 ignore start */
const PROCESS$1 = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning$1 = (msg, type, code, fn) => {
    typeof PROCESS$1.emitWarning === 'function'
        ? PROCESS$1.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC$1 = globalThis.AbortController;
let AS$1 = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC$1 === 'undefined') {
    //@ts-ignore
    AS$1 = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC$1 = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS$1();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS$1.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning$1('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn$1 = (code) => !warned$1.has(code);
const isPosInt$1 = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray$1 = (max) => !isPosInt$1(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray$1
                    : null;
/* c8 ignore stop */
let ZeroArray$1 = class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
};
let Stack$1 = class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray$1(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
};
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
let LRUCache$1 = class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */
    get onInsert() {
        return this.#onInsert;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt$1(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray$1(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack$1.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof onInsert === 'function') {
            this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt$1(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt$1(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt$1(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt$1(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn$1(code)) {
                warned$1.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning$1(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray$1(this.#max);
        const starts = new ZeroArray$1(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf$1.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf$1.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf$1.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray$1(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt$1(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt$1(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf$1.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf$1.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf$1.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
            if (this.#hasOnInsert) {
                this.#onInsert?.(v, k, 'add');
            }
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
            if (this.#hasOnInsert) {
                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC$1();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC$1);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
};

const proc$1 = typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
    };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
const isStream$1 = (s) => !!s &&
    typeof s === 'object' &&
    (s instanceof Minipass$1 ||
        s instanceof Stream ||
        isReadable$1(s) ||
        isWritable$1(s));
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
const isReadable$1 = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof node_events.EventEmitter &&
    typeof s.pipe === 'function' &&
    // node core Writable streams have a pipe() method, but it throws
    s.pipe !== Stream.Writable.prototype.pipe;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
const isWritable$1 = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof node_events.EventEmitter &&
    typeof s.write === 'function' &&
    typeof s.end === 'function';
const EOF$1 = Symbol('EOF');
const MAYBE_EMIT_END$1 = Symbol('maybeEmitEnd');
const EMITTED_END$1 = Symbol('emittedEnd');
const EMITTING_END$1 = Symbol('emittingEnd');
const EMITTED_ERROR$1 = Symbol('emittedError');
const CLOSED$1 = Symbol('closed');
const READ$1 = Symbol('read');
const FLUSH$1 = Symbol('flush');
const FLUSHCHUNK$1 = Symbol('flushChunk');
const ENCODING$1 = Symbol('encoding');
const DECODER$1 = Symbol('decoder');
const FLOWING$1 = Symbol('flowing');
const PAUSED$1 = Symbol('paused');
const RESUME$1 = Symbol('resume');
const BUFFER$1 = Symbol('buffer');
const PIPES$1 = Symbol('pipes');
const BUFFERLENGTH$1 = Symbol('bufferLength');
const BUFFERPUSH$1 = Symbol('bufferPush');
const BUFFERSHIFT$1 = Symbol('bufferShift');
const OBJECTMODE$1 = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED$1 = Symbol('destroyed');
// internal event when stream has an error
const ERROR$1 = Symbol('error');
const EMITDATA$1 = Symbol('emitData');
const EMITEND$1 = Symbol('emitEnd');
const EMITEND2$1 = Symbol('emitEnd2');
const ASYNC$1 = Symbol('async');
const ABORT$1 = Symbol('abort');
const ABORTED$1 = Symbol('aborted');
const SIGNAL$1 = Symbol('signal');
const DATALISTENERS$1 = Symbol('dataListeners');
const DISCARDED$1 = Symbol('discarded');
const defer$1 = (fn) => Promise.resolve().then(fn);
const nodefer$1 = (fn) => fn();
const isEndish$1 = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBufferLike$1 = (b) => b instanceof ArrayBuffer ||
    (!!b &&
        typeof b === 'object' &&
        b.constructor &&
        b.constructor.name === 'ArrayBuffer' &&
        b.byteLength >= 0);
const isArrayBufferView$1 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
let Pipe$1 = class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME$1]();
        this.dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) { }
    /* c8 ignore stop */
    end() {
        this.unpipe();
        if (this.opts.end)
            this.dest.end();
    }
};
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
let PipeProxyErrors$1 = class PipeProxyErrors extends Pipe$1 {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = er => dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
};
const isObjectModeOptions$1 = (o) => !!o.objectMode;
const isEncodingOptions$1 = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
let Minipass$1 = class Minipass extends node_events.EventEmitter {
    [FLOWING$1] = false;
    [PAUSED$1] = false;
    [PIPES$1] = [];
    [BUFFER$1] = [];
    [OBJECTMODE$1];
    [ENCODING$1];
    [ASYNC$1];
    [DECODER$1];
    [EOF$1] = false;
    [EMITTED_END$1] = false;
    [EMITTING_END$1] = false;
    [CLOSED$1] = false;
    [EMITTED_ERROR$1] = null;
    [BUFFERLENGTH$1] = 0;
    [DESTROYED$1] = false;
    [SIGNAL$1];
    [ABORTED$1] = false;
    [DATALISTENERS$1] = 0;
    [DISCARDED$1] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
        const options = (args[0] ||
            {});
        super();
        if (options.objectMode && typeof options.encoding === 'string') {
            throw new TypeError('Encoding and objectMode may not be used together');
        }
        if (isObjectModeOptions$1(options)) {
            this[OBJECTMODE$1] = true;
            this[ENCODING$1] = null;
        }
        else if (isEncodingOptions$1(options)) {
            this[ENCODING$1] = options.encoding;
            this[OBJECTMODE$1] = false;
        }
        else {
            this[OBJECTMODE$1] = false;
            this[ENCODING$1] = null;
        }
        this[ASYNC$1] = !!options.async;
        this[DECODER$1] = this[ENCODING$1]
            ? new node_string_decoder.StringDecoder(this[ENCODING$1])
            : null;
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER$1] });
        }
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', { get: () => this[PIPES$1] });
        }
        const { signal } = options;
        if (signal) {
            this[SIGNAL$1] = signal;
            if (signal.aborted) {
                this[ABORT$1]();
            }
            else {
                signal.addEventListener('abort', () => this[ABORT$1]());
            }
        }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
        return this[BUFFERLENGTH$1];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
        return this[ENCODING$1];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
        return this[OBJECTMODE$1];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
        throw new Error('objectMode must be set at instantiation time');
    }
    /**
     * true if this is an async stream
     */
    get ['async']() {
        return this[ASYNC$1];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC$1] = this[ASYNC$1] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT$1]() {
        this[ABORTED$1] = true;
        this.emit('abort', this[SIGNAL$1]?.reason);
        this.destroy(this[SIGNAL$1]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED$1];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED$1])
            return false;
        if (this[EOF$1])
            throw new Error('write after end');
        if (this[DESTROYED$1]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC$1] ? defer$1 : nodefer$1;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE$1] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView$1(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike$1(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE$1]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING$1] && this[BUFFERLENGTH$1] !== 0)
                this[FLUSH$1](true);
            /* c8 ignore stop */
            if (this[FLOWING$1])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH$1](chunk);
            if (this[BUFFERLENGTH$1] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING$1];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH$1] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING$1];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING$1] && !this[DECODER$1]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING$1]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER$1].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING$1] && this[BUFFERLENGTH$1] !== 0)
            this[FLUSH$1](true);
        if (this[FLOWING$1])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH$1](chunk);
        if (this[BUFFERLENGTH$1] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING$1];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED$1])
            return null;
        this[DISCARDED$1] = false;
        if (this[BUFFERLENGTH$1] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH$1])) {
            this[MAYBE_EMIT_END$1]();
            return null;
        }
        if (this[OBJECTMODE$1])
            n = null;
        if (this[BUFFER$1].length > 1 && !this[OBJECTMODE$1]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER$1] = [
                (this[ENCODING$1]
                    ? this[BUFFER$1].join('')
                    : Buffer.concat(this[BUFFER$1], this[BUFFERLENGTH$1])),
            ];
        }
        const ret = this[READ$1](n || null, this[BUFFER$1][0]);
        this[MAYBE_EMIT_END$1]();
        return ret;
    }
    [READ$1](n, chunk) {
        if (this[OBJECTMODE$1])
            this[BUFFERSHIFT$1]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT$1]();
            else if (typeof c === 'string') {
                this[BUFFER$1][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH$1] -= n;
            }
            else {
                this[BUFFER$1][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH$1] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER$1].length && !this[EOF$1])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF$1] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING$1] || !this[PAUSED$1])
            this[MAYBE_EMIT_END$1]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME$1]() {
        if (this[DESTROYED$1])
            return;
        if (!this[DATALISTENERS$1] && !this[PIPES$1].length) {
            this[DISCARDED$1] = true;
        }
        this[PAUSED$1] = false;
        this[FLOWING$1] = true;
        this.emit('resume');
        if (this[BUFFER$1].length)
            this[FLUSH$1]();
        else if (this[EOF$1])
            this[MAYBE_EMIT_END$1]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME$1]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING$1] = false;
        this[PAUSED$1] = true;
        this[DISCARDED$1] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED$1];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
        return this[FLOWING$1];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
        return this[PAUSED$1];
    }
    [BUFFERPUSH$1](chunk) {
        if (this[OBJECTMODE$1])
            this[BUFFERLENGTH$1] += 1;
        else
            this[BUFFERLENGTH$1] += chunk.length;
        this[BUFFER$1].push(chunk);
    }
    [BUFFERSHIFT$1]() {
        if (this[OBJECTMODE$1])
            this[BUFFERLENGTH$1] -= 1;
        else
            this[BUFFERLENGTH$1] -= this[BUFFER$1][0].length;
        return this[BUFFER$1].shift();
    }
    [FLUSH$1](noDrain = false) {
        do { } while (this[FLUSHCHUNK$1](this[BUFFERSHIFT$1]()) &&
            this[BUFFER$1].length);
        if (!noDrain && !this[BUFFER$1].length && !this[EOF$1])
            this.emit('drain');
    }
    [FLUSHCHUNK$1](chunk) {
        this.emit('data', chunk);
        return this[FLOWING$1];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
        if (this[DESTROYED$1])
            return dest;
        this[DISCARDED$1] = false;
        const ended = this[EMITTED_END$1];
        opts = opts || {};
        if (dest === proc$1.stdout || dest === proc$1.stderr)
            opts.end = false;
        else
            opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end)
                dest.end();
        }
        else {
            // "as" here just ignores the WType, which pipes don't care about,
            // since they're only consuming from us, and writing to the dest
            this[PIPES$1].push(!opts.proxyErrors
                ? new Pipe$1(this, dest, opts)
                : new PipeProxyErrors$1(this, dest, opts));
            if (this[ASYNC$1])
                defer$1(() => this[RESUME$1]());
            else
                this[RESUME$1]();
        }
        return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
        const p = this[PIPES$1].find(p => p.dest === dest);
        if (p) {
            if (this[PIPES$1].length === 1) {
                if (this[FLOWING$1] && this[DATALISTENERS$1] === 0) {
                    this[FLOWING$1] = false;
                }
                this[PIPES$1] = [];
            }
            else
                this[PIPES$1].splice(this[PIPES$1].indexOf(p), 1);
            p.unpipe();
        }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
        return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === 'data') {
            this[DISCARDED$1] = false;
            this[DATALISTENERS$1]++;
            if (!this[PIPES$1].length && !this[FLOWING$1]) {
                this[RESUME$1]();
            }
        }
        else if (ev === 'readable' && this[BUFFERLENGTH$1] !== 0) {
            super.emit('readable');
        }
        else if (isEndish$1(ev) && this[EMITTED_END$1]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        }
        else if (ev === 'error' && this[EMITTED_ERROR$1]) {
            const h = handler;
            if (this[ASYNC$1])
                defer$1(() => h.call(this, this[EMITTED_ERROR$1]));
            else
                h.call(this, this[EMITTED_ERROR$1]);
        }
        return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
        return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
        const ret = super.off(ev, handler);
        // if we previously had listeners, and now we don't, and we don't
        // have any pipes, then stop the flow, unless it's been explicitly
        // put in a discarded flowing state via stream.resume().
        if (ev === 'data') {
            this[DATALISTENERS$1] = this.listeners('data').length;
            if (this[DATALISTENERS$1] === 0 &&
                !this[DISCARDED$1] &&
                !this[PIPES$1].length) {
                this[FLOWING$1] = false;
            }
        }
        return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === 'data' || ev === undefined) {
            this[DATALISTENERS$1] = 0;
            if (!this[DISCARDED$1] && !this[PIPES$1].length) {
                this[FLOWING$1] = false;
            }
        }
        return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
        return this[EMITTED_END$1];
    }
    [MAYBE_EMIT_END$1]() {
        if (!this[EMITTING_END$1] &&
            !this[EMITTED_END$1] &&
            !this[DESTROYED$1] &&
            this[BUFFER$1].length === 0 &&
            this[EOF$1]) {
            this[EMITTING_END$1] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED$1])
                this.emit('close');
            this[EMITTING_END$1] = false;
        }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
        const data = args[0];
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' &&
            ev !== 'close' &&
            ev !== DESTROYED$1 &&
            this[DESTROYED$1]) {
            return false;
        }
        else if (ev === 'data') {
            return !this[OBJECTMODE$1] && !data
                ? false
                : this[ASYNC$1]
                    ? (defer$1(() => this[EMITDATA$1](data)), true)
                    : this[EMITDATA$1](data);
        }
        else if (ev === 'end') {
            return this[EMITEND$1]();
        }
        else if (ev === 'close') {
            this[CLOSED$1] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END$1] && !this[DESTROYED$1])
                return false;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        }
        else if (ev === 'error') {
            this[EMITTED_ERROR$1] = data;
            super.emit(ERROR$1, data);
            const ret = !this[SIGNAL$1] || this.listeners('error').length
                ? super.emit('error', data)
                : false;
            this[MAYBE_EMIT_END$1]();
            return ret;
        }
        else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END$1]();
            return ret;
        }
        else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END$1]();
        return ret;
    }
    [EMITDATA$1](data) {
        for (const p of this[PIPES$1]) {
            if (p.dest.write(data) === false)
                this.pause();
        }
        const ret = this[DISCARDED$1] ? false : super.emit('data', data);
        this[MAYBE_EMIT_END$1]();
        return ret;
    }
    [EMITEND$1]() {
        if (this[EMITTED_END$1])
            return false;
        this[EMITTED_END$1] = true;
        this.readable = false;
        return this[ASYNC$1]
            ? (defer$1(() => this[EMITEND2$1]()), true)
            : this[EMITEND2$1]();
    }
    [EMITEND2$1]() {
        if (this[DECODER$1]) {
            const data = this[DECODER$1].end();
            if (data) {
                for (const p of this[PIPES$1]) {
                    p.dest.write(data);
                }
                if (!this[DISCARDED$1])
                    super.emit('data', data);
            }
        }
        for (const p of this[PIPES$1]) {
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
        const buf = Object.assign([], {
            dataLength: 0,
        });
        if (!this[OBJECTMODE$1])
            buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', c => {
            buf.push(c);
            if (!this[OBJECTMODE$1])
                buf.dataLength += c.length;
        });
        await p;
        return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
        if (this[OBJECTMODE$1]) {
            throw new Error('cannot concat in objectMode');
        }
        const buf = await this.collect();
        return (this[ENCODING$1]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength));
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
        return new Promise((resolve, reject) => {
            this.on(DESTROYED$1, () => reject(new Error('stream destroyed')));
            this.on('error', er => reject(er));
            this.on('end', () => resolve());
        });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED$1] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF$1])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED$1, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED$1, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF$1] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED$1, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED$1, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED$1] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR$1, stop);
            this.off(DESTROYED$1, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR$1, stop);
        this.once(DESTROYED$1, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED$1]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED$1);
            return this;
        }
        this[DESTROYED$1] = true;
        this[DISCARDED$1] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER$1].length = 0;
        this[BUFFERLENGTH$1] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED$1])
            wc.close();
        if (er)
            this.emit('error', er);
        // if no error to emit, still reject pending promises
        else
            this.emit(DESTROYED$1);
        return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
        return isStream$1;
    }
};

const realpathSync$1 = fs.realpathSync.native;
const defaultFS$1 = {
    lstatSync: fs.lstatSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync,
    readlinkSync: fs.readlinkSync,
    realpathSync: realpathSync$1,
    promises: {
        lstat: promises.lstat,
        readdir: promises.readdir,
        readlink: promises.readlink,
        realpath: promises.realpath,
    },
};
// if they just gave us require('fs') then use our default
const fsFromOption$1 = (fsOption) => !fsOption || fsOption === defaultFS$1 || fsOption === actualFS__namespace ?
    defaultFS$1
    : {
        ...defaultFS$1,
        ...fsOption,
        promises: {
            ...defaultFS$1.promises,
            ...(fsOption.promises || {}),
        },
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp$1 = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive$1 = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp$1, '$1\\');
// windows paths are separated by either / or \
const eitherSep$1 = /[\\\/]/;
const UNKNOWN$1 = 0; // may not even exist, for all we know
const IFIFO$1 = 0b0001;
const IFCHR$1 = 0b0010;
const IFDIR$1 = 0b0100;
const IFBLK$1 = 0b0110;
const IFREG$1 = 0b1000;
const IFLNK$1 = 0b1010;
const IFSOCK$1 = 0b1100;
const IFMT$1 = 0b1111;
// mask to unset low 4 bits
const IFMT_UNKNOWN$1 = ~IFMT$1;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED$1 = 0b0000_0001_0000;
// set after a successful lstat()
const LSTAT_CALLED$1 = 0b0000_0010_0000;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR$1 = 0b0000_0100_0000;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT$1 = 0b0000_1000_0000;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK$1 = 0b0001_0000_0000;
// set if we know realpath() will fail
const ENOREALPATH$1 = 0b0010_0000_0000;
const ENOCHILD$1 = ENOTDIR$1 | ENOENT$1 | ENOREALPATH$1;
const TYPEMASK$1 = 0b0011_1111_1111;
const entToType$1 = (s) => s.isFile() ? IFREG$1
    : s.isDirectory() ? IFDIR$1
        : s.isSymbolicLink() ? IFLNK$1
            : s.isCharacterDevice() ? IFCHR$1
                : s.isBlockDevice() ? IFBLK$1
                    : s.isSocket() ? IFSOCK$1
                        : s.isFIFO() ? IFIFO$1
                            : UNKNOWN$1;
// normalize unicode path names
const normalizeCache$1 = new Map();
const normalize$1 = (s) => {
    const c = normalizeCache$1.get(s);
    if (c)
        return c;
    const n = s.normalize('NFKD');
    normalizeCache$1.set(s, n);
    return n;
};
const normalizeNocaseCache$1 = new Map();
const normalizeNocase$1 = (s) => {
    const c = normalizeNocaseCache$1.get(s);
    if (c)
        return c;
    const n = normalize$1(s.toLowerCase());
    normalizeNocaseCache$1.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
let ResolveCache$1 = class ResolveCache extends LRUCache$1 {
    constructor() {
        super({ max: 256 });
    }
};
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */
let ChildrenCache$1 = class ChildrenCache extends LRUCache$1 {
    constructor(maxSize = 16 * 1024) {
        super({
            maxSize,
            // parent + children
            sizeCalculation: a => a.length + 1,
        });
    }
};
const setAsCwd$1 = Symbol('PathScurry setAsCwd');
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
let PathBase$1 = class PathBase {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    /**
     * boolean indicating that this path is the current working directory
     * of the PathScurry collection that contains it.
     */
    isCWD = false;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['parentPath'] refers to the path of the
     * directory that was passed to readdir. For root entries, it's the path
     * to the entry itself.
     */
    get parentPath() {
        return (this.parent || this).fullpath();
    }
    /**
     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
     * this property refers to the *parent* path, not the path object itself.
     *
     * @deprecated
     */
    get path() {
        return this.parentPath;
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN$1, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase$1(name) : normalize$1(name);
        this.#type = type & TYPEMASK$1;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        }
        else {
            this.#fs = fsFromOption$1(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
        if (this.#depth !== undefined)
            return this.#depth;
        if (!this.parent)
            return (this.#depth = 0);
        return (this.#depth = this.parent.depth() + 1);
    }
    /**
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ?
            this.getRoot(rootPath).#resolveParts(dirParts)
            : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED$1;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
        if (pathPart === '' || pathPart === '.') {
            return this;
        }
        if (pathPart === '..') {
            return this.parent || this;
        }
        // find the child
        const children = this.children();
        const name = this.nocase ? normalizeNocase$1(pathPart) : normalize$1(pathPart);
        for (const p of children) {
            if (p.#matchName === name) {
                return p;
            }
        }
        // didn't find it, create provisional child, since it might not
        // actually exist.  If we know the parent isn't a dir, then
        // in fact it CAN'T exist.
        const s = this.parent ? this.sep : '';
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
        const pchild = this.newChild(pathPart, UNKNOWN$1, {
            ...opts,
            parent: this,
            fullpath,
        });
        if (!this.canReaddir()) {
            pchild.#type |= ENOENT$1;
        }
        // don't have to update provisional, because if we have real children,
        // then provisional is set to children.length, otherwise a lower number
        children.push(pchild);
        return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
        if (this.isCWD)
            return '';
        if (this.#relative !== undefined) {
            return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relative = this.name);
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? '' : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
        if (this.sep === '/')
            return this.relative();
        if (this.isCWD)
            return '';
        if (this.#relativePosix !== undefined)
            return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relativePosix = this.fullpathPosix());
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? '' : '/') + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
        if (this.#fullpath !== undefined) {
            return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#fullpath = this.name);
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? '' : this.sep) + name;
        return (this.#fullpath = fp);
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
        if (this.#fullpathPosix !== undefined)
            return this.#fullpathPosix;
        if (this.sep === '/')
            return (this.#fullpathPosix = this.fullpath());
        if (!this.parent) {
            const p = this.fullpath().replace(/\\/g, '/');
            if (/^[a-z]:\//i.test(p)) {
                return (this.#fullpathPosix = `//?/${p}`);
            }
            else {
                return (this.#fullpathPosix = p);
            }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
        return (this.#fullpathPosix = fpp);
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
        return (this.#type & IFMT$1) === UNKNOWN$1;
    }
    isType(type) {
        return this[`is${type}`]();
    }
    getType() {
        return (this.isUnknown() ? 'Unknown'
            : this.isDirectory() ? 'Directory'
                : this.isFile() ? 'File'
                    : this.isSymbolicLink() ? 'SymbolicLink'
                        : this.isFIFO() ? 'FIFO'
                            : this.isCharacterDevice() ? 'CharacterDevice'
                                : this.isBlockDevice() ? 'BlockDevice'
                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'
                                        : 'Unknown');
        /* c8 ignore stop */
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
        return (this.#type & IFMT$1) === IFREG$1;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
        return (this.#type & IFMT$1) === IFDIR$1;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
        return (this.#type & IFMT$1) === IFCHR$1;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
        return (this.#type & IFMT$1) === IFBLK$1;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
        return (this.#type & IFMT$1) === IFIFO$1;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
        return (this.#type & IFMT$1) === IFSOCK$1;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
        return (this.#type & IFLNK$1) === IFLNK$1;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
        return this.#type & LSTAT_CALLED$1 ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
        if (this.#linkTarget)
            return true;
        if (!this.parent)
            return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT$1;
        return !((ifmt !== UNKNOWN$1 && ifmt !== IFLNK$1) ||
            this.#type & ENOREADLINK$1 ||
            this.#type & ENOENT$1);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
        return !!(this.#type & READDIR_CALLED$1);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
        return !!(this.#type & ENOENT$1);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
        return !this.nocase ?
            this.#matchName === normalize$1(n)
            : this.#matchName === normalizeNocase$1(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = (await this.parent.realpath())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = this.parent.realpathSync()?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED$1;
        // mark all remaining provisional children as ENOENT
        for (let p = children.provisional; p < children.length; p++) {
            const c = children[p];
            if (c)
                c.#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT$1)
            return;
        this.#type = (this.#type | ENOENT$1) & IFMT_UNKNOWN$1;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH$1;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children can't exist.
        // this *should* be impossible, since any children created
        // after it's been marked ENOTDIR should be marked ENOENT,
        // so it won't even get to this point.
        /* c8 ignore start */
        if (this.#type & ENOTDIR$1)
            return;
        /* c8 ignore stop */
        let t = this.#type;
        // this could happen if we stat a dir, then delete it,
        // then try to read it or one of its children.
        if ((t & IFMT$1) === IFDIR$1)
            t &= IFMT_UNKNOWN$1;
        this.#type = t | ENOTDIR$1;
        this.#markChildrenENOENT();
    }
    #readdirFail(code = '') {
        // markENOTDIR and markENOENT also set provisional=0
        if (code === 'ENOTDIR' || code === 'EPERM') {
            this.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            this.#markENOENT();
        }
        else {
            this.children().provisional = 0;
        }
    }
    #lstatFail(code = '') {
        // Windows just raises ENOENT in this case, disable for win CI
        /* c8 ignore start */
        if (code === 'ENOTDIR') {
            // already know it has a parent by this point
            const p = this.parent;
            p.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            /* c8 ignore stop */
            this.#markENOENT();
        }
    }
    #readlinkFail(code = '') {
        let ter = this.#type;
        ter |= ENOREADLINK$1;
        if (code === 'ENOENT')
            ter |= ENOENT$1;
        // windows gets a weird error when you try to readlink a file
        if (code === 'EINVAL' || code === 'UNKNOWN') {
            // exists, but not a symlink, we don't know WHAT it is, so remove
            // all IFMT bits.
            ter &= IFMT_UNKNOWN$1;
        }
        this.#type = ter;
        // windows just gets ENOENT in this case.  We do cover the case,
        // just disabled because it's impossible on Windows CI
        /* c8 ignore start */
        if (code === 'ENOTDIR' && this.parent) {
            this.parent.#markENOTDIR();
        }
        /* c8 ignore stop */
    }
    #readdirAddChild(e, c) {
        return (this.#readdirMaybePromoteChild(e, c) ||
            this.#readdirAddNewChild(e, c));
    }
    #readdirAddNewChild(e, c) {
        // alloc new entry at head, so it's never provisional
        const type = entToType$1(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT$1;
        if (ifmt !== IFDIR$1 && ifmt !== IFLNK$1 && ifmt !== UNKNOWN$1) {
            child.#type |= ENOTDIR$1;
        }
        c.unshift(child);
        c.provisional++;
        return child;
    }
    #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
            const pchild = c[p];
            const name = this.nocase ? normalizeNocase$1(e.name) : normalize$1(e.name);
            if (name !== pchild.#matchName) {
                continue;
            }
            return this.#readdirPromoteChild(e, pchild, p, c);
        }
    }
    #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        // retain any other flags, but set ifmt from dirent
        p.#type = (p.#type & IFMT_UNKNOWN$1) | entToType$1(e);
        // case sensitivity fixing when we learn the true name.
        if (v !== e.name)
            p.name = e.name;
        // just advance provisional index (potentially off the list),
        // otherwise we have to splice/pop it out and re-insert at head
        if (index !== c.provisional) {
            if (index === c.length - 1)
                c.pop();
            else
                c.splice(index, 1);
            c.unshift(p);
        }
        c.provisional++;
        return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
        if ((this.#type & ENOENT$1) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
        if ((this.#type & ENOENT$1) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType$1(st);
        // retain any other flags, but set the ifmt
        this.#type = (this.#type & IFMT_UNKNOWN$1) | ifmt | LSTAT_CALLED$1;
        if (ifmt !== UNKNOWN$1 && ifmt !== IFDIR$1 && ifmt !== IFLNK$1) {
            this.#type |= ENOTDIR$1;
        }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach(cb => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo)
                cb(null, []);
            else
                queueMicrotask(() => cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo)
                cb(null, c);
            else
                queueMicrotask(() => cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        }
        else {
            /* c8 ignore start */
            let resolve = () => { };
            /* c8 ignore stop */
            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
            try {
                for (const e of await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true,
                })) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true,
            })) {
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        }
        catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD$1)
            return false;
        const ifmt = IFMT$1 & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */
        if (!(ifmt === UNKNOWN$1 || ifmt === IFDIR$1 || ifmt === IFLNK$1)) {
            return false;
        }
        /* c8 ignore stop */
        return true;
    }
    shouldWalk(dirs, walkFilter) {
        return ((this.#type & IFDIR$1) === IFDIR$1 &&
            !(this.#type & ENOCHILD$1) &&
            !dirs.has(this) &&
            (!walkFilter || walkFilter(this)));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH$1 | ENOREADLINK$1 | ENOENT$1) & this.#type)
            return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH$1 | ENOREADLINK$1 | ENOENT$1) & this.#type)
            return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd$1](oldCwd) {
        if (oldCwd === this)
            return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join('/');
            p = p.parent;
            rp.push('..');
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
};
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
let PathWin32$1 = class PathWin32 extends PathBase$1 {
    /**
     * Separator for generating path strings.
     */
    sep = '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep$1;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN$1, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN$1, opts = {}) {
        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return node_path.win32.parse(path).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
        rootPath = uncToDrive$1(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
            return this.root;
        }
        // ok, not that one, check if it matches another we know about
        for (const [compare, root] of Object.entries(this.roots)) {
            if (this.sameRoot(rootPath, compare)) {
                return (this.roots[rootPath] = root);
            }
        }
        // otherwise, have to create a new one.
        return (this.roots[rootPath] = new PathScurryWin32$1(rootPath, this).root);
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
        // windows can (rarely) have case-sensitive filesystem, but
        // UNC and drive letters are always case-insensitive, and canonically
        // represented uppercase.
        rootPath = rootPath
            .toUpperCase()
            .replace(/\//g, '\\')
            .replace(uncDriveRegexp$1, '$1\\');
        return rootPath === compare;
    }
};
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
let PathPosix$1 = class PathPosix extends PathBase$1 {
    /**
     * separator for parsing path strings
     */
    splitSep = '/';
    /**
     * separator for generating path strings
     */
    sep = '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN$1, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path.startsWith('/') ? '/' : '';
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
        return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN$1, opts = {}) {
        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
};
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
let PathScurryBase$1 = class PathScurryBase {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS$1, } = {}) {
        this.#fs = fsFromOption$1(fs);
        if (cwd instanceof URL || cwd.startsWith('file://')) {
            cwd = node_url.fileURLToPath(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache$1();
        this.#resolvePosixCache = new ResolveCache$1();
        this.#children = new ChildrenCache$1(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */
        if (nocase === undefined) {
            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
        }
        /* c8 ignore stop */
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill('..').join(joinSep),
                relativePosix: new Array(l).fill('..').join('/'),
                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path = this.cwd) {
        if (typeof path === 'string') {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else {
            const p = await entry.readdir();
            return withFileTypes ? p : p.map(e => e.name);
        }
    }
    readdirSync(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else if (withFileTypes) {
            return entry.readdirSync();
        }
        else {
            return entry.readdirSync().map(e => e.name);
        }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const walk = (dir, cb) => {
            dirs.add(dir);
            dir.readdirCB((er, entries) => {
                /* c8 ignore start */
                if (er) {
                    return cb(er);
                }
                /* c8 ignore stop */
                let len = entries.length;
                if (!len)
                    return cb();
                const next = () => {
                    if (--len === 0) {
                        cb();
                    }
                };
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        results.push(withFileTypes ? e : e.fullpath());
                    }
                    if (follow && e.isSymbolicLink()) {
                        e.realpath()
                            .then(r => (r?.isUnknown() ? r.lstat() : r))
                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    }
                    else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        }
                        else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej) => {
            walk(start, er => {
                /* c8 ignore start */
                if (er)
                    return rej(er);
                /* c8 ignore stop */
                res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass$1({ objectMode: true });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false) => {
                    /* c8 ignore start */
                    if (er)
                        return results.emit('error', er);
                    /* c8 ignore stop */
                    if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries) {
                            if (e.isSymbolicLink()) {
                                promises.push(e
                                    .realpath()
                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(() => onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries) {
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries) {
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once('drain', process);
                    }
                    else if (!sync) {
                        process();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase$1)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass$1({ objectMode: true });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries) {
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync())))
                            continue;
                        if (r.isUnknown())
                            r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing)
                results.once('drain', process);
        };
        process();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd$1](oldCwd);
    }
};
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
let PathScurryWin32$1 = class PathScurryWin32 extends PathScurryBase$1 {
    /**
     * separator for generating path strings
     */
    sep = '\\';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path.win32, '\\', { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return node_path.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathWin32$1(this.rootPath, IFDIR$1, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
    }
};
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
let PathScurryPosix$1 = class PathScurryPosix extends PathScurryBase$1 {
    /**
     * separator for generating path strings
     */
    sep = '/';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path.posix, '/', { ...opts, nocase });
        this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
        return '/';
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathPosix$1(this.rootPath, IFDIR$1, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return p.startsWith('/');
    }
};
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
let PathScurryDarwin$1 = class PathScurryDarwin extends PathScurryPosix$1 {
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
    }
};
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
process.platform === 'win32' ? PathWin32$1 : PathPosix$1;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
const PathScurry$1 = process.platform === 'win32' ? PathScurryWin32$1
    : process.platform === 'darwin' ? PathScurryDarwin$1
        : PathScurryPosix$1;

// this is just a very light wrapper around 2 arrays with an offset index
const isPatternList$1 = (pl) => pl.length >= 1;
const isGlobList$1 = (gl) => gl.length >= 1;
/**
 * An immutable-ish view on an array of glob parts and their parsed
 * results
 */
let Pattern$1 = class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
        if (!isPatternList$1(patternList)) {
            throw new TypeError('empty pattern list');
        }
        if (!isGlobList$1(globList)) {
            throw new TypeError('empty glob list');
        }
        if (globList.length !== patternList.length) {
            throw new TypeError('mismatched pattern list and glob list lengths');
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
            throw new TypeError('index out of range');
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        // normalize root entries of absolute patterns on initial creation.
        if (this.#index === 0) {
            // c: => ['c:/']
            // C:/ => ['C:/']
            // C:/x => ['C:/', 'x']
            // //host/share => ['//host/share/']
            // //host/share/ => ['//host/share/']
            // //host/share/x => ['//host/share/', 'x']
            // /etc => ['/', 'etc']
            // / => ['/']
            if (this.isUNC()) {
                // '' / '' / 'host' / 'share'
                const [p0, p1, p2, p3, ...prest] = this.#patternList;
                const [g0, g1, g2, g3, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = [p0, p1, p2, p3, ''].join('/');
                const g = [g0, g1, g2, g3, ''].join('/');
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
            else if (this.isDrive() || this.isAbsolute()) {
                const [p1, ...prest] = this.#patternList;
                const [g1, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = p1 + '/';
                const g = g1 + '/';
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
        }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
        return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
        return typeof this.#patternList[this.#index] === 'string';
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
        return this.#patternList[this.#index] === GLOBSTAR$1;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
        return (this.#globString =
            this.#globString ||
                (this.#index === 0 ?
                    this.isAbsolute() ?
                        this.#globList[0] + this.#globList.slice(1).join('/')
                        : this.#globList.join('/')
                    : this.#globList.slice(this.#index).join('/')));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
        return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
        if (this.#rest !== undefined)
            return this.#rest;
        if (!this.hasMore())
            return (this.#rest = null);
        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== undefined ?
            this.#isUNC
            : (this.#isUNC =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    pl[0] === '' &&
                    pl[1] === '' &&
                    typeof pl[2] === 'string' &&
                    !!pl[2] &&
                    typeof pl[3] === 'string' &&
                    !!pl[3]);
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== undefined ?
            this.#isDrive
            : (this.#isDrive =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    this.length > 1 &&
                    typeof pl[0] === 'string' &&
                    /^[a-z]:$/i.test(pl[0]));
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== undefined ?
            this.#isAbsolute
            : (this.#isAbsolute =
                (pl[0] === '' && pl.length > 1) ||
                    this.isDrive() ||
                    this.isUNC());
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
        const p = this.#patternList[0];
        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?
            p
            : '';
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
        return !(this.#index === 0 ||
            !this.isGlobstar() ||
            !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
            return false;
        this.#followGlobstar = false;
        return true;
    }
};

// give it a pattern, and it'll be able to tell you if
// a given path should be ignored.
// Ignoring a path ignores its children if the pattern ends in /**
// Ignores are always parsed in dot:true mode
const defaultPlatform$4 = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * Class used to process ignored patterns
 */
let Ignore$1 = class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform$4, }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
            dot: true,
            nobrace,
            nocase,
            noext,
            noglobstar,
            optimizationLevel: 2,
            platform,
            nocomment: true,
            nonegate: true,
        };
        for (const ign of ignored)
            this.add(ign);
    }
    add(ign) {
        // this is a little weird, but it gives us a clean set of optimized
        // minimatch matchers, without getting tripped up if one of them
        // ends in /** inside a brace section, and it's only inefficient at
        // the start of the walk, not along it.
        // It'd be nice if the Pattern class just had a .test() method, but
        // handling globstars is a bit of a pita, and that code already lives
        // in minimatch anyway.
        // Another way would be if maybe Minimatch could take its set/globParts
        // as an option, and then we could at least just use Pattern to test
        // for absolute-ness.
        // Yet another way, Minimatch could take an array of glob strings, and
        // a cwd option, and do the right thing.
        const mm = new Minimatch$1(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
            const parsed = mm.set[i];
            const globParts = mm.globParts[i];
            /* c8 ignore start */
            if (!parsed || !globParts) {
                throw new Error('invalid pattern object');
            }
            // strip off leading ./ portions
            // https://github.com/isaacs/node-glob/issues/570
            while (parsed[0] === '.' && globParts[0] === '.') {
                parsed.shift();
                globParts.shift();
            }
            /* c8 ignore stop */
            const p = new Pattern$1(parsed, globParts, 0, this.platform);
            const m = new Minimatch$1(p.globString(), this.mmopts);
            const children = globParts[globParts.length - 1] === '**';
            const absolute = p.isAbsolute();
            if (absolute)
                this.absolute.push(m);
            else
                this.relative.push(m);
            if (children) {
                if (absolute)
                    this.absoluteChildren.push(m);
                else
                    this.relativeChildren.push(m);
            }
        }
    }
    ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || '.';
        const relatives = `${relative}/`;
        for (const m of this.relative) {
            if (m.match(relative) || m.match(relatives))
                return true;
        }
        for (const m of this.absolute) {
            if (m.match(fullpath) || m.match(fullpaths))
                return true;
        }
        return false;
    }
    childrenIgnored(p) {
        const fullpath = p.fullpath() + '/';
        const relative = (p.relative() || '.') + '/';
        for (const m of this.relativeChildren) {
            if (m.match(relative))
                return true;
        }
        for (const m of this.absoluteChildren) {
            if (m.match(fullpath))
                return true;
        }
        return false;
    }
};

// synchronous utility for filtering entries and calculating subwalks
/**
 * A cache of which patterns have been processed for a given Path
 */
let HasWalkedCache$1 = class HasWalkedCache {
    store;
    constructor(store = new Map()) {
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
            cached.add(pattern.globString());
        else
            this.store.set(fullpath, new Set([pattern.globString()]));
    }
};
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */
let MatchRecord$1 = class MatchRecord {
    store = new Map();
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [...this.store.entries()].map(([path, n]) => [
            path,
            !!(n & 2),
            !!(n & 1),
        ]);
    }
};
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */
let SubWalks$1 = class SubWalks {
    store = new Map();
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find(p => p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        }
        else
            this.store.set(target, [pattern]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */
        if (!subs) {
            throw new Error('attempting to walk unknown path');
        }
        /* c8 ignore stop */
        return subs;
    }
    entries() {
        return this.keys().map(k => [k, this.store.get(k)]);
    }
    keys() {
        return [...this.store.keys()].filter(t => t.canReaddir());
    }
};
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */
let Processor$1 = class Processor {
    hasWalkedCache;
    matches = new MatchRecord$1();
    subwalks = new SubWalks$1();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache =
            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache$1();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map(p => [target, p]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet) {
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === '/' && this.opts.root !== undefined ?
                    this.opts.root
                    : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                }
                else {
                    pattern = rest;
                }
            }
            if (t.isENOENT())
                continue;
            let p;
            let rest;
            let changed = false;
            while (typeof (p = pattern.pattern()) === 'string' &&
                (rest = pattern.rest())) {
                const c = t.resolve(p);
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                    continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === 'string') {
                // must not be final entry, otherwise we would have
                // concatenated it earlier.
                const ifDir = p === '..' || p === '' || p === '.';
                this.matches.add(t.resolve(p), absolute, ifDir);
                continue;
            }
            else if (p === GLOBSTAR$1) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() ||
                    this.follow ||
                    pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === '' || rp === '.');
                }
                else {
                    if (rp === '..') {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */
                        const tp = t.parent || t;
                        /* c8 ignore stop */
                        if (!rrest)
                            this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            }
            else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries) {
            for (const pattern of patterns) {
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === GLOBSTAR$1) {
                    results.testGlobstar(e, pattern, rest, absolute);
                }
                else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                }
                else {
                    results.testString(e, p, rest, absolute);
                }
            }
        }
        return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith('.')) {
            if (!pattern.hasMore()) {
                this.matches.add(e, absolute, false);
            }
            if (e.canReaddir()) {
                // if we're in follow mode or it's not a symlink, just keep
                // testing the same pattern. If there's more after the globstar,
                // then this symlink consumes the globstar. If not, then we can
                // follow at most ONE symlink along the way, so we mark it, which
                // also checks to ensure that it wasn't already marked.
                if (this.follow || !e.isSymbolicLink()) {
                    this.subwalks.add(e, pattern);
                }
                else if (e.isSymbolicLink()) {
                    if (rest && pattern.checkFollowGlobstar()) {
                        this.subwalks.add(e, rest);
                    }
                    else if (pattern.markFollowGlobstar()) {
                        this.subwalks.add(e, pattern);
                    }
                }
            }
        }
        // if the NEXT thing matches this entry, then also add
        // the rest.
        if (rest) {
            const rp = rest.pattern();
            if (typeof rp === 'string' &&
                // dots and empty were handled already
                rp !== '..' &&
                rp !== '' &&
                rp !== '.') {
                this.testString(e, rp, rest.rest(), absolute);
            }
            else if (rp === '..') {
                /* c8 ignore start */
                const ep = e.parent || e;
                /* c8 ignore stop */
                this.subwalks.add(ep, rest);
            }
            else if (rp instanceof RegExp) {
                this.testRegExp(e, rp, rest.rest(), absolute);
            }
        }
    }
    testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
    testString(e, p, rest, absolute) {
        // should never happen?
        if (!e.isNamed(p))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
};

/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
const makeIgnore$1 = (ignore, opts) => typeof ignore === 'string' ? new Ignore$1([ignore], opts)
    : Array.isArray(ignore) ? new Ignore$1(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
let GlobUtil$1 = class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
            this.#ignore = makeIgnore$1(opts.ignore ?? [], opts);
            if (!this.includeChildMatches &&
                typeof this.#ignore.add !== 'function') {
                const m = 'cannot ignore child matches, ignore lacks add() method.';
                throw new Error(m);
            }
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return (e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)) ?
            e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        // we know we have an ignore if this is false, but TS doesn't
        if (!this.includeChildMatches && this.#ignore?.add) {
            const ign = `${e.relativePosix()}/**`;
            this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?
                '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor$1(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor$1(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const children = t.readdirSync();
            this.walkCB3Sync(t, children, processor, next);
        }
        next();
    }
    walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2Sync(target, patterns, processor.child(), next);
        }
        next();
    }
};
let GlobWalker$1 = class GlobWalker extends GlobUtil$1 {
    matches = new Set();
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
    }
    matchEmit(e) {
        this.matches.add(e);
    }
    async walk() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            await this.path.lstat();
        }
        await new Promise((res, rej) => {
            this.walkCB(this.path, this.patterns, () => {
                if (this.signal?.aborted) {
                    rej(this.signal.reason);
                }
                else {
                    res(this.matches);
                }
            });
        });
        return this.matches;
    }
    walkSync() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        // nothing for the callback to do, because this never pauses
        this.walkCBSync(this.path, this.patterns, () => {
            if (this.signal?.aborted)
                throw this.signal.reason;
        });
        return this.matches;
    }
};
let GlobStream$1 = class GlobStream extends GlobUtil$1 {
    results;
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
        this.results = new Minipass$1({
            signal: this.signal,
            objectMode: true,
        });
        this.results.on('drain', () => this.resume());
        this.results.on('resume', () => this.resume());
    }
    matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
            this.pause();
    }
    stream() {
        const target = this.path;
        if (target.isUnknown()) {
            target.lstat().then(() => {
                this.walkCB(target, this.patterns, () => this.results.end());
            });
        }
        else {
            this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
    }
    streamSync() {
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
    }
};

// if no process global, just call it linux.
// so we default to case-sensitive, / separators
const defaultPlatform$3 = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * An object that can perform glob pattern traversals.
 */
let Glob$1 = class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
        /* c8 ignore start */
        if (!opts)
            throw new TypeError('glob options required');
        /* c8 ignore stop */
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
            this.cwd = '';
        }
        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
            opts.cwd = node_url.fileURLToPath(opts.cwd);
        }
        this.cwd = opts.cwd || '';
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth =
            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== undefined) {
            throw new Error('cannot set absolute and withFileTypes:true');
        }
        if (typeof pattern === 'string') {
            pattern = [pattern];
        }
        this.windowsPathsNoEscape =
            !!opts.windowsPathsNoEscape ||
                opts.allowWindowsEscape ===
                    false;
        if (this.windowsPathsNoEscape) {
            pattern = pattern.map(p => p.replace(/\\/g, '/'));
        }
        if (this.matchBase) {
            if (opts.noglobstar) {
                throw new TypeError('base matching requires globstar');
            }
            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform$3;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
            this.scurry = opts.scurry;
            if (opts.nocase !== undefined &&
                opts.nocase !== opts.scurry.nocase) {
                throw new Error('nocase option contradicts provided scurry option');
            }
        }
        else {
            const Scurry = opts.platform === 'win32' ? PathScurryWin32$1
                : opts.platform === 'darwin' ? PathScurryDarwin$1
                    : opts.platform ? PathScurryPosix$1
                        : PathScurry$1;
            this.scurry = new Scurry(this.cwd, {
                nocase: opts.nocase,
                fs: opts.fs,
            });
        }
        this.nocase = this.scurry.nocase;
        // If you do nocase:true on a case-sensitive file system, then
        // we need to use regexps instead of strings for non-magic
        // path portions, because statting `aBc` won't return results
        // for the file `AbC` for example.
        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
        const mmo = {
            // default nocase based on platform
            ...opts,
            dot: this.dot,
            matchBase: this.matchBase,
            nobrace: this.nobrace,
            nocase: this.nocase,
            nocaseMagicOnly,
            nocomment: true,
            noext: this.noext,
            nonegate: true,
            optimizationLevel: 2,
            platform: this.platform,
            windowsPathsNoEscape: this.windowsPathsNoEscape,
            debug: !!this.opts.debug,
        };
        const mms = this.pattern.map(p => new Minimatch$1(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
            set[0].push(...m.set);
            set[1].push(...m.globParts);
            return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
            const g = globParts[i];
            /* c8 ignore start */
            if (!g)
                throw new Error('invalid pattern object');
            /* c8 ignore stop */
            return new Pattern$1(set, g, 0, this.platform);
        });
    }
    async walk() {
        // Walkers always return array of Path objects, so we just have to
        // coerce them into the right shape.  It will have already called
        // realpath() if the option was set to do so, so we know that's cached.
        // start out knowing the cwd, at least
        return [
            ...(await new GlobWalker$1(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walk()),
        ];
    }
    walkSync() {
        return [
            ...new GlobWalker$1(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walkSync(),
        ];
    }
    stream() {
        return new GlobStream$1(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).stream();
    }
    streamSync() {
        return new GlobStream$1(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
        return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
        return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
};

/**
 * Return true if the patterns provided contain any magic glob characters,
 * given the options provided.
 *
 * Brace expansion is not considered "magic" unless the `magicalBraces` option
 * is set, as brace expansion just turns one string into an array of strings.
 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
 * `'xby'` both do not contain any magic glob characters, and it's treated the
 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
 * is in the options, brace expansion _is_ treated as a pattern having magic.
 */
const hasMagic$1 = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
        pattern = [pattern];
    }
    for (const p of pattern) {
        if (new Minimatch$1(p, options).hasMagic())
            return true;
    }
    return false;
};

function globStreamSync$1(pattern, options = {}) {
    return new Glob$1(pattern, options).streamSync();
}
function globStream$1(pattern, options = {}) {
    return new Glob$1(pattern, options).stream();
}
function globSync$1(pattern, options = {}) {
    return new Glob$1(pattern, options).walkSync();
}
async function glob_$1(pattern, options = {}) {
    return new Glob$1(pattern, options).walk();
}
function globIterateSync$1(pattern, options = {}) {
    return new Glob$1(pattern, options).iterateSync();
}
function globIterate$1(pattern, options = {}) {
    return new Glob$1(pattern, options).iterate();
}
// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
const streamSync$1 = globStreamSync$1;
const stream$1 = Object.assign(globStream$1, { sync: globStreamSync$1 });
const iterateSync$1 = globIterateSync$1;
const iterate$1 = Object.assign(globIterate$1, {
    sync: globIterateSync$1,
});
const sync$1 = Object.assign(globSync$1, {
    stream: globStreamSync$1,
    iterate: globIterateSync$1,
});
const glob$1 = Object.assign(glob_$1, {
    glob: glob_$1,
    globSync: globSync$1,
    sync: sync$1,
    globStream: globStream$1,
    stream: stream$1,
    globStreamSync: globStreamSync$1,
    streamSync: streamSync$1,
    globIterate: globIterate$1,
    iterate: iterate$1,
    globIterateSync: globIterateSync$1,
    iterateSync: iterateSync$1,
    Glob: Glob$1,
    hasMagic: hasMagic$1,
    escape: escape$1,
    unescape: unescape$1,
});
glob$1.glob = glob$1;

let Position$1 = class Position {
    line;
    column;
    static from(positionOrLine, column) {
        if (typeof positionOrLine === "number") {
            return new Position(positionOrLine, column);
        }
        else {
            return new Position(positionOrLine.line, positionOrLine.column);
        }
    }
    static get zero() {
        return new Position(0, 0);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Location$1 = class Location {
    start;
    end;
    static from(locationOrLine, column, endLine, endColumn) {
        if (typeof locationOrLine === "number") {
            const start = Position$1.from(locationOrLine, column);
            const end = Position$1.from(endLine, endColumn);
            return new Location(start, end);
        }
        else {
            const start = Position$1.from(locationOrLine.start);
            const end = Position$1.from(locationOrLine.end);
            return new Location(start, end);
        }
    }
    static get zero() {
        return new Location(Position$1.zero, Position$1.zero);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Range$1 = class Range {
    start;
    end;
    static from(rangeOrStart, end) {
        if (typeof rangeOrStart === "number") {
            return new Range(rangeOrStart, end);
        }
        else {
            return new Range(rangeOrStart[0], rangeOrStart[1]);
        }
    }
    static get zero() {
        return new Range(0, 0);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Token$1 = class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range$1.from(token.range), Location$1.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/errors.ts.erb
let HerbError$1 = class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError$1(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
};
let UnexpectedError$1 = class UnexpectedError extends HerbError$1 {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` description: ${JSON.stringify(this.description)}\n`;
        output += ` expected: ${JSON.stringify(this.expected)}\n`;
        output += ` found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
};
let UnexpectedTokenError$1 = class UnexpectedTokenError extends HerbError$1 {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token$1.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += ` found: ${this.found ? this.found.treeInspect() : ""}\n`;
        return output;
    }
};
let MissingOpeningTagError$1 = class MissingOpeningTagError extends HerbError$1 {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            closing_tag: data.closing_tag ? Token$1.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : ""}\n`;
        return output;
    }
};
let MissingClosingTagError$1 = class MissingClosingTagError extends HerbError$1 {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        return output;
    }
};
let TagNamesMismatchError$1 = class TagNamesMismatchError extends HerbError$1 {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token$1.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        output += ` closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : ""}\n`;
        return output;
    }
};
let QuotesMismatchError$1 = class QuotesMismatchError extends HerbError$1 {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_quote: data.opening_quote ? Token$1.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token$1.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : ""}\n`;
        output += ` closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : ""}\n`;
        return output;
    }
};
let VoidElementClosingTagError$1 = class VoidElementClosingTagError extends HerbError$1 {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` expected: ${JSON.stringify(this.expected)}\n`;
        output += ` found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
};
let UnclosedElementError$1 = class UnclosedElementError extends HerbError$1 {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        return output;
    }
};
let RubyParseError$1 = class RubyParseError extends HerbError$1 {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` error_message: ${JSON.stringify(this.error_message)}\n`;
        output += ` diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += ` level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
};
let ERBControlFlowScopeError$1 = class ERBControlFlowScopeError extends HerbError$1 {
    keyword;
    static from(data) {
        return new ERBControlFlowScopeError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            keyword: data.keyword,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.keyword = props.keyword;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "ERB_CONTROL_FLOW_SCOPE_ERROR",
            keyword: this.keyword,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBControlFlowScopeError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` keyword: ${JSON.stringify(this.keyword)}\n`;
        return output;
    }
};
let MissingERBEndTagError$1 = class MissingERBEndTagError extends HerbError$1 {
    keyword;
    static from(data) {
        return new MissingERBEndTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            keyword: data.keyword,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.keyword = props.keyword;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSINGERB_END_TAG_ERROR",
            keyword: this.keyword,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingERBEndTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` keyword: ${JSON.stringify(this.keyword)}\n`;
        return output;
    }
};
function fromSerializedError$1(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError$1.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError$1.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError$1.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError$1.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError$1.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError$1.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError$1.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError$1.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError$1.from(error);
        case "ERB_CONTROL_FLOW_SCOPE_ERROR": return ERBControlFlowScopeError$1.from(error);
        case "MISSINGERB_END_TAG_ERROR": return MissingERBEndTagError$1.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}

function ensureString(object) {
    if (typeof object === "string") {
        return object;
    }
    throw new TypeError("Argument must be a string");
}
function convertToUTF8$1(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/nodes.ts.erb
let Node$1 = class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode$1(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length === 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError$1) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "   ", isLast, false);
            }
            else {
                const symbol = isLast ? " " : " ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? " " : " ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index === 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
};
let DocumentNode$1 = class DocumentNode extends Node$1 {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
};
let LiteralNode$1 = class LiteralNode extends Node$1 {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8$1(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` content: ${this.content ? JSON.stringify(this.content) : ""}\n`;
        return output;
    }
};
let HTMLOpenTagNode$1 = class HTMLOpenTagNode extends Node$1 {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : ""}\n`;
        return output;
    }
};
let HTMLCloseTagNode$1 = class HTMLCloseTagNode extends Node$1 {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let HTMLElementNode$1 = class HTMLElementNode extends Node$1 {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    source;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            open_tag: data.open_tag ? fromSerializedNode$1((data.open_tag)) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode$1(node)),
            close_tag: data.close_tag ? fromSerializedNode$1((data.close_tag)) : null,
            is_void: data.is_void,
            source: data.source,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
        this.source = props.source;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
            source: this.source,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` open_tag: ${this.inspectNode(this.open_tag, "   ")}`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` body: ${this.inspectArray(this.body, "   ")}`;
        output += ` close_tag: ${this.inspectNode(this.close_tag, "   ")}`;
        output += ` is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : ""}\n`;
        output += ` source: ${this.source ? JSON.stringify(this.source) : ""}\n`;
        return output;
    }
};
let HTMLAttributeValueNode$1 = class HTMLAttributeValueNode extends Node$1 {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            open_quote: data.open_quote ? Token$1.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            close_quote: data.close_quote ? Token$1.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` open_quote: ${this.open_quote ? this.open_quote.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` close_quote: ${this.close_quote ? this.close_quote.treeInspect() : ""}\n`;
        output += ` quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : ""}\n`;
        return output;
    }
};
let HTMLAttributeNameNode$1 = class HTMLAttributeNameNode extends Node$1 {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
};
let HTMLAttributeNode$1 = class HTMLAttributeNode extends Node$1 {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            name: data.name ? fromSerializedNode$1((data.name)) : null,
            equals: data.equals ? Token$1.from(data.equals) : null,
            value: data.value ? fromSerializedNode$1((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` name: ${this.inspectNode(this.name, "   ")}`;
        output += ` equals: ${this.equals ? this.equals.treeInspect() : ""}\n`;
        output += ` value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
};
let HTMLTextNode$1 = class HTMLTextNode extends Node$1 {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8$1(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` content: ${this.content ? JSON.stringify(this.content) : ""}\n`;
        return output;
    }
};
let HTMLCommentNode$1 = class HTMLCommentNode extends Node$1 {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            comment_start: data.comment_start ? Token$1.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            comment_end: data.comment_end ? Token$1.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` comment_start: ${this.comment_start ? this.comment_start.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` comment_end: ${this.comment_end ? this.comment_end.treeInspect() : ""}\n`;
        return output;
    }
};
let HTMLDoctypeNode$1 = class HTMLDoctypeNode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let XMLDeclarationNode$1 = class XMLDeclarationNode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let CDATANode$1 = class CDATANode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let WhitespaceNode$1 = class WhitespaceNode extends Node$1 {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            value: data.value ? Token$1.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` value: ${this.value ? this.value.treeInspect() : ""}\n`;
        return output;
    }
};
let ERBContentNode$1 = class ERBContentNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        // no-op for analyzed_ruby
        output += ` parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : ""}\n`;
        output += ` valid: ${typeof this.valid === 'boolean' ? String(this.valid) : ""}\n`;
        return output;
    }
};
let ERBEndNode$1 = class ERBEndNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let ERBElseNode$1 = class ERBElseNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBIfNode$1 = class ERBIfNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            subsequent: data.subsequent ? fromSerializedNode$1((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` subsequent: ${this.inspectNode(this.subsequent, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBBlockNode$1 = class ERBBlockNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` body: ${this.inspectArray(this.body, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBWhenNode$1 = class ERBWhenNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBCaseNode$1 = class ERBCaseNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` conditions: ${this.inspectArray(this.conditions, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBCaseMatchNode$1 = class ERBCaseMatchNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` conditions: ${this.inspectArray(this.conditions, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBWhileNode$1 = class ERBWhileNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBUntilNode$1 = class ERBUntilNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBForNode$1 = class ERBForNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBRescueNode$1 = class ERBRescueNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            subsequent: data.subsequent ? fromSerializedNode$1((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
};
let ERBEnsureNode$1 = class ERBEnsureNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBBeginNode$1 = class ERBBeginNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode$1((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode$1((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` rescue_clause: ${this.inspectNode(this.rescue_clause, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` ensure_clause: ${this.inspectNode(this.ensure_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBUnlessNode$1 = class ERBUnlessNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBYieldNode$1 = class ERBYieldNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let ERBInNode$1 = class ERBInNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
function fromSerializedNode$1(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode$1.from(node);
        case "AST_LITERAL_NODE": return LiteralNode$1.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode$1.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode$1.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode$1.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode$1.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode$1.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode$1.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode$1.from(node);
        case "AST_CDATA_NODE": return CDATANode$1.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode$1.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode$1.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode$1.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode$1.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode$1.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode$1.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode$1.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode$1.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode$1.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode$1.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode$1.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode$1.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode$1.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode$1.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode$1.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode$1.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode$1.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode$1.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

let Result$1 = class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
};

let HerbWarning$1 = class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location$1.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
};

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
let ParseResult$1 = class ParseResult extends Result$1 {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode$1.from(result.value), result.source, result.warnings.map((warning) => HerbWarning$1.from(warning)), result.errors.map((error) => HerbError$1.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
};

var name$1 = "@herb-tools/core";
var version$1$1 = "0.8.2";
var packageJSON = {
	name: name$1,
	version: version$1$1};

class TokenList {
    list;
    static from(list) {
        return new TokenList(list.map((token) => Token$1.from(token)));
    }
    constructor(list) {
        this.list = list;
    }
    get length() {
        return this.list.length;
    }
    get tokens() {
        return this.list;
    }
    [Symbol.iterator]() {
        return this.list[Symbol.iterator]();
    }
    at(index) {
        return this.list.at(index);
    }
    forEach(callback) {
        this.list.forEach(callback);
    }
    map(callback) {
        return this.list.map(callback);
    }
    filter(predicate) {
        return this.list.filter(predicate);
    }
    __getobj__() {
        return this.list;
    }
    inspect() {
        return this.list.map((token) => token.inspect()).join("\n") + "\n";
    }
    toString() {
        return this.inspect();
    }
}

/**
 * Represents the result of a lexical analysis, extending the base `Result` class.
 * It contains the token list, source code, warnings, and errors.
 */
class LexResult extends Result$1 {
    /** The list of tokens generated from the source code. */
    value;
    /**
     * Creates a `LexResult` instance from a serialized result.
     * @param result - The serialized lexical result containing tokens, source, warnings, and errors.
     * @returns A new `LexResult` instance.
     */
    static from(result) {
        return new LexResult(TokenList.from(result.tokens || []), result.source, result.warnings.map((warning) => HerbWarning$1.from(warning)), result.errors.map((error) => HerbError$1.from(error)));
    }
    /**
     * Constructs a new `LexResult`.
     * @param value - The list of tokens.
     * @param source - The source code that was lexed.
     * @param warnings - An array of warnings encountered during lexing.
     * @param errors - An array of errors encountered during lexing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the lexing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the lexing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
    /**
     * Converts the `LexResult` to a JSON representation.
     * @returns An object containing the token list, source, warnings, and errors.
     */
    toJSON() {
        return {
            value: this.value,
            source: this.source,
            warnings: this.warnings,
            errors: this.errors,
        };
    }
}

const DEFAULT_PARSER_OPTIONS = {
    track_whitespace: false,
};

/**
 * The main Herb parser interface, providing methods to lex and parse input.
 */
class HerbBackend {
    /** The backend instance handling lexing and parsing. */
    backend = undefined;
    backendPromise;
    /**
     * Creates a new Herb instance.
     * @param backendPromise - A promise resolving to a `LibHerbBackend` implementation for lexing and parsing.
     * @throws Error if no valid backend is provided.
     */
    constructor(backendPromise) {
        if (!backendPromise) {
            throw new Error("No LibHerb backend provided");
        }
        this.backendPromise = backendPromise;
    }
    /**
     * Loads the backend by resolving the backend promise.
     * @returns A promise containing the resolved `HerbBackend` instance after loading it.
     */
    async load() {
        const backend = await this.backendPromise();
        this.backend = backend;
        return this;
    }
    /**
     * Lexes the given source string into a `LexResult`.
     * @param source - The source code to lex.
     * @returns A `LexResult` instance.
     * @throws Error if the backend is not loaded.
     */
    lex(source) {
        this.ensureBackend();
        return LexResult.from(this.backend.lex(ensureString(source)));
    }
    /**
     * Lexes a file.
     * @param path - The file path to lex.
     * @returns A `LexResult` instance.
     * @throws Error if the backend is not loaded.
     */
    lexFile(path) {
        this.ensureBackend();
        return LexResult.from(this.backend.lexFile(ensureString(path)));
    }
    /**
     * Parses the given source string into a `ParseResult`.
     * @param source - The source code to parse.
     * @param options - Optional parsing options.
     * @returns A `ParseResult` instance.
     * @throws Error if the backend is not loaded.
     */
    parse(source, options) {
        this.ensureBackend();
        const mergedOptions = { ...DEFAULT_PARSER_OPTIONS, ...options };
        return ParseResult$1.from(this.backend.parse(ensureString(source), mergedOptions));
    }
    /**
     * Parses a file.
     * @param path - The file path to parse.
     * @returns A `ParseResult` instance.
     * @throws Error if the backend is not loaded.
     */
    parseFile(path) {
        this.ensureBackend();
        return ParseResult$1.from(this.backend.parseFile(ensureString(path)));
    }
    /**
     * Extracts embedded Ruby code from the given source.
     * @param source - The source code to extract Ruby from.
     * @returns The extracted Ruby code as a string.
     * @throws Error if the backend is not loaded.
     */
    extractRuby(source) {
        this.ensureBackend();
        return this.backend.extractRuby(ensureString(source));
    }
    /**
     * Extracts HTML from the given source.
     * @param source - The source code to extract HTML from.
     * @returns The extracted HTML as a string.
     * @throws Error if the backend is not loaded.
     */
    extractHTML(source) {
        this.ensureBackend();
        return this.backend.extractHTML(ensureString(source));
    }
    /**
     * Gets the Herb version information, including the core and backend versions.
     * @returns A version string containing backend, core, and libherb versions.
     * @throws Error if the backend is not loaded.
     */
    get version() {
        this.ensureBackend();
        const backend = this.backendVersion();
        const core = `${packageJSON.name}@${packageJSON.version}`;
        const libherb = this.backend.version();
        return `${backend}, ${core}, ${libherb}`;
    }
    /**
     * Ensures that the backend is loaded.
     * @throws Error if the backend is not loaded.
     */
    ensureBackend() {
        if (!this.isLoaded) {
            throw new Error("Herb backend is not loaded. Call `await Herb.load()` first.");
        }
    }
    /**
     * Checks if the backend is loaded.
     * @returns True if the backend is loaded, false otherwise.
     */
    get isLoaded() {
        return this.backend !== undefined;
    }
}

var name$2 = "@herb-tools/node-wasm";
var version$3 = "0.8.2";

class HerbBackendNodeWASM extends HerbBackend {
    backendVersion() {
        return `${name$2}@${version$3}`;
    }
}

// This code implements the `-sMODULARIZE` settings by taking the generated
// JS program code (INNER_JS_CODE) and wrapping it in a factory function.

// When targetting node and ES6 we use `await import ..` in the generated code
// so the outer function needs to be marked as async.
async function Herb$1(moduleArg = {}) {
  var moduleRtn;

// include: shell.js
// include: minimum_runtime_check.js
(function() {
  // "30.0.0" -> 300000
  function humanReadableVersionToPacked(str) {
    str = str.split('-')[0]; // Remove any trailing part from e.g. "12.53.3-alpha"
    var vers = str.split('.').slice(0, 3);
    while(vers.length < 3) vers.push('00');
    vers = vers.map((n, i, arr) => n.padStart(2, '0'));
    return vers.join('');
  }
  // 300000 -> "30.0.0"
  var packedVersionToHumanReadable = n => [n / 10000 | 0, (n / 100 | 0) % 100, n % 100].join('.');

  var TARGET_NOT_SUPPORTED = 2147483647;

  var currentNodeVersion = typeof process !== 'undefined' && process?.versions?.node ? humanReadableVersionToPacked(process.versions.node) : TARGET_NOT_SUPPORTED;
  if (currentNodeVersion < 160000) {
    throw new Error(`This emscripten-generated code requires node v${ packedVersionToHumanReadable(160000) } (detected v${packedVersionToHumanReadable(currentNodeVersion)})`);
  }

  var currentSafariVersion = typeof navigator !== 'undefined' && navigator?.userAgent?.includes("Safari/") && navigator.userAgent.match(/Version\/(\d+\.?\d*\.?\d*)/) ? humanReadableVersionToPacked(navigator.userAgent.match(/Version\/(\d+\.?\d*\.?\d*)/)[1]) : TARGET_NOT_SUPPORTED;
  if (currentSafariVersion < TARGET_NOT_SUPPORTED) {
    throw new Error(`This page was compiled without support for Safari browser. Pass -sMIN_SAFARI_VERSION=${currentSafariVersion} or lower to enable support for this browser.`);
  }
  if (currentSafariVersion < 2147483647) {
    throw new Error(`This emscripten-generated code requires Safari v${ packedVersionToHumanReadable(2147483647) } (detected v${currentSafariVersion})`);
  }

  var currentFirefoxVersion = typeof navigator !== 'undefined' && navigator?.userAgent?.match(/Firefox\/(\d+(?:\.\d+)?)/) ? parseFloat(navigator.userAgent.match(/Firefox\/(\d+(?:\.\d+)?)/)[1]) : TARGET_NOT_SUPPORTED;
  if (currentFirefoxVersion < TARGET_NOT_SUPPORTED) {
    throw new Error(`This page was compiled without support for Firefox browser. Pass -sMIN_FIREFOX_VERSION=${currentFirefoxVersion} or lower to enable support for this browser.`);
  }
  if (currentFirefoxVersion < 2147483647) {
    throw new Error(`This emscripten-generated code requires Firefox v2147483647 (detected v${currentFirefoxVersion})`);
  }

  var currentChromeVersion = typeof navigator !== 'undefined' && navigator?.userAgent?.match(/Chrome\/(\d+(?:\.\d+)?)/) ? parseFloat(navigator.userAgent.match(/Chrome\/(\d+(?:\.\d+)?)/)[1]) : TARGET_NOT_SUPPORTED;
  if (currentChromeVersion < TARGET_NOT_SUPPORTED) {
    throw new Error(`This page was compiled without support for Chrome browser. Pass -sMIN_CHROME_VERSION=${currentChromeVersion} or lower to enable support for this browser.`);
  }
  if (currentChromeVersion < 2147483647) {
    throw new Error(`This emscripten-generated code requires Chrome v2147483647 (detected v${currentChromeVersion})`);
  }
})();

// end include: minimum_runtime_check.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = moduleArg;

{
  // When building an ES module `require` is not normally available.
  // We need to use `createRequire()` to construct the require()` function.
  const { createRequire } = await import('module');
  /** @suppress{duplicate} */
  var require$1 = createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('herb-lint.js', document.baseURI).href)));

}
var quit_ = (status, toThrow) => {
  throw toThrow;
};

var _scriptName = (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('herb-lint.js', document.baseURI).href));

// Hooks that are implemented differently in different runtime environments.
var readBinary;

{

  // These modules will usually be used on Node.js. Load them eagerly to avoid
  // the complexity of lazy-loading.
  var fs = require$1('fs');

  if (_scriptName.startsWith('file:')) {
    require$1('path').dirname(require$1('url').fileURLToPath(_scriptName)) + '/';
  }

// include: node_shell_read.js
readBinary = (filename) => {
  // We need to re-wrap `file://` strings to URLs.
  filename = isFileURI(filename) ? new URL(filename) : filename;
  var ret = fs.readFileSync(filename);
  assert(Buffer.isBuffer(ret));
  return ret;
};
// end include: node_shell_read.js
  if (process.argv.length > 1) {
    process.argv[1].replace(/\\/g, '/');
  }

  process.argv.slice(2);

  quit_ = (status, toThrow) => {
    process.exitCode = status;
    throw toThrow;
  };

}

var out = console.log.bind(console);
var err = console.error.bind(console);

// perform assertions in shell.js after we set up out() and err(), as otherwise
// if an assertion fails it cannot print the message

assert(true, 'web environment detected but not enabled at build time.  Add `web` to `-sENVIRONMENT` to enable.');

assert(true, 'worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable.');

assert(true, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');

// end include: shell.js

// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;

if (!globalThis.WebAssembly) {
  err('no native wasm support detected');
}

// Wasm globals

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');

// include: runtime_common.js
// include: runtime_stack_check.js
// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // If the stack ends at address zero we write our cookies 4 bytes into the
  // stack.  This prevents interference with SAFE_HEAP and ASAN which also
  // monitor writes to address zero.
  if (max == 0) {
    max += 4;
  }
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAPU32[((max)>>2)] = 0x02135467;
  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAPU32[((0)>>2)] = 1668509029;
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  // See writeStackCookie().
  if (max == 0) {
    max += 4;
  }
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
  }
  // Also test the global address 0 for integrity.
  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {
    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
  }
}

// Endianness check
(() => {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) abort('Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)');
})();

function consumedModuleProp(prop) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      set() {
        abort(`Attempt to set \`Module.${prop}\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);

      }
    });
  }
}

function makeInvalidEarlyAccess(name) {
  return () => assert(false, `call to '${name}' via reference taken before Wasm module initialization`);

}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
  }
}

// forcing the filesystem exports a few things by default
function isExportedByForceFilesystem(name) {
  return name === 'FS_createPath' ||
         name === 'FS_createDataFile' ||
         name === 'FS_createPreloadedFile' ||
         name === 'FS_preloadFile' ||
         name === 'FS_unlink' ||
         name === 'addRunDependency' ||
         // The old FS has some functionality that WasmFS lacks.
         name === 'FS_createLazyFile' ||
         name === 'FS_createDevice' ||
         name === 'removeRunDependency';
}

function missingLibrarySymbol(sym) {

  // Any symbol that is not included from the JS library is also (by definition)
  // not exported on the Module object.
  unexportedRuntimeSymbol(sym);
}

function unexportedRuntimeSymbol(sym) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get() {
        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
        if (isExportedByForceFilesystem(sym)) {
          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
        }
        abort(msg);
      },
    });
  }
}

// end include: runtime_debug.js
var readyPromiseResolve, readyPromiseReject;

// Memory management
var
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

// BigInt64Array type is not correctly defined in closure
var
/** not-@type {!BigInt64Array} */
  HEAP64,
/* BigUint64Array type is not correctly defined in closure
/** not-@type {!BigUint64Array} */
  HEAPU64;

var runtimeInitialized = false;



function updateMemoryViews() {
  var b = wasmMemory.buffer;
  HEAP8 = new Int8Array(b);
  HEAP16 = new Int16Array(b);
  HEAPU8 = new Uint8Array(b);
  HEAPU16 = new Uint16Array(b);
  HEAP32 = new Int32Array(b);
  HEAPU32 = new Uint32Array(b);
  HEAPF32 = new Float32Array(b);
  HEAPF64 = new Float64Array(b);
  HEAP64 = new BigInt64Array(b);
  HEAPU64 = new BigUint64Array(b);
}

// include: memoryprofiler.js
// end include: memoryprofiler.js
// end include: runtime_common.js
assert(globalThis.Int32Array && globalThis.Float64Array && Int32Array.prototype.subarray && Int32Array.prototype.set,
       'JS engine does not provide full typed array support');

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  consumedModuleProp('preRun');
  // Begin ATPRERUNS hooks
  callRuntimeCallbacks(onPreRuns);
  // End ATPRERUNS hooks
}

function initRuntime() {
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  checkStackCookie();

  // No ATINITS hooks

  wasmExports['__wasm_call_ctors']();

  // No ATPOSTCTORS hooks
}

function postRun() {
  checkStackCookie();
   // PThreads reuse the runtime from the main thread.

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  consumedModuleProp('postRun');

  // Begin ATPOSTRUNS hooks
  callRuntimeCallbacks(onPostRuns);
  // End ATPOSTRUNS hooks
}

/** @param {string|number=} what */
function abort(what) {
  Module['onAbort']?.(what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // definition for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject?.(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// show errors on likely calls to FS when it was not included
var FS = {
  error() {
    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');
  },
  init() { FS.error(); },
  createDataFile() { FS.error(); },
  createPreloadedFile() { FS.error(); },
  createLazyFile() { FS.error(); },
  open() { FS.error(); },
  mkdev() { FS.error(); },
  registerDevice() { FS.error(); },
  analyzePath() { FS.error(); },

  ErrnoError() { FS.error(); },
};


function createExportWrapper(name, nargs) {
  return (...args) => {
    assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
    var f = wasmExports[name];
    assert(f, `exported native function \`${name}\` not found`);
    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.
    assert(args.length <= nargs, `native function \`${name}\` called with ${args.length} args but expects ${nargs}`);
    return f(...args);
  };
}

var wasmBinaryFile;

function findWasmBinary() {
  return base64Decode('AGFzbQEAAAABkgM0YAJ/fwF/YAAAYAJ/fwBgA39/fwBgAX8AYAR/f39/AGADf39/AX9gA39+fwF+YAZ/fH9/f38Bf2AGf39/f39/AGAFf39/f38AYAF/AX9gBX9/f39/AXxgCH9/f39/f39/AGAAAX9gBX9/f35+AGAEf39/fwF/YAR/fn9/AX9gBn9/f39/fgF/YAd/f39/fn9/AX9gBn9/f39/fwF/YAV/f39/fwF/YAh/f39/f39/fwF/YAd/f39/f39/AX9gCX9/f39/f39/fwF/YAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gAXwBf2ABfABgDX9/f39/f39/f39/f38Bf2ACf38BfGAEf39/fwF+YAF9AX9gAXwBfmACf38BfmAEf39+fgBgA39+fgBgBH9/f34AYAV/f39/fgBgAn5+AX9gAn9+AGACfH8BfGAFf35+fn4AYAR/fn5/AGAHf39/f39/fwBgBH9/f34BfmADfn9/AX9gAn5/AX9gBH5+fn4Bf2ACf3wAYAJ/fQBgAn5+AXwCpgYfA2VudgRleGl0AAQDZW52DV9fYXNzZXJ0X2ZhaWwABQNlbnYRX2VtdmFsX2dldF9nbG9iYWwACwNlbnYTX2VtdmFsX3NldF9wcm9wZXJ0eQADA2Vudg1fZW12YWxfZGVjcmVmAAQDZW52FV9lbXZhbF9jcmVhdGVfaW52b2tlcgAGA2Vudg1fZW12YWxfaW52b2tlAAwDZW52Fl9lbXZhbF9ydW5fZGVzdHJ1Y3RvcnMABANlbnYSX2VtdmFsX25ld19jc3RyaW5nAAsDZW52DV9lbXZhbF90eXBlb2YACwNlbnYTX2VtdmFsX2dldF9wcm9wZXJ0eQAAA2Vudg1fZW12YWxfaW5jcmVmAAQDZW52GV9lbWJpbmRfcmVnaXN0ZXJfZnVuY3Rpb24ADQNlbnYRX2VtdmFsX25ld19vYmplY3QADgNlbnYQX2VtdmFsX25ld19hcnJheQAOA2VudhVfZW1iaW5kX3JlZ2lzdGVyX3ZvaWQAAgNlbnYVX2VtYmluZF9yZWdpc3Rlcl9ib29sAAUDZW52GF9lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgAKA2VudhdfZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludAAPA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0AAMDZW52G19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZwACA2VudhxfZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAMDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZW12YWwABANlbnYcX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldwADA2VudglfYWJvcnRfanMAARZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX2Nsb3NlAAsWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF93cml0ZQAQFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfc2VlawARA2VudgpfbXVubWFwX2pzABIDZW52CF9tbWFwX2pzABMDZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAACwOvDa0NAQsLCwsLCwsLAAAAAAAAAAAAAAsLCwsLCwsLAAQABgsUFQAUFAACAAACCwAACwQLCgsQEBYXGBcQFBAUFBQUEBgUFxgWFxkZFhYWFhcaGBQXAgQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAIFFQkQCgYFBgUQChAKFQkVBgUGBQsEBAQEBAQEBAQEBAQEAgICCwsABA4OCwICABAAAAAAAAAAAAAAAAACAgIACwsLCwsGAAsLAAsGBgsEAgILCgIACwsLCwICBAULBQAGBgMAAAMLCwMEAgAGBAsLCwsLCwsACwAAAgILAgMDCwsECwYLAxALAAAGBgsLCwQLCwYLCwMDAAAAAAAOCwIACwsCCwsEAAsLAgAAAAMCAgIDBAIDAAAACwMFCwsCBAICAwsDAwMDAAsDAwALAwMDAwIDAwICAgICAgICAgICAwMDCwsLCxsAAgsOCwQLAgADCwsACxwBDgsLAgsLAgIGAAsFAgMDAwMCAwMCAwMCAAMDAwsDAwAFAwsLCwALDgsCCwsLCwsLCwsLCwsABQsLAAsOCwIDCwsACw4LCwsACw4CCwMLCwICAAADCwUDAxADBgICBAMAAQsBAAMDEBALCwYLGwsOCwsLAgICAgALBgsLCwALCwsLCwsLAg4ODgsLAAsbDgsLDgACBAECBAIEAgMCAgMDAgIDAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwAFCwsACw4LAgAFCwsACw4LAgsQCwsVBAAABgYAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgIEAgIDAwAABAUGAAYCAAYDBQUGCgIFBAQEBAQECwsABAYCBQACCwMGFQQLAAQAAAQABAsEAgAGCwIECwALAAADAAsACwsAAxULCwsACwYCCwsLBgsLCwsGCwALAAACAgICBQIAAgICAgIGBgAAFAUABAMLBgACBhAGAgsACxACAgYABgsAAgAEAAMXCwAAAAoLAwYJBQULCwAAAAAAAAULAAYGBhQLCxQVAgMAAAIQAhQGGBADAgICBAMCFQsDEAMQAAIQCxAAEAsLFQYAEBAAAAAAAAAACwILAgACAwIVFQACBgIQAgMABgYGBgAAAAYQEAsKEAACAwICAhAVEBAVAhACAgICBgkCFQoGAgYGAgYGFQIXFwULGAIDAAAAABYLEAsdFRUQFhUAAAIQFwAAAhcXEAIQAAIQFQIQAAIDEAICBhADFQQGFAILEBcQAAsQFBAQFBAQEAAQEAYUEAACAxAQEBAQEBQQEBAQEBAQFBAQEBAQEBUVFRQGAAMQEAACAgYAAAYAAgAAEBAQFAAeAAsQBgYfEAAQFQAWAAAAAAICFQICAgICEAIDAgYCAAsGCwICAAYEBgQCAAIAEAIAAAIGBgIGBgIAEAAAFRcVAgICCwMABRQKAgACCwYGEAIAAhUDAwsUCyAhAAADBgYFBgIGBgYVEBAQBhALAgICAAMLAhAQEBAUEAALBgMCAgoAAAYGEA0LCwAABQALAAAACwQDAAAAAAsAFQYVBgYGBgAiCwQECgMgIQsLAAsLAAsLAgADAwMDAgAFAAUEBgYAAAsACwYQBgAGBgAGCwALCwsCAAMABAALAAsABhALBgYEBQsFAwUAAgIjBCQlJQQmAhUGBAAGBQQDAwMECwsABAYLFRUVFRUDAwsEAQEOJwELCwQLBgcGCwYABgYLCwYQCwsOBwYGAAQEAAASARIADgEODg4OAQAQCwcAAAALCwYGBgYLKAspKisqJAULCSwiBR4tCwYLCwApFRcDCwUuLy8KBggCIRAGCwYACwYEAAAAAAYCAA4LKiswMCoxMgICDg4rKioBDg4OKjMACwEACwsBBAIAAAACBAMLAAsLCwINAQsLCwQACwsLBgICCwALBAACAwIGAwICAgsBCwsLCwICCw4ECwMLCwsLAwMGAAAEFQYABgsLCw4DAAEACwALAwMCAAAACwsEAgILDgsEBAQEBAYGCwYQAhQVFAUFBQoFCgoJCQsECw4EBwFwAYACgAIFBwEBgwKAgAIGEgN/AUGAgAQLfwFBAAt/AUEACwfZAhAGbWVtb3J5AgARX193YXNtX2NhbGxfY3RvcnMAHxlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQAGbWFsbG9jAK4MBGZyZWUAsAwNX19nZXRUeXBlTmFtZQDMCwZmZmx1c2gA1gsbZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduALMMGGVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZADLDBllbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlAMoMCHN0cmVycm9yAM8MFWVtc2NyaXB0ZW5fc3RhY2tfaW5pdADIDBllbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlAMkMGV9lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUAyQ0XX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2MAyg0cZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudADLDQn3AwEAQQEL/wEpKissLS4vMDE6PEpGR/cB7APUA9YD5QPmA+cDgASCBIYEigTjBOQE5wToBOkE6gTrBOwE7QTuBO8E8ATxBPIE8wT0BPUE9gT3BPgE+gT7BPwE/QT+BP8EgAWBBYIFgwWEBYUFhgWHBYgFiQWKBYsFjAWNBY4FjwWQBZEFkgWTBZQFlQWWBZcFmAWZBZoFmwWcBZ0FngWfBaAFoQWiBaMFpAWlBaYFpwWoBakFqgWrBawFrQWuBa8FsAWxBbIFswW0BbUFtgW3BbgFuQW6BbsFvAW9Bb4FvwXABcEFwgXDBcQFxQXGBccFyAXJBcoFywXMBc0FzgXPBdAF0QXSBdMF1AXVBdYF1wXYBdkF2gXbBdwF3QXeBd8F4AXhBeIF4wXkBeUF5gXnBegF6QXqBesF7AXtBe4F7wXwBfEF8gXzBfQF9QX2BfcF+AX5BfoF+wX8Bf0F/gX/BYAGgQaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GkAaRBpIGkwaUBpUGlgaXBpgGmQaaBpsGnAadBp4GnwagBqEGogajBqQGpQamBqcGqAapBqoGqwasBq0GiArACt0K3wrgCuEK4grOC9oL2QvYC/sL/AumDKcMqgywDbMNsQ2yDbYNtA25DccNxQ3ADbUNxg3EDcENCsKsJa0NDgAQyAwQngQQzwsQ+AsLIwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQCTA0EBcQ8LIwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQCUA0EBcQ8LIwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQCVA0EBcQ8LIwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQCWA0EBcQ8LIwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQCaA0EBcQ8LIwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQCbA0EBcQ8LIwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQCgA0EBcQ8LIwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQChA0EBcQ8LnwEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAiACKAIIKAKMAjYCAAJAAkADQCACKAIAQQBHQQFxRQ0BAkAgAigCACgCECACKAIEEP+LgIAADQAgAkEBQQFxOgAPDAMLIAIgAigCACgCADYCAAwACwsgAkEAQQFxOgAPCyACLQAPQQFxIQMgAkEQaiSAgICAACADDwu8AgEMfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFCACIAIoAhQ2AhACQAJAIAIoAhgvAQBB//8DcUHDAEZBAXFFDQAgAiACKAIYNgIMIAIoAgwoAhBBAEchA0EAIQQgA0EBcSEFIAQhBgJAIAVFDQAgAigCDCgCFEEARyEGCyACIAZBAXE6AAsgAigCDCgCLEEARyEHQQAhCCAHQQFxIQkgCCEKAkAgCUUNACACKAIMKAIwQQBHIQoLIAIgCkEBcToACgJAIAItAAtBAXFFDQAgAi0ACkEBcUUNACACKAIQQQE6AJIDIAJBAUEBcToAHwwCCwsgAigCGCELIAIoAhAhDCALQYGAgIAAIAwQt4aAgAAgAkEAQQFxOgAfCyACLQAfQQFxIQ0gAkEgaiSAgICAACANDwuxAgEEfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFCACIAIoAhQ2AhACQAJAIAIoAhgvAQBB//8DcUEORkEBcUUNACACIAIoAhg2AgwgAiACKAIMKAIoIAIoAgwoAiRrNgIIAkACQAJAIAIoAghBAkZBAXFFDQAgAigCDCgCJC0AAEH/AXFB5ABGQQFxRQ0AIAIoAgwoAiQtAAFB/wFxQe8ARkEBcQ0BCyACKAIIQQFGQQFxRQ0BIAIoAgwoAiQtAABB/wFxQfsARkEBcUUNAQsgAigCEEEBOgCXAyACQQFBAXE6AB8MAgsLIAIoAhghAyACKAIQIQQgA0GCgICAACAEELeGgIAAIAJBAEEBcToAHwsgAi0AH0EBcSEFIAJBIGokgICAgAAgBQ8LogEBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAiACKAIENgIAAkACQCACKAIILwEAQf//A3FBGUZBAXFFDQAgAigCAEEBOgCYAyACQQFBAXE6AA8MAQsgAigCCCEDIAIoAgAhBCADQYOAgIAAIAQQt4aAgAAgAkEAQQFxOgAPCyACLQAPQQFxIQUgAkEQaiSAgICAACAFDwuiAQEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBCACIAIoAgQ2AgACQAJAIAIoAggvAQBB//8DcUEYRkEBcUUNACACKAIAQQE6AJkDIAJBAUEBcToADwwBCyACKAIIIQMgAigCACEEIANBhICAgAAgBBC3hoCAACACQQBBAXE6AA8LIAItAA9BAXEhBSACQRBqJICAgIAAIAUPC6MBAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEIAIgAigCBDYCAAJAAkAgAigCCC8BAEH//wNxQZUBRkEBcUUNACACKAIAQQE6AJ0DIAJBAUEBcToADwwBCyACKAIIIQMgAigCACEEIANBhYCAgAAgBBC3hoCAACACQQBBAXE6AA8LIAItAA9BAXEhBSACQRBqJICAgIAAIAUPC6IBAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEIAIgAigCBDYCAAJAAkAgAigCCC8BAEH//wNxQTdGQQFxRQ0AIAIoAgBBAToAnAMgAkEBQQFxOgAPDAELIAIoAgghAyACKAIAIQQgA0GGgICAACAEELeGgIAAIAJBAEEBcToADwsgAi0AD0EBcSEFIAJBEGokgICAgAAgBQ8LowEBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAiACKAIENgIAAkACQCACKAIILwEAQf//A3FBkwFGQQFxRQ0AIAIoAgBBAToAngMgAkEBQQFxOgAPDAELIAIoAgghAyACKAIAIQQgA0GHgICAACAEELeGgIAAIAJBAEEBcToADwsgAi0AD0EBcSEFIAJBEGokgICAgAAgBQ8LogEBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAiACKAIENgIAAkACQCACKAIILwEAQf//A3FBC0ZBAXFFDQAgAigCAEEBOgCfAyACQQFBAXE6AA8MAQsgAigCCCEDIAIoAgAhBCADQYiAgIAAIAQQt4aAgAAgAkEAQQFxOgAPCyACLQAPQQFxIQUgAkEQaiSAgICAACAFDwu8AgEMfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFCACIAIoAhQ2AhACQAJAIAIoAhgvAQBB//8DcUGSAUZBAXFFDQAgAiACKAIYNgIMIAIoAgwoAhBBAEchA0EAIQQgA0EBcSEFIAQhBgJAIAVFDQAgAigCDCgCFEEARyEGCyACIAZBAXE6AAsgAigCDCgCLEEARyEHQQAhCCAHQQFxIQkgCCEKAkAgCUUNACACKAIMKAIwQQBHIQoLIAIgCkEBcToACgJAIAItAAtBAXFFDQAgAi0ACkEBcUUNACACKAIQQQE6AKIDIAJBAUEBcToAHwwCCwsgAigCGCELIAIoAhAhDCALQYmAgIAAIAwQt4aAgAAgAkEAQQFxOgAfCyACLQAfQQFxIQ0gAkEgaiSAgICAACANDwt0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAIAEoAghBh6aEgAAQqICAgABBAXFFDQAgASgCCEEBOgCTAyABQQFBAXE6AA8MAQsgAUEAQQFxOgAPCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwt0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAIAEoAghByKaEgAAQqICAgABBAXFFDQAgASgCCEEBOgCUAyABQQFBAXE6AA8MAQsgAUEAQQFxOgAPCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwuaAQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIAkACQCABKAIIQYinhIAAEKiAgIAAQQFxRQ0AAkAgASgCCEGmp4SAABCogICAAEEBcUUNACABQQBBAXE6AA8MAgsgASgCCEEBOgCVAyABQQFBAXE6AA8MAQsgAUEAQQFxOgAPCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwt0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAIAEoAghBr6WEgAAQqICAgABBAXFFDQAgASgCCEEBOgCWAyABQQFBAXE6AA8MAQsgAUEAQQFxOgAPCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwt0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAIAEoAghB6KWEgAAQqICAgABBAXFFDQAgASgCCEEBOgCaAyABQQFBAXE6AA8MAQsgAUEAQQFxOgAPCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwt0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAIAEoAghBy6WEgAAQqICAgABBAXFFDQAgASgCCEEBOgCbAyABQQFBAXE6AA8MAQsgAUEAQQFxOgAPCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwt0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAIAEoAghBp6aEgAAQqICAgABBAXFFDQAgASgCCEEBOgCgAyABQQFBAXE6AA8MAQsgAUEAQQFxOgAPCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwt0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAIAEoAghB56aEgAAQqICAgABBAXFFDQAgASgCCEEBOgChAyABQQFBAXE6AA8MAQsgAUEAQQFxOgAPCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwujAQEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBCACIAIoAgQ2AgACQAJAIAIoAggvAQBB//8DcUGXAUZBAXFFDQAgAigCAEEBOgCjAyACQQFBAXE6AA8MAQsgAigCCCEDIAIoAgAhBCADQYqAgIAAIAQQt4aAgAAgAkEAQQFxOgAPCyACLQAPQQFxIQUgAkEQaiSAgICAACAFDwuBCgEdfyOAgICAAEHAAWshASABJICAgIAAIAEgADYCvAEgASgCvAEoAgBBb2ohAiACQQtLGgJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4MAAEJAgMEBQYJCQcICQsgASABKAK8ATYCuAECQCABKAK4ASgCLEEARkEBcUUNACABKAK4ASgCGEEMaiEDIAEoArgBKAIgQQxqQQhqIQQgASgCvAEoAhQhBUGv5YWAABogASADKQIANwMQIAEgBCkCADcDCEGv5YWAACABQRBqIAFBCGogBRCmgYCAAAsMCQsgASABKAK8ATYCtAECQCABKAK0ASgCKEEARkEBcUUNACABKAK0ASgCGEEMaiEGIAEoArQBKAIgQQxqQQhqIQcgASgCvAEoAhQhCEG8g4WAABogASAGKQIANwMgIAEgBykCADcDGEG8g4WAACABQSBqIAFBGGogCBCmgYCAAAsMCAsgASABKAK8ATYCsAECQCABKAKwASgCMEEARkEBcUUNACABKAKwASgCGEEMaiEJIAEoArABKAIgQQxqQQhqIQogASgCvAEoAhQhC0HW5YWAABogASAJKQIANwMwIAEgCikCADcDKEHW5YWAACABQTBqIAFBKGogCxCmgYCAAAsMBwsgASABKAK8ATYCrAECQCABKAKsASgCMEEARkEBcUUNACABKAKsASgCGEEMaiEMIAEoAqwBKAIgQQxqQQhqIQ0gASgCvAEoAhQhDkHW5YWAABogASAMKQIANwNAIAEgDSkCADcDOEHW5YWAACABQcAAaiABQThqIA4QpoGAgAALDAYLIAEgASgCvAE2AqgBAkAgASgCqAEoAihBAEZBAXFFDQAgASgCqAEoAhhBDGohDyABKAKoASgCIEEMakEIaiEQIAEoArwBKAIUIRFB8uWFgAAaIAEgDykCADcDUCABIBApAgA3A0hB8uWFgAAgAUHQAGogAUHIAGogERCmgYCAAAsMBQsgASABKAK8ATYCpAECQCABKAKkASgCKEEARkEBcUUNACABKAKkASgCGEEMaiESIAEoAqQBKAIgQQxqQQhqIRMgASgCvAEoAhQhFEGF5YWAABogASASKQIANwNgIAEgEykCADcDWEGF5YWAACABQeAAaiABQdgAaiAUEKaBgIAACwwECyABIAEoArwBNgKgAQJAIAEoAqABKAIoQQBGQQFxRQ0AIAEoAqABKAIYQQxqIRUgASgCoAEoAiBBDGpBCGohFiABKAK8ASgCFCEXQcbkhYAAGiABIBUpAgA3A3AgASAWKQIANwNoQcbkhYAAIAFB8ABqIAFB6ABqIBcQpoGAgAALDAMLIAEgASgCvAE2ApwBAkAgASgCnAEoAjRBAEZBAXFFDQAgASgCnAEoAhhBDGohGCABKAKcASgCIEEMakEIaiEZIAEoArwBKAIUIRpB3+SFgAAaIAEgGCkCADcDgAEgASAZKQIANwN4Qd/khYAAIAFBgAFqIAFB+ABqIBoQpoGAgAALDAILIAEgASgCvAE2ApgBAkAgASgCmAEoAixBAEZBAXFFDQAgASgCmAEoAhhBDGohGyABKAKYASgCIEEMakEIaiEcIAEoArwBKAIUIR1Bt+SFgAAaIAEgGykCADcDkAEgASAcKQIANwOIAUG35IWAACABQZABaiABQYgBaiAdEKaBgIAACwwBCwsgAUHAAWokgICAgAAPC8oUAR9/I4CAgIAAQeABayECIAIkgICAgAAgAiAANgLcASACIAE2AtgBIAIgAigC2AE2AtQBIAIoAtwBIQMgAigC1AEgAzYCBAJAIAIoAtwBKAIADQAgAiACKALcATYC0AEgAiACKALQASgCGDYCzAEgAigC3AEgAigC0AEoAhggAigC1AEQvYCAgAAhBCACKALQASAENgIYIAJBzAFqELiCgIAACwJAIAIoAtwBKAIAQQJGQQFxRQ0AIAIgAigC3AE2AsgBIAIgAigCyAEoAiQ2AsQBIAIoAtwBIAIoAsgBKAIkIAIoAtQBEL2AgIAAIQUgAigCyAEgBTYCJCACQcQBahC4goCAAAsCQCACKALcASgCAEEDRkEBcUUNACACIAIoAtwBNgLAASACIAIoAsABKAIgNgK8ASACKALcASACKALAASgCICACKALUARC9gICAACEGIAIoAsABIAY2AiAgAkG8AWoQuIKAgAALAkAgAigC3AEoAgBBBEZBAXFFDQAgAiACKALcATYCuAEgAiACKAK4ASgCIDYCtAEgAigC3AEgAigCuAEoAiAgAigC1AEQvYCAgAAhByACKAK4ASAHNgIgIAJBtAFqELiCgIAACwJAIAIoAtwBKAIAQQVGQQFxRQ0AIAIgAigC3AE2ArABIAIgAigCsAEoAhw2AqwBIAIoAtwBIAIoArABKAIcIAIoAtQBEL2AgIAAIQggAigCsAEgCDYCHCACQawBahC4goCAAAsCQCACKALcASgCAEEGRkEBcUUNACACIAIoAtwBNgKoASACIAIoAqgBKAIYNgKkASACKALcASACKAKoASgCGCACKALUARC9gICAACEJIAIoAqgBIAk2AhggAkGkAWoQuIKAgAALAkAgAigC3AEoAgBBCUZBAXFFDQAgAiACKALcATYCoAEgAiACKAKgASgCHDYCnAEgAigC3AEgAigCoAEoAhwgAigC1AEQvYCAgAAhCiACKAKgASAKNgIcIAJBnAFqELiCgIAACwJAIAIoAtwBKAIAQQpGQQFxRQ0AIAIgAigC3AE2ApgBIAIgAigCmAEoAhw2ApQBIAIoAtwBIAIoApgBKAIcIAIoAtQBEL2AgIAAIQsgAigCmAEgCzYCHCACQZQBahC4goCAAAsCQCACKALcASgCAEELRkEBcUUNACACIAIoAtwBNgKQASACIAIoApABKAIcNgKMASACKALcASACKAKQASgCHCACKALUARC9gICAACEMIAIoApABIAw2AhwgAkGMAWoQuIKAgAALAkAgAigC3AEoAgBBDEZBAXFFDQAgAiACKALcATYCiAEgAiACKAKIASgCHDYChAEgAigC3AEgAigCiAEoAhwgAigC1AEQvYCAgAAhDSACKAKIASANNgIcIAJBhAFqELiCgIAACwJAIAIoAtwBKAIAQRBGQQFxRQ0AIAIgAigC3AE2AoABIAIgAigCgAEoAiQ2AnwgAigC3AEgAigCgAEoAiQgAigC1AEQvYCAgAAhDiACKAKAASAONgIkIAJB/ABqELiCgIAACwJAIAIoAtwBKAIAQRFGQQFxRQ0AIAIgAigC3AE2AnggAiACKAJ4KAIkNgJ0IAIoAtwBIAIoAngoAiQgAigC1AEQvYCAgAAhDyACKAJ4IA82AiQgAkH0AGoQuIKAgAALAkAgAigC3AEoAgBBEkZBAXFFDQAgAiACKALcATYCcCACIAIoAnAoAiQ2AmwgAigC3AEgAigCcCgCJCACKALUARC9gICAACEQIAIoAnAgEDYCJCACQewAahC4goCAAAsCQCACKALcASgCAEETRkEBcUUNACACIAIoAtwBNgJoIAIgAigCaCgCJDYCZCACKALcASACKAJoKAIkIAIoAtQBEL2AgIAAIREgAigCaCARNgIkIAJB5ABqELiCgIAACwJAIAIoAtwBKAIAQRRGQQFxRQ0AIAIgAigC3AE2AmAgAiACKAJgKAIkNgJcIAIoAtwBIAIoAmAoAiQgAigC1AEQvYCAgAAhEiACKAJgIBI2AiQgAkHcAGoQuIKAgAALAkAgAigC3AEoAgBBFEZBAXFFDQAgAiACKALcATYCWCACIAIoAlgoAig2AlQgAigC3AEgAigCWCgCKCACKALUARC9gICAACETIAIoAlggEzYCKCACQdQAahC4goCAAAsCQCACKALcASgCAEEVRkEBcUUNACACIAIoAtwBNgJQIAIgAigCUCgCJDYCTCACKALcASACKAJQKAIkIAIoAtQBEL2AgIAAIRQgAigCUCAUNgIkIAJBzABqELiCgIAACwJAIAIoAtwBKAIAQRVGQQFxRQ0AIAIgAigC3AE2AkggAiACKAJIKAIoNgJEIAIoAtwBIAIoAkgoAiggAigC1AEQvYCAgAAhFSACKAJIIBU2AiggAkHEAGoQuIKAgAALAkAgAigC3AEoAgBBFkZBAXFFDQAgAiACKALcATYCQCACIAIoAkAoAiQ2AjwgAigC3AEgAigCQCgCJCACKALUARC9gICAACEWIAIoAkAgFjYCJCACQTxqELiCgIAACwJAIAIoAtwBKAIAQRdGQQFxRQ0AIAIgAigC3AE2AjggAiACKAI4KAIkNgI0IAIoAtwBIAIoAjgoAiQgAigC1AEQvYCAgAAhFyACKAI4IBc2AiQgAkE0ahC4goCAAAsCQCACKALcASgCAEEYRkEBcUUNACACIAIoAtwBNgIwIAIgAigCMCgCJDYCLCACKALcASACKAIwKAIkIAIoAtQBEL2AgIAAIRggAigCMCAYNgIkIAJBLGoQuIKAgAALAkAgAigC3AEoAgBBGUZBAXFFDQAgAiACKALcATYCKCACIAIoAigo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KyArKAIAQX9qNgIACwJAIAItAG5BAXFFDQAgAigCcCEsICwgLCgCBEF/ajYCBAsgAiACLQArQQFxOgB/CyACLQB/QQFxIS0gAkGAAWokgICAgAAgLQ8LjAMDAn8BfgN/I4CAgIAAQeADayECIAIkgICAgAAgAiAANgLcAyACIAE2AtgDIAIgAigC2AMQuIGAgAA2AtQDAkACQCACKALUA0EAR0EBcQ0ADAELIAJBwABqIQNCACEEIAMgBDcDACACQThqIAQ3AwAgAkEwaiAENwMAIAJBKGogBDcDACACQSBqIAQ3AwAgAkEYaiAENwMAIAIgBDcDECACQQE6AEQgAigC1AMhBSACKALUAxCBjICAACEGIAJByABqIAUgBiACQRBqELuGgIAAIAIgAkHIAGoQz4aAgAA2AgwgAiACKALUAjYCCAJAA0AgAigCCEEAR0EBcUUNASACIAIoAgggAigC3AMgAigC2AMgAkHIAGoQmYKAgAA2AgQgAigC3AMoAhQgAigCBBCxgoCAACACIAIoAggoAgA2AggMAAsLIAIoAgwhByACQcgAaiAHELSGgIAAIAJByABqEMmGgIAAIAJBEGoQuoaAgAAgAigC1AMQsIyAgAALIAJB4ANqJICAgIAADwvqAwEUfyOAgICAAEEQayEBIAEkgICAgAAgASAAKQIANwMAIAEgARDMgICAADYCDCABKAIMKAKMAyECIAEoAgwhAyACQYGAgIAAIAMQtoaAgAAgASgCDCgCjAMhBCABKAIMIQUgBEGCgICAACAFELaGgIAAIAEoAgwoAowDIQYgASgCDCEHIAZBg4CAgAAgBxC2hoCAACABKAIMKAKMAyEIIAEoAgwhCSAIQYSAgIAAIAkQtoaAgAAgASgCDCgCjAMhCiABKAIMIQsgCkGFgICAACALELaGgIAAIAEoAgwoAowDIQwgASgCDCENIAxBhoCAgAAgDRC2hoCAACABKAIMKAKMAyEOIAEoAgwhDyAOQYeAgIAAIA8QtoaAgAAgASgCDCgCjAMhECABKAIMIREgEEGIgICAACARELaGgIAAIAEoAgwoAowDIRIgASgCDCETIBJBiYCAgAAgExC2hoCAACABKAIMELKAgIAAGiABKAIMELOAgIAAGiABKAIMELSAgIAAGiABKAIMELaAgIAAGiABKAIMELeAgIAAGiABKAIMELiAgIAAGiABKAIMELmAgIAAGiABKAIMKAKMAyABKAIMELqAgIAAGiABKAIMELWAgIAAGiABKAIMIRQgAUEQaiSAgICAACAUDwvhBgEEfyOAgICAAEHAAGshAiACIAA2AjggAiABNgI0AkACQCACKAI4QQBHQQFxDQAgAkEBQQFxOgA/DAELIAIgAigCNDYCMCACIAIoAjAoAgA2AiwgAkESNgIoIAJBfzYCJCACKAI4LwEAIQMCQAJAAkACQAJAAkAgA0ELRg0AIANBEUYNAyADQRNGDQICQAJAAkACQCADQRhGDQACQCADQRlGDQAgA0E3Rg0EAkACQCADQcMARg0AIANB6wBGDQogA0GEAUYNCiADQZIBRg0BIANBkwFGDQUgA0GVAUYNBCADQZcBRg0IDAsLIAIgAigCODYCICACQQA2AiggAiACKAIgKAIQIAIoAjAoAgRrNgIkDAsLIAIgAigCODYCHCACQQs2AiggAiACKAIcKAIQIAIoAjAoAgRrNgIkDAoLIAIgAigCODYCGCACQQQ2AiggAiACKAIYKAIkIAIoAjAoAgRrNgIkDAkLIAIgAigCODYCFCACQQU2AiggAiACKAIUKAIkIAIoAjAoAgRrNgIkDAgLIAIgAigCODYCECACQQw2AiggAiACKAIQKAIQIAIoAjAoAgRrNgIkDAcLIAIgAigCODYCDCACQQ02AiggAiACKAIMKAIQIAIoAjAoAgRrNgIkDAYLIAIgAigCODYCCCACQQ42AiggAiACKAIIKAIcIAIoAjAoAgRrNgIkDAULIAIgAigCODYCBCACQQg2AigCQAJAIAIoAgQoAhBBAEdBAXFFDQAgAiACKAIEKAIQIAIoAjAoAgRrNgIkDAELIAIgAigCOCgCCCACKAIwKAIEazYCJAsMBAsgAkERNgIoIAIgAigCOCgCCCACKAIwKAIEazYCJAwDCyACIAIoAjg2AgACQCACKAIAKAI8QQBHQQFxRQ0AIAJBDzYCKCACIAIoAjgoAgggAigCMCgCBGs2AiQLDAILIAJBEjYCKCACIAIoAjgoAgggAigCMCgCBGs2AiQMAQsLAkAgAigCJEF/R0EBcUUNAAJAAkAgAigCLC0ACEEBcUUNACACKAIkIAIoAiwoAgRJQQFxRQ0BCyACKAIoIQQgAigCLCAENgIAIAIoAiQhBSACKAIsIAU2AgQgAigCLEEBOgAICwsgAkEBQQFxOgA/CyACLQA/QQFxDwueAgELfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBAJAAkAgAigCBEEDRkEBcUUNACACQQFBAXE6AA8MAQsgAigCCEF6aiEDIANBCUsaAkACQAJAAkAgAw4KAAEDAwMDAwMDAgMLIAIoAgRBBkYhBEEBIQUgBEEBcSEGIAUhBwJAIAYNACACKAIEQQJGIQcLIAIgB0EBcToADwwDCyACKAIEQQdGIQhBASEJIAhBAXEhCiAJIQsCQCAKDQAgAigCBEECRiELCyACIAtBAXE6AA8MAgsgAiACKAIEQRBGQQFxOgAPDAELIAIgAigCCCACKAIEEMSAgIAAQQFxOgAPCyACLQAPQQFxIQwgAkEQaiSAgICAACAMDwvWAgEEfyOAgICAAEEQayEBIAEkgICAgAAgAUGkAxCujICAADYCDCABKAIMIAAoAgAgACgCBEEAELuGgIAAIAEoAgwQz4aAgAAhAiABKAIMIAI2AowDIAEoAgwoAogCQQBGIQMgASgCDCADQQFxOgCQAyABKAIMQQE6AJEDIAEoAgxBADoAkgMgASgCDEEAOgCTAyABKAIMQQA6AJQDIAEoAgxBADoAlQMgASgCDEEAOgCXAyABKAIMQQA6AJYDIAEoAgxBADoAmAMgASgCDEEAOgCZAyABKAIMQQA6AJoDIAEoAgxBADoAmwMgASgCDEEAOgCcAyABKAIMQQA6AJ0DIAEoAgxBADoAngMgASgCDEEAOgCfAyABKAIMQQA6AKADIAEoAgxBADoAoQMgASgCDEEAOgCiAyABKAIMQQA6AKMDIAEoAgwhBCABQRBqJICAgIAAIAQPC40BAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQAJAIAEoAgxBAEdBAXENAAwBCwJAIAEoAgwtAJEDQQFxRQ0AIAEoAgwoAowDQQBHQQFxRQ0AIAEoAgwgASgCDCgCjAMQtIaAgAALIAEoAgwQyYaAgAAgASgCDBCwjICAAAsgAUEQaiSAgICAAA8L/wEBAX8jgICAgABBEGshASABIAA2AggCQAJAIAEoAggtAJUDQQFxRQ0AIAFBgOaFgAA2AgwMAQsCQCABKAIILQCUA0EBcUUNACABQcnlhYAANgIMDAELAkAgASgCCC0AkwNBAXFFDQAgAUGh5YWAADYCDAwBCwJAIAEoAggtAJoDQQFxRQ0AIAFB+OSFgAA2AgwMAQsCQCABKAIILQCbA0EBcUUNACABQe3khYAANgIMDAELAkAgASgCCC0AoANBAXFFDQAgAUG65YWAADYCDAwBCwJAIAEoAggtAKEDQQFxRQ0AIAFB4+WFgAA2AgwMAQsgAUEANgIMCyABKAIMDwu5AQEEfyOAgICAAEEQayEFIAUkgICAgAAgBSAANgIMIAUgATYCCCAFIAQ2AgQCQAJAIAUoAgxBAEdBAXENAAwBCyAFKAIIIQYgBSgCDCAGNgIAIAUoAgxBBGogAikCADcCACAFKAIMQQRqQQhqIAMpAgA3AgACQCAFKAIEQQBGQQFxRQ0AQQgQsIKAgAAhByAFKAIMIAc2AhQMAQsgBSgCBCEIIAUoAgwgCDYCFAsgBUEQaiSAgICAAA8LqQEBB38jgICAgABBIGshASABJICAgIAAIAEgADYCHCABQRwQroyAgAA2AhggASgCGCECIAEoAhxBDGohAyABKAIcQQxqQQhqIQRBARogASADKQIANwMQIAEgBCkCADcDCEEAIQUgAkEBIAFBEGogAUEIaiAFEM+AgIAAIAEoAhwoAgAQp4KAgAAhBiABKAIYIAY2AhggASgCGCEHIAFBIGokgICAgAAgBw8LkAEBBX8jgICAgABBIGshBCAEJICAgIAAIAQgADYCHCAEIAM2AhggBEEcEK6MgIAANgIUIAQoAhQhBSAEKAIYIQZBABogBCABKQIANwMIIAQgAikCADcDACAFQQAgBEEIaiAEIAYQz4CAgAAgBCgCHCEHIAQoAhQgBzYCGCAEKAIUIQggBEEgaiSAgICAACAIDwuWAQEFfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgAzYCGCAEQRwQroyAgAA2AhQgBCgCFCEFIAQoAhghBkEBGiAEIAEpAgA3AwggBCACKQIANwMAIAVBASAEQQhqIAQgBhDPgICAACAEKAIcEKeCgIAAIQcgBCgCFCAHNgIYIAQoAhQhCCAEQSBqJICAgIAAIAgPC4UCAQl/I4CAgIAAQTBrIQggCCSAgICAACAIIAA2AiwgCCABNgIoIAggAjYCJCAIIAM2AiAgCCAEOgAfIAggBzYCGCAIQSwQroyAgAA2AhQgCCgCFCEJIAgoAhghCkECGiAIIAUpAgA3AwggCCAGKQIANwMAIAlBAiAIQQhqIAggChDPgICAACAIKAIsEKCCgIAAIQsgCCgCFCALNgIYIAgoAigQoIKAgAAhDCAIKAIUIAw2AhwgCCgCJBCggoCAACENIAgoAhQgDTYCICAIKAIgIQ4gCCgCFCAONgIkIAgtAB8hDyAIKAIUIA9BAXE6ACggCCgCFCEQIAhBMGokgICAgAAgEA8L7QEBCH8jgICAgABBMGshByAHJICAgIAAIAcgADYCLCAHIAE2AiggByACNgIkIAcgAzYCICAHIAY2AhwgB0EoEK6MgIAANgIYIAcoAhghCCAHKAIcIQlBAxogByAEKQIANwMQIAcgBSkCADcDCCAIQQMgB0EQaiAHQQhqIAkQz4CAgAAgBygCLBCggoCAACEKIAcoAhggCjYCGCAHKAIoEKCCgIAAIQsgBygCGCALNgIcIAcoAiQhDCAHKAIYIAw2AiAgBygCIBCggoCAACENIAcoAhggDTYCJCAHKAIYIQ4gB0EwaiSAgICAACAODwuRAgEKfyOAgICAAEEwayEJIAkkgICAgAAgCSAANgIsIAkgATYCKCAJIAI2AiQgCSADNgIgIAkgBDoAHyAJIAU2AhggCSAINgIUIAlBMBCujICAADYCECAJKAIQIQogCSgCFCELQQQaIAkgBikCADcDCCAJIAcpAgA3AwAgCkEEIAlBCGogCSALEM+AgIAAIAkoAiwhDCAJKAIQIAw2AhggCSgCKBCggoCAACENIAkoAhAgDTYCHCAJKAIkIQ4gCSgCECAONgIgIAkoAiAhDyAJKAIQIA82AiQgCS0AHyEQIAkoAhAgEEEBcToAKCAJKAIYIREgCSgCECARNgIsIAkoAhAhEiAJQTBqJICAgIAAIBIPC+oBAQh/I4CAgIAAQTBrIQcgBySAgICAACAHIAA2AiwgByABNgIoIAcgAjYCJCAHIAM6ACMgByAGNgIcIAdBKBCujICAADYCGCAHKAIYIQggBygCHCEJQQUaIAcgBCkCADcDECAHIAUpAgA3AwggCEEFIAdBEGogB0EIaiAJEM+AgIAAIAcoAiwQoIKAgAAhCiAHKAIYIAo2AhggBygCKCELIAcoAhggCzYCHCAHKAIkEKCCgIAAIQwgBygCGCAMNgIgIActACMhDSAHKAIYIA1BAXE6ACQgBygCGCEOIAdBMGokgICAgAAgDg8LkAEBBX8jgICAgABBIGshBCAEJICAgIAAIAQgADYCHCAEIAM2AhggBEEcEK6MgIAANgIUIAQoAhQhBSAEKAIYIQZBBhogBCABKQIANwMIIAQgAikCADcDACAFQQYgBEEIaiAEIAYQz4CAgAAgBCgCHCEHIAQoAhQgBzYCGCAEKAIUIQggBEEgaiSAgICAACAIDwvJAQEHfyOAgICAAEEwayEGIAYkgICAgAAgBiAANgIsIAYgATYCKCAGIAI2AiQgBiAFNgIgIAZBJBCujICAADYCHCAGKAIcIQcgBigCICEIQQcaIAYgAykCADcDECAGIAQpAgA3AwggB0EHIAZBEGogBkEIaiAIEM+AgIAAIAYoAiwhCSAGKAIcIAk2AhggBigCKBCggoCAACEKIAYoAhwgCjYCHCAGKAIkIQsgBigCHCALNgIgIAYoAhwhDCAGQTBqJICAgIAAIAwPC5YBAQV/I4CAgIAAQSBrIQQgBCSAgICAACAEIAA2AhwgBCADNgIYIARBHBCujICAADYCFCAEKAIUIQUgBCgCGCEGQQgaIAQgASkCADcDCCAEIAIpAgA3AwAgBUEIIARBCGogBCAGEM+AgIAAIAQoAhwQp4KAgAAhByAEKAIUIAc2AhggBCgCFCEIIARBIGokgICAgAAgCA8LzwEBB38jgICAgABBMGshBiAGJICAgIAAIAYgADYCLCAGIAE2AiggBiACNgIkIAYgBTYCICAGQSQQroyAgAA2AhwgBigCHCEHIAYoAiAhCEEJGiAGIAMpAgA3AxAgBiAEKQIANwMIIAdBCSAGQRBqIAZBCGogCBDPgICAACAGKAIsEKCCgIAAIQkgBigCHCAJNgIYIAYoAighCiAGKAIcIAo2AhwgBigCJBCggoCAACELIAYoAhwgCzYCICAGKAIcIQwgBkEwaiSAgICAACAMDwvPAQEHfyOAgICAAEEwayEGIAYkgICAgAAgBiAANgIsIAYgATYCKCAGIAI2AiQgBiAFNgIgIAZBJBCujICAADYCHCAGKAIcIQcgBigCICEIQQoaIAYgAykCADcDECAGIAQpAgA3AwggB0EKIAZBEGogBkEIaiAIEM+AgIAAIAYoAiwQoIKAgAAhCSAGKAIcIAk2AhggBigCKCEKIAYoAhwgCjYCHCAGKAIkEKCCgIAAIQsgBigCHCALNgIgIAYoAhwhDCAGQTBqJICAgIAAIAwPC88BAQd/I4CAgIAAQTBrIQYgBiSAgICAACAGIAA2AiwgBiABNgIoIAYgAjYCJCAGIAU2AiAgBkEkEK6MgIAANgIcIAYoAhwhByAGKAIgIQhBCxogBiADKQIANwMQIAYgBCkCADcDCCAHQQsgBkEQaiAGQQhqIAgQz4CAgAAgBigCLBCggoCAACEJIAYoAhwgCTYCGCAGKAIoIQogBigCHCAKNgIcIAYoAiQQoIKAgAAhCyAGKAIcIAs2AiAgBigCHCEMIAZBMGokgICAgAAgDA8LzwEBB38jgICAgABBMGshBiAGJICAgIAAIAYgADYCLCAGIAE2AiggBiACNgIkIAYgBTYCICAGQSQQroyAgAA2AhwgBigCHCEHIAYoAiAhCEEMGiAGIAMpAgA3AxAgBiAEKQIANwMIIAdBDCAGQRBqIAZBCGogCBDPgICAACAGKAIsEKCCgIAAIQkgBigCHCAJNgIYIAYoAighCiAGKAIcIAo2AhwgBigCJBCggoCAACELIAYoAhwgCzYCICAGKAIcIQwgBkEwaiSAgICAACAMDwuWAQEFfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgAzYCGCAEQRwQroyAgAA2AhQgBCgCFCEFIAQoAhghBkENGiAEIAEpAgA3AwggBCACKQIANwMAIAVBDSAEQQhqIAQgBhDPgICAACAEKAIcEKCCgIAAIQcgBCgCFCAHNgIYIAQoAhQhCCAEQSBqJICAgIAAIAgPC6ACAQp/I4CAgIAAQTBrIQkgCSSAgICAACAJIAA2AiwgCSABNgIoIAkgAjYCJCAJIAM2AiAgCSAEOgAfIAkgBToAHiAJIAg2AhggCUEsEK6MgIAANgIUIAkoAhQhCiAJKAIYIQtBDhogCSAGKQIANwMIIAkgBykCADcDACAKQQ4gCUEIaiAJIAsQz4CAgAAgCSgCLBCggoCAACEMIAkoAhQgDDYCGCAJKAIoEKCCgIAAIQ0gCSgCFCANNgIcIAkoAiQQoIKAgAAhDiAJKAIUIA42AiAgCSgCICEPIAkoAhQgDzYCJCAJLQAfIRAgCSgCFCAQQQFxOgAoIAktAB4hESAJKAIUIBFBAXE6ACkgCSgCFCESIAlBMGokgICAgAAgEg8L1QEBB38jgICAgABBMGshBiAGJICAgIAAIAYgADYCLCAGIAE2AiggBiACNgIkIAYgBTYCICAGQSQQroyAgAA2AhwgBigCHCEHIAYoAiAhCEEPGiAGIAMpAgA3AxAgBiAEKQIANwMIIAdBDyAGQRBqIAZBCGogCBDPgICAACAGKAIsEKCCgIAAIQkgBigCHCAJNgIYIAYoAigQoIKAgAAhCiAGKAIcIAo2AhwgBigCJBCggoCAACELIAYoAhwgCzYCICAGKAIcIQwgBkEwaiSAgICAACAMDwvtAQEIfyOAgICAAEEwayEHIAckgICAgAAgByAANgIsIAcgATYCKCAHIAI2AiQgByADNgIgIAcgBjYCHCAHQSgQroyAgAA2AhggBygCGCEIIAcoAhwhCUEQGiAHIAQpAgA3AxAgByAFKQIANwMIIAhBECAHQRBqIAdBCGogCRDPgICAACAHKAIsEKCCgIAAIQogBygCGCAKNgIYIAcoAigQoIKAgAAhCyAHKAIYIAs2AhwgBygCJBCggoCAACEMIAcoAhggDDYCICAHKAIgIQ0gBygCGCANNgIkIAcoAhghDiAHQTBqJICAgIAAIA4PC5oCAQp/I4CAgIAAQTBrIQkgCSSAgICAACAJIAA2AiwgCSABNgIoIAkgAjYCJCAJIAM2AiAgCSAENgIcIAkgBTYCGCAJIAg2AhQgCUEwEK6MgIAANgIQIAkoAhAhCiAJKAIUIQtBERogCSAGKQIANwMIIAkgBykCADcDACAKQREgCUEIaiAJIAsQz4CAgAAgCSgCLBCggoCAACEMIAkoAhAgDDYCGCAJKAIoEKCCgIAAIQ0gCSgCECANNgIcIAkoAiQQoIKAgAAhDiAJKAIQIA42AiAgCSgCICEPIAkoAhAgDzYCJCAJKAIcIRAgCSgCECAQNgIoIAkoAhghESAJKAIQIBE2AiwgCSgCECESIAlBMGokgICAgAAgEg8LggIBCX8jgICAgABBMGshCCAIJICAgIAAIAggADYCLCAIIAE2AiggCCACNgIkIAggAzYCICAIIAQ2AhwgCCAHNgIYIAhBLBCujICAADYCFCAIKAIUIQkgCCgCGCEKQRIaIAggBSkCADcDCCAIIAYpAgA3AwAgCUESIAhBCGogCCAKEM+AgIAAIAgoAiwQoIKAgAAhCyAIKAIUIAs2AhggCCgCKBCggoCAACEMIAgoAhQgDDYCHCAIKAIkEKCCgIAAIQ0gCCgCFCANNgIgIAgoAiAhDiAIKAIUIA42AiQgCCgCHCEPIAgoAhQgDzYCKCAIKAIUIRAgCEEwaiSAgICAACAQDwvtAQEIfyOAgICAAEEwayEHIAckgICAgAAgByAANgIsIAcgATYCKCAHIAI2AiQgByADNgIgIAcgBjYCHCAHQSgQroyAgAA2AhggBygCGCEIIAcoAhwhCUETGiAHIAQpAgA3AxAgByAFKQIANwMIIAhBEyAHQRBqIAdBCGogCRDPgICAACAHKAIsEKCCgIAAIQogBygCGCAKNgIYIAcoAigQoIKAgAAhCyAHKAIYIAs2AhwgBygCJBCggoCAACEMIAcoAhggDDYCICAHKAIgIQ0gBygCGCANNgIkIAcoAhghDiAHQTBqJICAgIAAIA4PC7cCAQt/I4CAgIAAQcAAayEKIAokgICAgAAgCiAANgI8IAogATYCOCAKIAI2AjQgCiADNgIwIAogBDYCLCAKIAU2AiggCiAGNgIkIAogCTYCICAKQTQQroyAgAA2AhwgCigCHCELIAooAiAhDEEUGiAKIAcpAgA3AxAgCiAIKQIANwMIIAtBFCAKQRBqIApBCGogDBDPgICAACAKKAI8EKCCgIAAIQ0gCigCHCANNgIYIAooAjgQoIKAgAAhDiAKKAIcIA42AhwgCigCNBCggoCAACEPIAooAhwgDzYCICAKKAIwIRAgCigCHCAQNgIkIAooAiwhESAKKAIcIBE2AiggCigCKCESIAooAhwgEjYCLCAKKAIkIRMgCigCHCATNgIwIAooAhwhFCAKQcAAaiSAgICAACAUDwu3AgELfyOAgICAAEHAAGshCiAKJICAgIAAIAogADYCPCAKIAE2AjggCiACNgI0IAogAzYCMCAKIAQ2AiwgCiAFNgIoIAogBjYCJCAKIAk2AiAgCkE0EK6MgIAANgIcIAooAhwhCyAKKAIgIQxBFRogCiAHKQIANwMQIAogCCkCADcDCCALQRUgCkEQaiAKQQhqIAwQz4CAgAAgCigCPBCggoCAACENIAooAhwgDTYCGCAKKAI4EKCCgIAAIQ4gCigCHCAONgIcIAooAjQQoIKAgAAhDyAKKAIcIA82AiAgCigCMCEQIAooAhwgEDYCJCAKKAIsIREgCigCHCARNgIoIAooAighEiAKKAIcIBI2AiwgCigCJCETIAooAhwgEzYCMCAKKAIcIRQgCkHAAGokgICAgAAgFA8LggIBCX8jgICAgABBMGshCCAIJICAgIAAIAggADYCLCAIIAE2AiggCCACNgIkIAggAzYCICAIIAQ2AhwgCCAHNgIYIAhBLBCujICAADYCFCAIKAIUIQkgCCgCGCEKQRYaIAggBSkCADcDCCAIIAYpAgA3AwAgCUEWIAhBCGogCCAKEM+AgIAAIAgoAiwQoIKAgAAhCyAIKAIUIAs2AhggCCgCKBCggoCAACEMIAgoAhQgDDYCHCAIKAIkEKCCgIAAIQ0gCCgCFCANNgIgIAgoAiAhDiAIKAIUIA42AiQgCCgCHCEPIAgoAhQgDzYCKCAIKAIUIRAgCEEwaiSAgICAACAQDwuCAgEJfyOAgICAAEEwayEIIAgkgICAgAAgCCAANgIsIAggATYCKCAIIAI2AiQgCCADNgIgIAggBDYCHCAIIAc2AhggCEEsEK6MgIAANgIUIAgoAhQhCSAIKAIYIQpBFxogCCAFKQIANwMIIAggBikCADcDACAJQRcgCEEIaiAIIAoQz4CAgAAgCCgCLBCggoCAACELIAgoAhQgCzYCGCAIKAIoEKCCgIAAIQwgCCgCFCAMNgIcIAgoAiQQoIKAgAAhDSAIKAIUIA02AiAgCCgCICEOIAgoAhQgDjYCJCAIKAIcIQ8gCCgCFCAPNgIoIAgoAhQhECAIQTBqJICAgIAAIBAPC4ICAQl/I4CAgIAAQTBrIQggCCSAgICAACAIIAA2AiwgCCABNgIoIAggAjYCJCAIIAM2AiAgCCAENgIcIAggBzYCGCAIQSwQroyAgAA2AhQgCCgCFCEJIAgoAhghCkEYGiAIIAUpAgA3AwggCCAGKQIANwMAIAlBGCAIQQhqIAggChDPgICAACAIKAIsEKCCgIAAIQsgCCgCFCALNgIYIAgoAigQoIKAgAAhDCAIKAIUIAw2AhwgCCgCJBCggoCAACENIAgoAhQgDTYCICAIKAIgIQ4gCCgCFCAONgIkIAgoAhwhDyAIKAIUIA82AiggCCgCFCEQIAhBMGokgICAgAAgEA8LggIBCX8jgICAgABBMGshCCAIJICAgIAAIAggADYCLCAIIAE2AiggCCACNgIkIAggAzYCICAIIAQ2AhwgCCAHNgIYIAhBLBCujICAADYCFCAIKAIUIQkgCCgCGCEKQRkaIAggBSkCADcDCCAIIAYpAgA3AwAgCUEZIAhBCGogCCAKEM+AgIAAIAgoAiwQoIKAgAAhCyAIKAIUIAs2AhggCCgCKBCggoCAACEMIAgoAhQgDDYCHCAIKAIkEKCCgIAAIQ0gCCgCFCANNgIgIAgoAiAhDiAIKAIUIA42AiQgCCgCHCEPIAgoAhQgDzYCKCAIKAIUIRAgCEEwaiSAgICAACAQDwvtAQEIfyOAgICAAEEwayEHIAckgICAgAAgByAANgIsIAcgATYCKCAHIAI2AiQgByADNgIgIAcgBjYCHCAHQSgQroyAgAA2AhggBygCGCEIIAcoAhwhCUEaGiAHIAQpAgA3AxAgByAFKQIANwMIIAhBGiAHQRBqIAdBCGogCRDPgICAACAHKAIsEKCCgIAAIQogBygCGCAKNgIYIAcoAigQoIKAgAAhCyAHKAIYIAs2AhwgBygCJBCggoCAACEMIAcoAhggDDYCICAHKAIgIQ0gBygCGCANNgIkIAcoAhghDiAHQTBqJICAgIAAIA4PC88CAQx/I4CAgIAAQcAAayELIAskgICAgAAgCyAANgI8IAsgATYCOCALIAI2AjQgCyADNgIwIAsgBDYCLCALIAU2AiggCyAGNgIkIAsgBzYCICALIAo2AhwgC0E4EK6MgIAANgIYIAsoAhghDCALKAIcIQ1BGxogCyAIKQIANwMQIAsgCSkCADcDCCAMQRsgC0EQaiALQQhqIA0Qz4CAgAAgCygCPBCggoCAACEOIAsoAhggDjYCGCALKAI4EKCCgIAAIQ8gCygCGCAPNgIcIAsoAjQQoIKAgAAhECALKAIYIBA2AiAgCygCMCERIAsoAhggETYCJCALKAIsIRIgCygCGCASNgIoIAsoAighEyALKAIYIBM2AiwgCygCJCEUIAsoAhggFDYCMCALKAIgIRUgCygCGCAVNgI0IAsoAhghFiALQcAAaiSAgICAACAWDwuaAgEKfyOAgICAAEEwayEJIAkkgICAgAAgCSAANgIsIAkgATYCKCAJIAI2AiQgCSADNgIgIAkgBDYCHCAJIAU2AhggCSAINgIUIAlBMBCujICAADYCECAJKAIQIQogCSgCFCELQRwaIAkgBikCADcDCCAJIAcpAgA3AwAgCkEcIAlBCGogCSALEM+AgIAAIAkoAiwQoIKAgAAhDCAJKAIQIAw2AhggCSgCKBCggoCAACENIAkoAhAgDTYCHCAJKAIkEKCCgIAAIQ4gCSgCECAONgIgIAkoAiAhDyAJKAIQIA82AiQgCSgCHCEQIAkoAhAgEDYCKCAJKAIYIREgCSgCECARNgIsIAkoAhAhEiAJQTBqJICAgIAAIBIPC9UBAQd/I4CAgIAAQTBrIQYgBiSAgICAACAGIAA2AiwgBiABNgIoIAYgAjYCJCAGIAU2AiAgBkEkEK6MgIAANgIcIAYoAhwhByAGKAIgIQhBHRogBiADKQIANwMQIAYgBCkCADcDCCAHQR0gBkEQaiAGQQhqIAgQz4CAgAAgBigCLBCggoCAACEJIAYoAhwgCTYCGCAGKAIoEKCCgIAAIQogBigCHCAKNgIcIAYoAiQQoIKAgAAhCyAGKAIcIAs2AiAgBigCHCEMIAZBMGokgICAgAAgDA8L7QEBCH8jgICAgABBMGshByAHJICAgIAAIAcgADYCLCAHIAE2AiggByACNgIkIAcgAzYCICAHIAY2AhwgB0EoEK6MgIAANgIYIAcoAhghCCAHKAIcIQlBHhogByAEKQIANwMQIAcgBSkCADcDCCAIQR4gB0EQaiAHQQhqIAkQz4CAgAAgBygCLBCggoCAACEKIAcoAhggCjYCGCAHKAIoEKCCgIAAIQsgBygCGCALNgIcIAcoAiQQoIKAgAAhDCAHKAIYIAw2AiAgBygCICENIAcoAhggDTYCJCAHKAIYIQ4gB0EwaiSAgICAACAODwu/BQECfyOAgICAAEEQayECIAIkgICAgAAgAiABNgIMIAIoAgwoAgAhAyADQR5LGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADDh8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHwsgAEHVh4aAABDGgoCAAAwfCyAAQcWMhoAAEMaCgIAADB4LIABBgY2GgAAQxoKAgAAMHQsgAEGYjYaAABDGgoCAAAwcCyAAQf2HhoAAEMaCgIAADBsLIABBwI2GgAAQxoKAgAAMGgsgAEHYjoaAABDGgoCAAAwZCyAAQfKNhoAAEMaCgIAADBgLIABBrYeGgAAQxoKAgAAMFwsgAEHnh4aAABDGgoCAAAwWCyAAQcKOhoAAEMaCgIAADBULIABB5IuGgAAQxoKAgAAMFAsgAEHAj4aAABDGgoCAAAwTCyAAQYiPhoAAEMaCgIAADBILIABBwIeGgAAQxoKAgAAMEQsgAEGcj4aAABDGgoCAAAwQCyAAQYqOhoAAEMaCgIAADA8LIABBsI2GgAAQxoKAgAAMDgsgAEHWjIaAABDGgoCAAAwNCyAAQaCMhoAAEMaCgIAADAwLIABBnI6GgAAQxoKAgAAMCwsgAEHpjIaAABDGgoCAAAwKCyAAQfWOhoAAEMaCgIAADAkLIABBsoyGgAAQxoKAgAAMCAsgAEGniIaAABDGgoCAAAwHCyAAQd6NhoAAEMaCgIAADAYLIABBro6GgAAQxoKAgAAMBQsgAEGNjIaAABDGgoCAAAwECyAAQZOIhoAAEMaCgIAADAMLIABBrY+GgAAQxoKAgAAMAgsgAEH9i4aAABDGgoCAAAwBCyAAQeDuhYAAEMaCgIAACyACQRBqJICAgIAADwvXAQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkACQCABKAIMQQBGQQFxRQ0ADAELAkAgASgCDCgCFEEAR0EBcUUNACABQQA2AggCQANAIAEoAgggASgCDCgCFBC3goCAAElBAXFFDQEgASABKAIMKAIUIAEoAggQsoKAgAA2AgQCQCABKAIEQQBHQQFxRQ0AIAEoAgQQqYGAgAALIAEgASgCCEEBajYCCAwACwsgASgCDEEUahC4goCAAAsgASgCDBCwjICAAAsgAUEQaiSAgICAAA8L4QQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAAkAgASgCDEEAR0EBcQ0ADAELIAEoAgwoAgAhAiACQR5LGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOHwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fCyABKAIMEPOAgIAADB4LIAEoAgwQ9ICAgAAMHQsgASgCDBD1gICAAAwcCyABKAIMEPaAgIAADBsLIAEoAgwQ94CAgAAMGgsgASgCDBD4gICAAAwZCyABKAIMEPmAgIAADBgLIAEoAgwQ+oCAgAAMFwsgASgCDBD7gICAAAwWCyABKAIMEPyAgIAADBULIAEoAgwQ/YCAgAAMFAsgASgCDBD+gICAAAwTCyABKAIMEP+AgIAADBILIAEoAgwQgIGAgAAMEQsgASgCDBCBgYCAAAwQCyABKAIMEIKBgIAADA8LIAEoAgwQg4GAgAAMDgsgASgCDBCEgYCAAAwNCyABKAIMEIWBgIAADAwLIAEoAgwQhoGAgAAMCwsgASgCDBCHgYCAAAwKCyABKAIMEIiBgIAADAkLIAEoAgwQiYGAgAAMCAsgASgCDBCKgYCAAAwHCyABKAIMEIuBgIAADAYLIAEoAgwQjIGAgAAMBQsgASgCDBCNgYCAAAwECyABKAIMEI6BgIAADAMLIAEoAgwQj4GAgAAMAgsgASgCDBCQgYCAAAwBCyABKAIMEJGBgIAACyABQRBqJICAgIAADwvBAQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCGEEAR0EBcUUNACABQQA2AggCQANAIAEoAgggASgCDCgCGBC3goCAAElBAXFFDQEgASABKAIMKAIYIAEoAggQsoKAgAA2AgQCQCABKAIEQQBHQQFxRQ0AIAEoAgQQ8oCAgAALIAEgASgCCEEBajYCCAwACwsgASgCDEEYahC4goCAAAsgASgCDBDxgICAACABQRBqJICAgIAADwtXAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIYQQBHQQFxRQ0AIAEoAgwoAhgQsIyAgAALIAEoAgwQ8YCAgAAgAUEQaiSAgICAAA8LpwIBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAhhBAEdBAXFFDQAgASgCDCgCGBCigoCAAAsCQCABKAIMKAIcQQBHQQFxRQ0AIAEoAgwoAhwQooKAgAALAkAgASgCDCgCIEEAR0EBcUUNACABKAIMKAIgEKKCgIAACwJAIAEoAgwoAiRBAEdBAXFFDQAgAUEANgIIAkADQCABKAIIIAEoAgwoAiQQt4KAgABJQQFxRQ0BIAEgASgCDCgCJCABKAIIELKCgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEEPKAgIAACyABIAEoAghBAWo2AggMAAsLIAEoAgxBJGoQuIKAgAALIAEoAgwQ8YCAgAAgAUEQaiSAgICAAA8LpwIBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAhhBAEdBAXFFDQAgASgCDCgCGBCigoCAAAsCQCABKAIMKAIcQQBHQQFxRQ0AIAEoAgwoAhwQooKAgAALAkAgASgCDCgCIEEAR0EBcUUNACABQQA2AggCQANAIAEoAgggASgCDCgCIBC3goCAAElBAXFFDQEgASABKAIMKAIgIAEoAggQsoKAgAA2AgQCQCABKAIEQQBHQQFxRQ0AIAEoAgQQ8oCAgAALIAEgASgCCEEBajYCCAwACwsgASgCDEEgahC4goCAAAsCQCABKAIMKAIkQQBHQQFxRQ0AIAEoAgwoAiQQooKAgAALIAEoAgwQ8YCAgAAgAUEQaiSAgICAAA8L/wEBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMKAIYEPKAgIAAAkAgASgCDCgCHEEAR0EBcUUNACABKAIMKAIcEKKCgIAACwJAIAEoAgwoAiBBAEdBAXFFDQAgAUEANgIIAkADQCABKAIIIAEoAgwoAiAQt4KAgABJQQFxRQ0BIAEgASgCDCgCICABKAIIELKCgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEEPKAgIAACyABIAEoAghBAWo2AggMAAsLIAEoAgxBIGoQuIKAgAALIAEoAgwoAiQQ8oCAgAAgASgCDBDxgICAACABQRBqJICAgIAADwuFAgEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCGEEAR0EBcUUNACABKAIMKAIYEKKCgIAACwJAIAEoAgwoAhxBAEdBAXFFDQAgAUEANgIIAkADQCABKAIIIAEoAgwoAhwQt4KAgABJQQFxRQ0BIAEgASgCDCgCHCABKAIIELKCgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEEPKAgIAACyABIAEoAghBAWo2AggMAAsLIAEoAgxBHGoQuIKAgAALAkAgASgCDCgCIEEAR0EBcUUNACABKAIMKAIgEKKCgIAACyABKAIMEPGAgIAAIAFBEGokgICAgAAPC8EBAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIYQQBHQQFxRQ0AIAFBADYCCAJAA0AgASgCCCABKAIMKAIYELeCgIAASUEBcUUNASABIAEoAgwoAhggASgCCBCygoCAADYCBAJAIAEoAgRBAEdBAXFFDQAgASgCBBDygICAAAsgASABKAIIQQFqNgIIDAALCyABKAIMQRhqELiCgIAACyABKAIMEPGAgIAAIAFBEGokgICAgAAPC3MBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMKAIYEPKAgIAAAkAgASgCDCgCHEEAR0EBcUUNACABKAIMKAIcEKKCgIAACyABKAIMKAIgEPKAgIAAIAEoAgwQ8YCAgAAgAUEQaiSAgICAAA8LVwEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCGEEAR0EBcUUNACABKAIMKAIYELCMgIAACyABKAIMEPGAgIAAIAFBEGokgICAgAAPC4UCAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIYQQBHQQFxRQ0AIAEoAgwoAhgQooKAgAALAkAgASgCDCgCHEEAR0EBcUUNACABQQA2AggCQANAIAEoAgggASgCDCgCHBC3goCAAElBAXFFDQEgASABKAIMKAIcIAEoAggQsoKAgAA2AgQCQCABKAIEQQBHQQFxRQ0AIAEoAgQQ8oCAgAALIAEgASgCCEEBajYCCAwACwsgASgCDEEcahC4goCAAAsCQCABKAIMKAIgQQBHQQFxRQ0AIAEoAgwoAiAQooKAgAALIAEoAgwQ8YCAgAAgAUEQaiSAgICAAA8LhQIBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAhhBAEdBAXFFDQAgASgCDCgCGBCigoCAAAsCQCABKAIMKAIcQQBHQQFxRQ0AIAFBADYCCAJAA0AgASgCCCABKAIMKAIcELeCgIAASUEBcUUNASABIAEoAgwoAhwgASgCCBCygoCAADYCBAJAIAEoAgRBAEdBAXFFDQAgASgCBBDygICAAAsgASABKAIIQQFqNgIIDAALCyABKAIMQRxqELiCgIAACwJAIAEoAgwoAiBBAEdBAXFFDQAgASgCDCgCIBCigoCAAAsgASgCDBDxgICAACABQRBqJICAgIAADwuFAgEB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ADYCHCAFIAE2AhggBSAENgIUIAUoAhQhBiAFKAIcIQcgBSgCGCEIIAUgAikCADcDCCAFIAMpAgA3AwAgBiAHIAggBUEIaiAFEJaBgIAAELGCgIAAIAVBIGokgICAgAAPC4IDAQt/I4CAgIAAQcABayEDIAMkgICAgAAgAyAANgK8ASADQRwQroyAgAA2ArgBIAMoArgBIQRBAhogAyABKQIANwMYIAMgAikCADcDECAEQQIgA0EYaiADQRBqEJOBgIAAIANBpqeGgAA2ArQBIANB6wE2ArABIAMgAygCsAEQroyAgAA2AqwBAkACQCADKAKsAUEAR0EBcUUNACADQSBqIAMoArwBKAIAQYABEIWMgIAAGiADQQA6AKABIAMoAqwBIQUgAygCsAEhBiADKAK0ASEHIANBIGohCCADKAK8ASgCDCEJIAMgAygCvAEoAhA2AgggAyAJNgIEIAMgCDYCACAFIAYgByADEPqLgIAAGiADKAKsARCngoCAACEKIAMoArgBIAo2AhQgAygCrAEQsIyAgAAMAQtBpqeGgAAQp4KAgAAhCyADKAK4ASALNgIUCyADKAK8ARCggoCAACEMIAMoArgBIAw2AhggAygCuAEhDSADQcABaiSAgICAACANDwttAQN/I4CAgIAAQSBrIQQgBCSAgICAACAEIAA2AhwgBCADNgIYIAQoAhghBSAEKAIcIQYgBCABKQIANwMQIAQgAikCADcDCCAFIAYgBEEQaiAEQQhqEJiBgIAAELGCgIAAIARBIGokgICAgAAPC7IDAQx/I4CAgIAAQdACayEDIAMkgICAgAAgAyAANgLMAiADQRwQroyAgAA2AsgCIAMoAsgCIQRBAxogAyABKQIANwMYIAMgAikCADcDECAEQQMgA0EYaiADQRBqEJOBgIAAIANB/aeGgAA2AsQCIANB8QI2AsACIAMgAygCwAIQroyAgAA2ArwCAkACQCADKAK8AkEAR0EBcUUNACADQbABaiADKALMAigCAEGAARCFjICAABogA0EAOgCwAiADQSBqIAMoAswCKAIAQYABEIWMgIAAGiADQQA6AKABIAMoArwCIQUgAygCwAIhBiADKALEAiEHIANBsAFqIQggAygCzAIoAgwhCSADKALMAigCECEKIAMgA0EgajYCDCADIAo2AgggAyAJNgIEIAMgCDYC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GCADIAIpAgA3AxAgBEEJIANBGGogA0EQahCTgYCAACADQYirhoAANgK0ASADQY4CNgKwASADIAMoArABEK6MgIAANgKsAQJAAkAgAygCrAFBAEdBAXFFDQAgA0EgaiADKAK8AUGAARCFjICAABogA0EAOgCgASADKAKsASEFIAMoArABIQYgAygCtAEhByADIANBIGo2AgAgBSAGIAcgAxD6i4CAABogAygCrAEQp4KAgAAhCCADKAK4ASAINgIUIAMoAqwBELCMgIAADAELQYirhoAAEKeCgIAAIQkgAygCuAEgCTYCFAsgAygCvAEQp4KAgAAhCiADKAK4ASAKNgIYIAMoArgBIQsgA0HAAWokgICAgAAgCw8LbQEDfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgAzYCGCAEKAIYIQUgBCgCHCEGIAQgASkCADcDECAEIAIpAgA3AwggBSAGIARBEGogBEEIahCjgYCAABCxgoCAACAEQSBqJICAgIAADwvbAgEJfyOAgICAAEHAAWshAyADJICAgIAAIAMgADYCvAEgA0EcEK6MgIAANgK4ASADKAK4ASEEQQoaIAMgASkCADcDGCADIAIpAgA3AxAgBEEKIANBGGogA0EQahCTgYCAACADQcumhoAANgK0ASADQdsBNgKwASADIAMoArABEK6MgIAANgKsAQJAAkAgAygCrAFBAEdBAXFFDQAgA0EgaiADKAK8AUGAARCFjICAABogA0EAOgCgASADKAKsASEFIAMoArABIQYgAygCtAEhByADIANBIGo2AgAgBSAGIAcgAxD6i4CAABogAygCrAEQp4KAgAAhCCADKAK4ASAINgIUIAMoAqwBELCMgIAADAELQcumhoAAEKeCgIAAIQkgAygCuAEgCTYCFAsgAygCvAEQp4KAgAAhCiADKAK4ASAKNgIYIAMoArgBIQsgA0HAAWokgICAgAAgCw8LbQEDfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgAzYCGCAEKAIYIQUgBCgCHCEGIAQgASkCADcDECAEIAIpAgA3AwggBSAGIARBEGogBEEIahClgYCAABCxgoCAACAEQSBqJICAgIAADwv9AQECfyOAgICAAEEQayEBIAEgADYCCCABKAIIKAIAIQIgAkEKSxoCQAJAAkACQAJA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FA5ACw4REQ0KDhERERERAxEBEREREREREREREQcJAAwFAggREREREREREREREREREREREREREREREREREREQBBEGDxELIAEoAogBQQEQwYGAgAAhFUEYIRYCQCAVIBZ0IBZ1QSVGQQFxRQ0AIAEgASgCiAEQ3YGAgAA2AowBDBILAkAgASgCiAFBABDDgYCAAEEBcUUNACABIAEoAogBQQlBBBDYgYCAADYCjAEMEgsCQCABKAKIAUEAEMSBgIAAQQFxRQ0AIAEoAogBIRdBBSEYIAEgFyAYIBgQ2IGAgAA2AowBDBILAkAgASgCiAFBABDFgYCAAEEBcUUNACABIAEoAogBQQlBBxDYgYCAADYCjAEMEgsgASgCiAFBARDBgYCAACEZQRghGgJAIBkgGnQgGnUQ44uAgABFDQAgASABKAKIAUEJENmBgIAANgKMAQwSCwJAIAEoAogBQQAQxoGAgABBAXFFDQAgASgCiAEhGyABQfgAakGerIaAABDGgoCAACABIAEpAng3AxBBDSEcIAEgGyABQRBqIBwQ3oGAgAA2AowBDBILAkAgASgCiAFBABDOgYCAAEEBcUUNACABKAKIASEdIAFB8ABqQcWmhoAAEMaCgIAAIAEgASkCcDcDGEEKIR4gASAdIAFBGGogHhDegYCAADYCjAEMEgsgASABKAKIAUESENmBgIAANgKMAQwRCyABKAKIASEfIAFB5ABqQY+ahoAAEMaCgIAAIAEgASkCZDcDIEEMISAgASAfIAFBIGogIBDfgYCAADYCbAJAAkAgASgCbEEAR0EBcUUNACABKAJsISEMAQsgASgCiAFBExDZgYCAACEhCyABICE2AowBDBALIAEoAogBISIgAUHYAGpBhZqGgAAQxoKAgAAgASABKQJYNwMoQQYhIyABICIgAUEoaiAjEN+BgIAANgJgAkACQCABKAJgQQBHQQFxRQ0AIAEoAmAhJAwBCyABKAKIAUEgENmBgIAAISQLIAEgJDYCjAEMDwsgASgCiAEhJSABQcwAakGSmoaAABDGgoCAACABIAEpAkw3AzBBDiEmIAEgJSABQTBqICYQ34GAgAA2AlQCQAJAIAEoAlRBAEdBAXFFDQAgASgCVCEnDAELIAEoAogBQRgQ2YGAgAAhJwsgASAnNgKMAQwOCyABKAKIASEoIAFBwABqQYGahoAAEMaCgIAAIAEgASkCQDcDOEEIISkgASAoIAFBOGogKRDfgYCAADYCSAJAAkAgASgCSEEAR0EBcUUNACABKAJIISoMAQsgASgCiAFBIBDZgYCAACEqCyABICo2AowBDA0LIAEgASgCiAFBCxDZgYCAADYCjAEMDAsgASABKAKIAUEZENmBgIAANgKMAQwLCyABIAEoAogBQRwQ2YGAgAA2AowBDAoLIAEgASgCiAFBHRDZgYCAADYCjAEMCQsgASABKAKIAUEbENmBgIAANgKMAQwICyABIAEoAogBQR8Q2YGAgAA2AowBDAcLIAEgASgCiAFBGhDZgYCAADYCjAEMBgsgASABKAKIAUEUENmBgIAANgKMAQwFCyABIAEoAogBQR4Q2YGAgAA2AowBDAQLIAEgASgCiAFBFRDZgYCAADYCjAEMAwsgASABKAKIAUEWENmBgIAANgKMAQwCCyABIAEoAogBQRcQ2YGAgAA2AowBDAELIAEoAogBLQAgIStBGCEsAkAgKyAsdCAsdRDji4CAAEUNACABIAEoAogBEOCBgIAANgKMAQwBCyABIAEoAogBQSAQ3IGAgAA2AowBCyABKAKMASEtIAFBkAFqJICAgIAAIC0PC0oBBX8jgICAgABBEGshASABIAA2AgwgASgCDC0AICECQRghAyACIAN0IAN1IQRBASEFAkAgBEUNACABKAIMLQAwIQULIAVBAXEPC5EBAQN/I4CAgIAAQRBrIQEgASAANgIMAkACQCABKAIMKAIsIAEoAgwoAhBGQQFxRQ0AIAEoAgwhAiACIAIoAihBAWo2AigCQCABKAIMKAIoQQVLQQFxRQ0AIAEoAgxBAToAMAsMAQsgASgCDEEANgIoIAEoAgwoAhAhAyABKAIMIAM2AiwLIAEoAgwtADBBAXEPC+4DARJ/I4CAgIAAQdAAayEBIAEkgICAgAAgASAANgJIIAEgASgCSCgCEDYCRAJAAkADQCABKAJIQQAQzIGAgABBf3NBAXFFDQECQCABKAJIENSBgIAAQQFxRQ0AIAEoAkghAiABKAJEIQMgASgCSCgCECEEIAFBOGoaIAEgAikCADcDCCABQThqIAFBCGogAyAEEM2CgIAAIAEoAkghBSABIAEpAjg3AxBBISEGIAEgAUEQaiAGIAUQnoKAgAA2AkAgASABKAJANgJMDAMLIAEoAkgtACAhB0EYIQgCQAJAIAcgCHQgCHUQpoKAgABFDQAgASgCSCEJIAkgCSgCCEEBajYCCCABKAJIQQA2AgwMAQsgASgCSCEKIAogCigCDEEBajYCDAsgASgCSCELIAsgCygCEEEBajYCECABKAJIKAIAIAEoAkgoAhBqLQAAIQwgASgCSCAMOgAgDAALCyABKAJIQQI2AiQgASgCSCENIAEoAkQhDiABKAJIKAIQIQ8gAUEsahogASANKQIANwMYIAFBLGogAUEYaiAOIA8QzYKAgAAgASgCSCEQIAEgASkCLDcDIEEQIREgASABQSBqIBEgEBCegoCAADYCNCABIAEoAjQ2AkwLIAEoAkwhEiABQdAAaiSAgICAACASDwvzAgEKfyOAgICAAEHQAGshASABJICAgIAAIAEgADYCSCABKAJIQQA2AiQCQAJAIAEoAkhBABDKgYCAAEEBcUUNACABKAJIIQIgAUHAAGpBnpqGgAAQxoKAgAAgASABKQJANwMIQREhAyABIAIgAUEIaiADEN6BgIAANgJMDAELAkAgASgCSEEAEMuBgIAAQQFxRQ0AIAEoAkghBCABQThqQZaahoAAEMaCgIAAIAEgASkCODcDEEERIQUgASAEIAFBEGogBRDegYCAADYCTAwBCwJAIAEoAkhBABDJgYCAAEEBcUUNACABKAJIIQYgAUEwakGamoaAABDGgoCAACABIAEpAjA3AxhBESEHIAEgBiABQRhqIAcQ3oGAgAA2AkwMAQsgASgCSCEIIAFBKGpBn5qGgAAQxoKAgAAgASABKQIoNwMgQREhCSABIAggAUEgaiAJEN6BgIAANgJMCyABKAJMIQogAUHQAGokgICAgAAgCg8L6wEBB38jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkIAMgAygCLCgCEDYCICADQQA2AhwCQANAIAMoAhwgAygCKElBAXFFDQEgAygCLBDhgYCAACADIAMoAhxBAWo2AhwMAAsLIAMoAiwhBCADKAIgIQUgAygCLCgCECEGIANBEGoaIAMgBCkCADcDACADQRBqIAMgBSAGEM2CgIAAIAMoAiQhByADKAIsIQggAyADKQIQNwMIIAMgA0EIaiAHIAgQnoKAgAA2AhggAygCGCEJIANBMGokgICAgAAgCQ8LgQEBBX8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAiACKAIcLQAgOgAWIAJBADoAFyACKAIcIQMgAkEWaiEEIAJBDGogBBDGgoCAACACKAIYIQUgAiACKQIMNwMAIAMgAiAFEN6BgIAAIQYgAkEgaiSAgICAACAGDwtJAQV/I4CAgIAAQRBrIQEgASAANgIMIAEoAgxBIEYhAkEBIQMgAkEBcSEEIAMhBQJAIAQNACABKAIMQQlrQQVJIQULIAVBAXEPC9gCARV/I4CAgIAAQTBrIQEgASSAgICAACABIAA2AiwgASABKAIsKAIQNgIoA0AgASgCLC0AICECQRghAyACIAN0IAN1ENqBgIAAIQRBACEFAkAgBEUNACABKAIsLQAgIQZBGCEHIAYgB3QgB3VBCkchCEEAIQkgCEEBcSEKIAkhBSAKRQ0AIAEoAiwtACAhC0EYIQwgCyAMdCAMdUENRyENQQAhDiANQQFxIQ8gDiEFIA9FDQAgASgCLBDUgYCAAEF/cyEFCwJAIAVBAXFFDQAgASgCLBDhgYCAAAwBCwsgASgCLCEQIAEoAighESABKAIsKAIQIRIgAUEcahogASAQKQIANwMIIAFBHGogAUEIaiARIBIQzYKAgAAgASgCLCETIAEgASkCHDcDEEEAIRQgASABQRBqIBQgExCegoCAADYCJCABKAIkIRUgAUEwaiSAgICAACAVDwv9AgEHfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCOCACIAE2AjQgAiACKAI4KAIAIAIoAjgoAhAgAigCOCgCBBClgoCAADYCMAJAAkAgAigCMEEBTEEBcUUNACACIAIoAjggAigCNBDZgYCAADYCPAwBCyACIAIoAjgoAhA2AiwgAkEANgIoAkADQCACKAIoIAIoAjBIQQFxRQ0BAkAgAigCOCgCECACKAIoaiACKAI4KAIET0EBcUUNACACIAIoAjggAigCNBDZgYCAADYCPAwDCyACIAIoAihBAWo2AigMAAsLIAIoAjggAigCMBDigYCAACACKAI4IQMgAigCLCEEIAIoAjgoAhAhBSACQRxqGiACIAMpAgA3AwggAkEcaiACQQhqIAQgBRDNgoCAACACKAI0IQYgAigCOCEHIAIgAikCHDcDECACIAJBEGogBiAHEJ6CgIAA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QQhqIQcgBSAFKAIgNgIMIAUgBSgCHDYCECAHIAUpAgw3AgAPC1QBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAiACKAIIEKCCgIAANgIEIAIoAgwoAgggAigCBBC1goCAACACQRBqJICAgIAADwveAQEDfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIoAkACQCACKAIoKAIIELeCgIAADQAgAkEAQQFxOgAvDAELIAIgAigCKCgCCBC0goCAADYCJAJAAkAgAigCJEEARkEBcQ0AIAIoAiQoAgBBAEZBAXFFDQELIAJBAEEBcToALwwBCyACKAIkKAIAIQMgAkEcaiADEMaCgIAAIAIgAikCHDcDECACIAEpAgA3AwggAiACQRBqIAJBCGoQyIKAgABBAXE6AC8LIAItAC9BAXEhBCACQTBqJICAgIAAIAQPC2UBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCCAJAAkAgASgCCCgCCBC3goCAAA0AIAFBADYCDAwBCyABIAEoAggoAggQtoKAgAA2AgwLIAEoAgwhAiABQRBqJICAgIAAIAIPC9ACAQN/I4CAgIAAQcAAayEBIAEkgICAgAAgASAANgI4AkACQAJAIAEoAjhBAEdBAXFFDQAgASgCOCgCCEEAR0EBcQ0BCyABQQBBAXE6AD8MAQsgASABKAI4KAIIELeCgIAANgI0IAFBADYCMAJAA0AgASgCMCABKAI0SUEBcUUNASABIAEoAjgoAgggASgCMBCygoCAADYCLAJAIAEoAixBAEdBAXFFDQAgASgCLCgCAEEAR0EBcUUNACABKAIsKAIAIQIgAUEkaiACEMaCgIAAIAFBHGpB2YiFgAAQxoKAgAAgASABKQIkNwMQIAEgASkCHDcDCAJAIAFBEGogAUEIahDIgoCAAEEBcUUNACABQQFBAXE6AD8MBAsLIAEgASgCMEEBajYCMAwACwsgAUEAQQFxOgA/CyABLQA/QQFxIQMgAUHAAGokgICAgAAgAw8L6gEBAn8jgICAgABBwABrIQEgASSAgICAACABIAApAgA3AyACQAJAIAFBIGoQy4KAgABBAXFFDQAgAUEANgI8DAELIAFBNGpB4ZCEgAAQxoKAgAAgASAAKQIANwMYIAEgASkCNDcDEAJAIAFBGGogAUEQahDIgoCAAEEBcUUNACABQQE2AjwMAQsgAUEsakHis4WAABDGgoCAACABIAApAgA3AwggASABKQIsNwMAAkAgAUEIaiABEMiCgIAAQQFxRQ0AIAFBAjYCPAwBCyABQQA2AjwLIAEoAjwhAiABQcAAaiSAgICAACACDwtCAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAApAgA3AwggAUEIahDqgYCAAEEAR0EBcSECIAFBEGokgICAgAAgAg8LewECfyOAgICAAEEQayECIAIkgICAgAAgAiABNgIMIAIoAgxBf2ohAyADQQFLGgJAAkACQAJAIAMOAgABAgsgAEHhkISAABDGgoCAAAwCCyAAQeKzhYAAEMaCgIAADAELIABBh8KGgAAQxoKAgAALIAJBEGokgICAgAAPC08BAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIAkACQCACKAIMQQBGQQFxRQ0ADAELIAIoAgxBATYCDCACKAIIIQMgAigCDCADNgIQCw8LQQEBfyOAgICAAEEQayEBIAEgADYCDAJAAkAgASgCDEEARkEBcUUNAAwBCyABKAIMQQA2AgwgASgCDEEANgIQCw8LwgEBB38jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCICAEIAQoAiwQ8IGAgAA2AhwgBCgCKCEFIAQoAiQhBiAEKAIcKAIcEJ+CgIAAIQcgBCgCHEEMaiEIIAQoAhxBDGpBCGohCSAEKAIgIQogBCAIKQIANwMQIAQgCSkCADcDCCAFIAYgByAEQRBqIARBCGogChCVgYCAACAEKAIcEKKCgIAAIARBMGokgICAgAAPC1oBA38jgICAgABBEGshASABJICAgIAAIAEgADYCDCABIAEoAgwoAgQ2AgggASgCDCgCABDTgYCAACECIAEoAgwgAjYCBCABKAIIIQMgAUEQaiSAgICAACADDwvBAQEEfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgATYCGCAEIAI2AhQCQAJAIAQoAhgQu4KAgAANAAwBCyAEKAIYELqCgIAAIQUgBCgCHCgCBEEMaiEGIAQgAykCADcDCCAEIAYpAgA3AwBBACEHIAQgBSAEQQhqIAQgBxDSgICAADYCEAJAIAQoAhRBAEdBAXFFDQAg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AygCWCADKAJcEIWCgIAAELGCgIAADAELAkAgAygCXEEJEJuCgIAAQQFxRQ0AIAMoAlggAygCXBCGgoCAABCxgoCAAAwBCwJAIAMoAlxBChCbgoCAAEEBcUUNACADKAJYIAMoAlwQh4KAgAAQsYKAgAAMAQsgAygCXCgCBCgCHCEEIANBxABqQf/B1y82AgAgA0HAAGpBADYCACADQTxqQRk2AgAgA0E4akETNgIAIANBNGpBGzYCACADQTBqQRU2AgAgA0EsakEeNgIAIANBKGpBAjYCACADQSRqQQE2AgBBICEFIAMgBWpBAzYCAEEcIQYgAyAGakEaNgIAQRghByADIAdqIQhBFCEJIAggCTYCACADIAlqIAc2AgAgA0EQaiAGNgIAIAMgBTYCDCADQRY2AgggA0EXNgIEIANBHTYCAAJAIARBHyADEJ2CgIAAQQFxRQ0AIAMoAlggAygCXCADKAJUEIiCgIAAELGCgIAADAELIAMoAlwhCiADKAJUIQsgCkGE8ISAAEHyhIaAACALEO+BgIAADAALCyADQeAAaiSAgICAAA8LgQEBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAAkAgASgCDEEARkEBcUUNAAwBCwJAIAEoAgwoAgRBAEdBAXFFDQAgASgCDCgCBBCigoCAAAsgASgCDCgCCEEAR0EBcUUNACABKAIMQQhqELiCgIAACyABQRBqJICAgIAADwvBAgEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGAJAAkACQCACKAIcQQBGQQFxDQAgAigCHBC3goCAAA0BCwwBCyACIAIoAhwgAigCGBD+gYCAADYCFCACKAIcQQA2AgQgAkEANgIQAkADQCACKAIQIAIoAhQoAgRJQQFxRQ0BIAIoAhwgAigCFCACKAIQELKCgIAAELGCgIAAIAIgAigCEEEBajYCEAwACwsgAkEUahC4goCAACACQQA2AgwDQCACKAIMIAIoAhwoAgRJQQFxRQ0BIAIgAigCHCACKAIMELKCgIAANgIIAkACQCACKAIIQQBGQQFxRQ0ADAELIAIoAgghAyACKAIYIQQgA0GPgICAACAEEKiCgIAACyACIAIoAgxBAWo2AgwMAAsLIAJBIGokgICAgAAPC+IHARZ/I4CAgIAAQZABayECIAIkgICAgAAgAiAANgKMASACIAE2AogBIAIgAigCjAEQt4KAgAAQsIKAgAA2AoQBIAJBADYCgAECQANAIAIoAoABIAIoAowBELeCgIAASUEBcUUNASACIAIoAowBIAIoAoABELKCgIAANgJ8AkACQCACKAJ8QQBGQQFxRQ0ADAELAkACQCACKAJ8KAIAQQJGQQFxRQ0AIAIgAigCfDYCeCACKAJ4KAIcKAIAIQMgAkHwAGogAxDGgoCAACACKAKMASEEIAIoAoABIQUgAiACKQJwNwMoIAIgBCAFIAJBKGoQ/4GAgAA2AmwCQAJAIAIoAmxBf0ZBAXFFDQACQCACKAJ4KAIUELeCgIAADQAgAigCeCgCHCEGIAIoAnhBBGohByACKAJ4QQRqQQhqIQggAigCeCgCFCEJIAIgBykCADcDECACIAgpAgA3AwggBiACQRBqIAJBCGogCRCbgYCAAAsgAigChAEgAigCfBCxgoCAAAwBCyACIAIoAowBIAIoAmwQsoKAgAA2AmggAiACKAJsIAIoAoABa0EBaxCwgoCAADYCZCACIAIoAoABQQFqNgJgAkADQCACKAJgIAIoAmxJQQFxRQ0BIAIoAmQgAigCjAEgAigCYBCygoCAABCxgoCAACACIAIoAmBBAWo2AmAMAAsLIAIgAigCZCACKAKIARD+gYCAADYCXCACQeQAahC4goCAACACQQgQsIKAgAA2AlggAigCeCEKIAIoAngoAhwhCyACKAJcIQwgAigCaCENIAIoAnhBBGohDiACKAJoQQRqQQhqIQ8gAigCWCEQQQAaQQAaIAIgDikCADcDICACIA8pAgA3AxhBACERIAIgCiALIAwgDSARIBEgAkEgaiACQRhqIBAQ1YCAgAA2AlQgAigChAEgAigCVBCxgoCAACACIAIoAmw2AoABCwwBCwJAAkAgAigCfCgCAEEDRkEBcUUNACACIAIoAnw2AlAgAigCUCgCHCgCACESIAJByABqIBIQxoKAgAAgAiACKQJINwNAAkAgAkHAAGoQvoGAgABBAXENAAJAIAIoAlAoAhQQt4KAgAANACACKAJQKAIcIRMgAigCUEEEaiEUIAIoAlBBBGpBCGohFSACKAJQKAIUIRYgAiAUKQIANwM4IAIgFSkCADcDMCATIAJBOGogAkEwaiAWEJmBgIAACwsgAigChAEgAigCfBCxgoCAAAwBCyACKAKEASACKAJ8ELGCgIAACwsLIAIgAigCgAFBAWo2AoABDAALCyACKAKEASEXIAJBkAFqJICAgIAAIBcPC60DAQR/I4CAgIAAQdAAayEDIAMkgICAgAAgAyAANgJIIAMgATYCRCADQQA2AkAgAyADKAJEQQFqNgI8AkACQANAIAMoAjwgAygCSBC3goCAAElBAXFFDQEgAyADKAJIIAMoAjwQsoKAgAA2AjgCQAJAIAMoAjhBAEZBAXFFDQAMAQsCQAJAIAMoAjgoAgBBAkZBAXFFDQAgAyADKAI4NgI0IAMoAjQoAhwoAgAhBCADQSxqIAQQxoKAgAAgAyADKQIsNwMIIAMgAikCADcDAAJAIANBCGogAxDIgoCAAEEBcUUNACADIAMoAkBBAWo2AkALDAELAkAgAygCOCgCAEEDRkEBcUUNACADIAMoAjg2AiggAygCKCgCHCgCACEFIANBIGogBRDGgoCAACADIAMpAiA3AxggAyACKQIANwMQAkAgA0EYaiADQRBqEMiCgIAAQQFxRQ0AAkAgAygCQA0AIAMgAygCPDYCTAwHCyADIAMoAkBBf2o2AkALCwsLIAMgAygCPEEBajYCPAwACwsgA0F/NgJMCyADKAJMIQYgA0HQAGokgICAgAAgBg8LVgEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkACQCABKAIMQQBGQQFxRQ0ADAELIAEoAgwoAhggASgCDCgCFBD9gYCAAAsgAUEQaiSAgICAAA8LsgIBD38jgICAgABBMGshASABJICAgIAAIAEgADYCLCABQQgQsIKAgAA2AiggASgCLCECIAEoAighAyABIAJBDyADEPOBgIAANgIkIAEoAiwhBCABKAIoIQUgASAEQRAgBRDzgYCAADYCICABKAIsIQYgASgCKCEHIAEgBkERIAcQ84GAgAA2AhwgASgCJCEIIAEoAiAhCSABKAIcIQogASgCJEEMaiELIAEoAhxBDGpBCGohDCABKAIoIQ1BABpBABogASALKQIANwMQIAEgDCkCADcDCEEAIQ4gASAIIAkgCiAOIA4gDiABQRBqIAFBCGogDRDfgICAADYCGCABKAIkEKKCgIAAIAEoAiAQooKAgAAgASgCHBCigoCAACABKAIYIQ8gAUEwaiSAgICAACAPDwvTBAESfyOAgICAAEHgAGshASABJICAgIAAIAEgADYCXCABQQgQsIKAgAA2AlggAUEIELCCgIAANgJUIAFBxABqQcAAELmCgIAAGiABKAJcIQIgASgCWCEDIAEgAkEEIAMQ84GAgAA2AkAgASABKAJcKAIEQQxqKQIANwM4AkADQCABKAJcKAIEKAIcIQQgAUH/wdcvNgIkIAFBIjYCICAEQQsgAUEgahCdgoCAAEF/c0EBcUUNAQJAIAEoAlxBDxCbgoCAAEEBcUUNACABKAJcIQUgASgCVCEGIAFBxABqGiABIAEpAzg3AwAgBSABQcQAaiAGIAEQ8YGAgAAgASABKAJcEIGCgIAANgI0IAEoAlQgASgCNBCxgoCAAAwBCyABIAEoAlwgASgCXCgCBCgCHCABKAJYEPOBgIAANgIwIAEoAjAoAgAhByABQcQAaiAHELyCgIAAIAEoAjAQooKAgAAMAAsLIAEoAlwhCCABKAJUIQkgAUHEAGoaIAEgASkDODcDCCAIIAFBxABqIAkgAUEIahDxgYCAACABKAJcIQogASgCWCELIAEgCkELIAsQ84GAgAA2AiwgASgCQCEMIAEoAlQhDSABKAIsIQ4gASgCQEEMaiEPIAEoAixBDGpBCGohECABKAJYIREgASAPKQIANwMYIAEgECkCADcDECABIAwgDSAOIAFBGGogAUEQaiARENuAgIAANgIoIAEoAkAQooKAgAAgASgCLBCigoCAACABKAJIELCMgIAAIAEoAighEiABQeAAaiSAgICAACASDwvWBAESfyOAgICAAEHgAGshASABJICAgIAAIAEgADYCXCABQQgQsIKAgAA2AlggAUEIELCCgIAANgJUIAFBxABqQcAAELmCgIAAGiABKAJcIQIgASgCWCEDIAEgAkEFIAMQ84GAgAA2AkAgASABKAJcKAIEQQxqKQIANwM4AkADQCABKAJcKAIEKAIcIQQgAUH/wdcvNgIkIAFBIjYCICAEQQYgAUEgahCdgoCAAEF/c0EBcUUNAQJAIAEoAlxBDxCbgoCAAEEBcUUNACABKAJcIQUgASgCVCEGIAFBxABqGiABIAEpAzg3AwAgBSABQcQAaiAGIAEQ8YGAgAAgASABKAJcEIGCgIAANgI0IAEoAlQgASgCNBCxgoCAACABIAEoAlwoAgRBDGopAgA3AzgMAQsgASABKAJcEPCBgIAANgIwIAEoAjAoAgAhByABQcQAaiAHELyCgIAAIAEoAjAQooKAgAAMAAsLIAEoAlwhCCABKAJUIQkgAUHEAGoaIAEgASkDODcDCCAIIAFBxABqIAkgAUEIahDxgYCAACABKAJcIQogASgCWCELIAEgCkEGIAsQ84GAgAA2AiwgASgCQCEMIAEoAlQhDSABKAIsIQ4gASgCQEEMaiEPIAEoAixBDGpBCGohECABKAJYIREgASAPKQIANwMYIAEgECkCADcDECABIAwgDSAOIAFBGGogAUEQaiARENyAgIAANgIoIAEoAkAQooKAgAAgASgCLBCigoCAACABKAJIELCMgIAAIAEoAighEiABQeAAaiSAgICAACASDwvWBAESfyOAgICAAEHgAGshASABJICAgIAAIAEgADYCXCABQQgQsIKAgAA2AlggAUEIELCCgIAANgJUIAFBxABqQYABELmCgIAAGiABKAJcIQIgASgCWCEDIAEgAkEHIAMQ84GAgAA2AkAgASABKAJcKAIEQQxqKQIANwM4AkADQCABKAJcKAIEKAIcIQQgAUH/wdcvNgIkIAFBIjYCICAEQQggAUEgahCdgoCAAEF/c0EBcUUNAQJAIAEoAlxBDxCbgoCAAEEBcUUNACABKAJcIQUgASgCVCEGIAFBxABqGiABIAEpAzg3AwAgBSABQcQAaiAGIAEQ8YGAgAAgASABKAJcEIGCgIAANgI0IAEoAlQgASgCNBCxgoCAACABIAEoAlwoAgRBDGopAgA3AzgMAQsgASABKAJcEPCBgIAANgIwIAEoAjAoAgAhByABQcQAaiAHELyCgIAAIAEoAjAQooKAgAAMAAsLIAEoAlwhCCABKAJUIQkgAUHEAGoaIAEgASkDODcDCCAIIAFBxABqIAkgAUEIahDxgYCAACABKAJcIQogASgCWCELIAEgCkEIIAsQ84GAgAA2AiwgASgCQCEMIAEoAlQhDSABKAIsIQ4gASgCQEEMaiEPIAEoAixBDGpBCGohECABKAJYIREgASAPKQIANwMYIAEgECkCADcDECABIAwgDSAOIAFBGGogAUEQaiAREN2AgIAANgIoIAEoAkgQsIyAgAAgASgCQBCigoCAACABKAIsEKKCgIAAIAEoAighEiABQeAAaiSAgICAACASDwvQBAESfyOAgICAAEHgAGshASABJICAgIAAIAEgADYCXCABQQgQsIKAgAA2AlggAUEIELCCgIAANgJUIAEoAlwhAiABKAJYIQMgASACQQ0gAxDzgYCAADYCUCABIAEoAlwoAgRBDGopAgA3A0ggAUE4akGABBC5goCAABoCQANAIAEoAlwoAgQoAhwhBCABQf/B1y82AiQgAUEiNgIgIARBDiABQSBqEJ2CgIAAQX9zQQFxRQ0BAkAgASgCXEEPEJuCgIAAQQFxRQ0AIAEoAlwhBSABKAJUIQYgAUE4ahogASABKQNINwMAIAUgAUE4aiAGIAEQ8YGAgAAgASABKAJcEIGCgIAANgI0IAEoAlQgASgCNBCxgoCAACABIAEoAlwoAgRBDGopAgA3A0gMAQsgASABKAJcEPCBgIAANgIwIAEoAjAoAgAhByABQThqIAcQvIKAgAAgASgCMBCigoCAAAwACwsgASgCXCEIIAEoAlQhCSABQThqGiABIAEpA0g3AwggCCABQThqIAkgAUEIahDxgYCAACABKAJcIQogASgCWCELIAEgCkEOIAsQ84GAgAA2AiwgASgCUCEMIAEoAlQhDSABKAIsIQ4gASgCUEEMaiEPIAEoAixBDGpBCGohECABKAJYIREgASAPKQIANwMYIAEgECkCADcDECABIAwgDSAOIAFBGGogAUEQaiARENqAgIAANgIoIAEoAjwQsIyAgAAgASgCUBCigoCAACABKAIsEKKCgIAAIAEoAighEiABQeAAaiSAgICAACASDwvfAgEEfyOAgICAAEEwayEBIAEkgICAgAAgASAANgIoIAEgASgCKBCJgoCAADYCJAJAAkAgASgCJC0AKEEBcUUNACABIAEoAiggASgCJBCKgoCAADYCLAwBCwJAIAEoAiQtAChBAXENACABKAIkKAIcKAIAIQIgAUEcaiACEMaCgIAAIAEgASkCHDcDCCABQQhqEL6BgIAAQQFxRQ0AIAEoAigQ6YGAgABBAXENACABIAEoAiggASgCJBCKgoCAADYCLAwBCwJAIAEoAiQoAhwoAgBBAEdBAXFFDQAgASgCJCgCHCgCACEDIAFBFGogAxDGgoCAACABIAEpAhQ3AwAgARDrgYCAAEEBcUUNACABIAEoAiggASgCJBCLgoCAADYCEAJAIAEoAhBBAEdBAXFFDQAgASABKAIQNgIsDAILCyABIAEoAiQ2AiwLIAEoAiwhBCABQTBqJICAgIAAIAQPC5QFARh/I4CAgIAAQYABayEBIAEkgICAgAAgASAANgJ8IAFBCBCwgoCAADYCeCABQQgQsIKAgAA2AnQgASgCfCECIAEoAnghAyABIAJBCiADEPOBgIAANgJwIAEoAnwgASgCdBCMgoCAACABKAJ8IQQgASgCeCEFIAEgBEEDIAUQ84GAgAA2AmwgASgCfCABKAJ0EIyCgIAAIAEoAnwhBiABKAJ4IQcgASAGQQsgBxDzgYCAADYCaAJAIAEoAmxBAEdBAXFFDQAgASgCbCgCACEIIAFB4ABqIAgQxoKAgAAgASABKQJgNwMwIAFBMGoQvoGAgABBAXFFDQAgASgCfBDpgYCAAEEBcQ0AIAEoAmwoAgAhCSABQdAAaiAJEMaCgIAAIAFB2ABqGiABIAEpAlA3AxAgAUHYAGogAUEQahDAgYCAACABKAJsKAIAIQogAUHAAGogChDGgoCAACABQcgAahogASABKQJANwMYIAFByABqIAFBGGoQv4GAgAAgASgCbCELIAEoAlghDCABKAJIIQ0gASgCcEEMaiEOIAEoAmhBDGpBCGohDyABKAJ4IRAgASAOKQIANwMoIAEgDykCADcDICALIAwgDSABQShqIAFBIGogEBChgYCAACABKAJYELCMgIAAIAEoAkgQsIyAgAALIAEoAnAhESABKAJsIRIgASgCdCETIAEoAmghFCABKAJwQQxqIRUgASgCaEEMakEIaiEWIAEoAnghFyABIBUpAgA3AwggASAWKQIANwMAIAEgESASIBMgFCABQQhqIAEgFxDUgICAADYCPCABKAJwEKKCgIAAIAEoAmwQooKAgAAgASgCaBCigoCAACABKAI8IRggAUGAAWokgICAgAAgGA8LlwUBEH8jgICAgABBgAFrIQIgAiSAgICAACACIAA2AnggAiABNgJ0IAIgAigCeCgCBEEMaikCADcDaCACQdgAakGAEBC5goCAABoCQAJAA0AgAigCeCgCBCgCHCEDIAJBxABqQf/B1y82AgAgAkHAAGpBIjYCACACQQ82AjwgAkENNgI4IAJBBDYCNCACQQo2AjAgA0EJIAJBMGoQnYKAgABBf3NBAXFFDQECQCACKAJ4QSEQm4KAgABBAXFFDQAgAigCXBCwjICAACACKAJ4IQQgAigCdCEFIAIgBEEhIAUQ84GAgAA2AlQgAigCVCgCACEGIAIoAlRBDGohByACKAJUQQxqQQhqIQggAigCdCEJQfXMhIAAGkGM9IWAABogAiAHKQIANwMIIAIgCCkCADcDAEGM9IWAACEKQfXMhIAAIAogBiACQQhqIAIgCRCVgYCAACACKAJUEKKCgIAAIAJBADYCfAwDCyACIAIoAngQ8IGAgAA2AlAgAigCUCgCACELIAJB2ABqIAsQvIKAgAAgAigCUBCigoCAAAwACwsgAkEIELCCgIAANgJMIAJBADYCSAJAAkAgAkHYAGoQu4KAgABBAEtBAXFFDQAgAkHYAGoQuoKAgAAhDCACKAJ4KAIEQQxqIQ0gAigCTCEOIAIgAikDaDcDGCACIA0pAgA3AxAgAiAMIAJBGGogAkEQaiAOENmAgIAANgJIDAELIAIoAngoAgRBDGohDyACKAJMIRBBh8KGgAAaIAIgAikDaDcDKCACIA8pAgA3AyAgAkGHwoaAACACQShqIAJBIGogEBDZgICAADYCSAsgAigCXBCwjICAACACIAIoAkg2AnwLIAIoAnwhESACQYABaiSAgICAACARDwvrCAsLfwF+AX8BfgF/AX4BfwF+AX8Bfg1/I4CAgIAAQZABayEBIAEkgICAgAAgASAANgKIASABQQgQsIKAgAA2AoQBIAFBCBCwgoCAADYCgAEgASgCiAEhAiABKAKEASEDIAEgAkEJIAMQ84GAgAA2AnwgASgCiAEhBCABKAKEASEFIAEgBEEDIAUQ84GAgAA2AngCQANAIAEoAogBKAIEKAIcIQYgAUH/wdcvNgIoIAFBIjYCJCABQQw2AiAgBkELIAFBIGoQnYKAgABBf3NBAXFFDQEgASgCiAEoAgQoAhwhByABQf/B1y82AgQgAUECNgIAAkAgB0EAIAEQnYKAgABBAXFFDQAgASgCiAEgASgCgAEQjYKAgAAMAQsCQCABKAKIASgCBCgCHEEDRkEBcUUNACABKAKAASABKAKIARCOgoCAABCxgoCAAAwBCwJAIAEoAogBKAIEKAIcQQ9GQQFxRQ0AIAEoAogBIAEoAoABEI+CgIAADAELAkAgASgCiAEoAgQoAhxBHUZBAXFFDQAgASgCgAEgASgCiAEQjoKAgAAQsYKAgAAMAQsCQCABKAKIASgCBCgCHEEcRkEBcUUNACABKAKIASgCACEIQTAhCSAIIAlqKAIAIQogCSABQcAAamogCjYCAEEoIQsgCCALaikCACEMIAsgAUHAAGpqIAw3AwBBICENIAggDWopAgAhDiANIAFBwABqaiAONwMAQRghDyAIIA9qKQIAIRAgDyABQcAAamogEDcDAEEQIREgCCARaikCACESIBEgAUHAAGpqIBI3AwBBCCETIAggE2opAgAhFCATIAFBwABqaiAUNwMAIAEgCCkCADcDQCABIAFBwABqENOBgIAANgI8AkAgASgCPEEAR0EBcUUNACABKAI8KAIcQQNGQQFxRQ0AIAEoAjwQooKAgAAgASgCgAEgASgCiAEQjoKAgAAQsYKAgAAMAgsgASgCPBCigoCAAAsgASgCiAEhFSABKAKEASEWIBVBqPCEgABBjYaGgAAgFhDvgYCAAAwACwsgAUEAOgA7IAEgASgCiAFBCxDygYCAADYCNAJAAkAgASgCNEEARkEBcUUNACABKAKIASEXIAEoAoQBIRggASAXQQwgGBDzgYCAADYCNAJAIAEoAjRBAEZBAXFFDQAgASgCfBCigoCAACABKAJ4EKKCgIAAIAFBgAFqELiCgIAAIAFBhAFqELiCgIAAIAFBADYCjAEMAgsgAUEBOgA7CyABKAJ8IRkgASgCeCEaIAEoAjQhGyABKAKAASEcIAEtADshHSABKAJ8QQxqIR4gASgCNEEMakEIaiEfIAEoAoQBISAgASAeKQIANwMYIAEgHykCADcDECABIBkgGiAbIBwgHUEBcSABQRhqIAFBEGogIBDTgICAADYCMCABKAJ8EKKCgIAAIAEoAngQooKAgAAgASgCNBCigoCAACABIAEoAjA2AowBCyABKAKMASEhIAFBkAFqJICAgIAAICEPC50BAQh/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYIAIoAhghAyACKAIYKAIcIQQgAigCGEEEaiEFIAIoAhhBBGpBCGohBkEAGkEBGiACIAUpAgA3AxAgAiAGKQIANwMIQQEhB0EAIQggAyAEIAggCCAHIAggAkEQaiACQQhqIAgQ1YCAgAAhCSACQSBqJICAgIAAIAkPC+4FAQ9/I4CAgIAAQYABayECIAIkgICAgAAgAiAANgJ4IAIgATYCdCACQQgQsIKAgAA2AnAgAkEIELCCgIAANgJsIAIoAnggAigCdCgCHBDmgYCAAAJAAkAgAigCdCgCHCgCAEEAR0EBcUUNACACKAJ0KAIcKAIAIQMgAkHkAGogAxDGgoCAACACIAIpAmQ3AzAgAkEwahDrgYCAAEEBcUUNACACKAJ0KAIcKAIAIQQgAkHYAGogBBDGgoCAACACIAIpAlg3AyggAiACQShqEOqBgIAANgJgIAIoAnggAigCYBDtgYCAACACKAJ4IAIoAmwgAigCcBCQgoCAAAwBCyACKAJ4IAIoAmwgAigCcBD7gYCAAAsCQAJAIAIoAnhBChCbgoCAAEEBcQ0AIAIgAigCdCACKAJsIAIoAnAQ9IGAgAA2AnwMAQsgAiACKAJ4EIeCgIAANgJUAkAgAigCeBDpgYCAAEEBcQ0AIAIoAlQoAhwoAgAhBSACQcwAaiAFEMaCgIAAIAIgAikCTDcDICACQSBqEL6BgIAAQQFxRQ0AIAIoAmwgAigCVBC1goCAACACKAJ4IAIoAmwgAigCcBD7gYCAACACIAIoAngQh4KAgAA2AlQLIAIoAnghBiACKAJUKAIcKAIAIQcgAkHAAGogBxDGgoCAACACIAIpAkA3AxggAiAGIAJBGGoQ54GAgABBAXE6AEsCQAJAIAItAEtBAXFFDQAgAiACKAJ4EOiBgIAANgI8IAIoAjwQooKAgAAMAQsgAigCeCACKAJUIAIoAnAQ9YGAgAALIAIoAnQhCCACKAJ0KAIcIQkgAigCbCEKIAIoAlQhCyACKAJ0QQRqIQwgAigCVEEEakEIaiENIAIoAnAhDkEAGkEAGiACIAwpAgA3AxAgAiANKQIANwMIQQAhDyACIAggCSAKIAsgDyAPIAJBEGogAkEIaiAOENWAgIAANgJ8CyACKAJ8IRAgAkGAAWokgICAgAAgEA8LvQEBAn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQANAIAIoAhwoAgQoAhwhAyACQf/B1y82AgQgAkECNgIAIANBACACEJ2CgIAAQQFxRQ0BIAIgAigCHBDwgYCAADYCFAJAAkAgAigCHC0AFEEBcUUNACACKAIYQQBHQQFxRQ0AIAIoAhwgAigCFCACKAIYEJGCgIAADAELIAIoAhQQooKAgAALDAALCyACQSBqJICAgIAADwujAQEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACIAIoAgxBABDygYCAADYCBAJAAkAgAigCBEEAR0EBcUUNACACKAIMIAIoAgQgAigCCBCRgoCAAAwBCyACIAIoAgxBAhDygYCAADYCACACKAIAQQBHQQFxRQ0AIAIoAgwgAigCACACKAIIEJGCgIAACyACQRBqJICAgIAADwvwCgEjfyOAgICAAEHQAWshASABJICAgIAAIAEgADYCyAEgASABKALIARCSgoCAADYCxAECQAJAIAEoAsgBLQAUQQFxRQ0AIAEoAsgBKAIEKAIcQRRGIQJBASEDIAJBAXEhBCADIQUCQCAEDQAgASgCyAEoAgBBFBDNgYCAACEFCyABIAVBAXE6AMMBAkAgAS0AwwFBAXFFDQAgAUGwAWpBgAIQuYKAgAAaIAFCADcDqAEgAUIANwOgASABQQA2ApwBIAFBADYCmAEgAUEAOgCXAQJAA0AgASgCyAEoAgQoAhwhBiABQf/B1y82AiQgAUECNgIgIAZBACABQSBqEJ2CgIAAQQFxRQ0BIAEgASgCyAEQ8IGAgAA2ApABAkAgAS0AlwFBAXENACABQQE6AJcBIAEgASgCkAFBDGopAgA3A6gBIAEgASgCkAEoAgQ2ApwBCyABKAKQASgCACEHIAFBsAFqIAcQvIKAgAAgASgCkAEQooKAgAAMAAsLIAEgASgCyAEQ8IGAgAA2AowBAkAgAS0AlwFBAXENACABQQE6AJcBIAEgASgCjAFBDGopAgA3A6gBIAEgASgCjAEoAgQ2ApwBCyABKAKMASgCACEIIAFBsAFqIAgQvIKAgAAgASABKAKMAUEMakEIaikCADcDoAEgASABKAKMASgCCDYCmAEgASgCjAEQooKAgAACQANAIAEoAsgBKAIEKAIcIQkgAUH/wdcvNgIUIAFBAjYCECAJQQAgAUEQahCdgoCAAEEBcUUNASABIAEoAsgBEPCBgIAANgKIASABKAKIASgCACEKIAFBsAFqIAoQvIKAgAAgASABKAKIAUEMakEIaikCADcDoAEgASABKAKIASgCCDYCmAEgASgCiAEQooKAgAAMAAsLIAFBAUEgELeMgIAANgKEASABKAKEAUEUNgIcIAEoArQBEKeCgIAAIQsgASgChAEgCzYC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QdwAamopAgA3AwAgAyADKQJcNwMQIAogA0EQahDQgYCAAAJAIAMoAlhBAEdBAXFFDQAgAygCWBCigoCAAAsCQCADLQBXQQFxRQ0AIAMoAqwBIQ4gAygCqAEhDyADQZQBahogAyADKQOIATcDCCAOIANBlAFqIA8gA0EIahDxgYCAACADKAKsARDugYCAACADKAKYARCwjICAAAwECwsgAyADKAKsARDwgYCAADYCSCADKAJIKAIAIRAgA0GUAWogEBC8goCAACADKAJIEKKCgIAADAALCyADKAKsASERIAMoAqgBIRIgA0GUAWoaIAMgAykDiAE3AzggESADQZQBaiASIANBOGoQ8YGAgAAgAygCrAEQ7oGAgAAgAygCmAEQsIyAgAALIANBsAFqJICAgIAADwvDAQEFfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiQCQCADKAIsLQAUQQFxRQ0AIANBCBCwgoCAADYCICADKAIoIQQgAygCKEEMaiEFIAMoAihBDGpBCGohBiADKAIgIQcgAyAFKQIANwMQIAMgBikCADcDCCADIAQgA0EQaiADQQhqIAcQ3oCAgAA2AhwgAygCJCADKAIcELGCgIAACyADKAIoEKKCgIAAIANBMGokgICAgAAPC6cFAQt/I4CAgIAAQZABayEBIAEkgICAgAAgASAANgKMASABQQgQsIKAgAA2AogBIAFBCBCwgoCAADYChAEgAUH0AGpBgAEQuYKAgAAaIAEgASgCjAEoAgRBDGopAgA3A2gCQANAIAEoAowBKAIEKAIcIQJBFCEDIAMgAUEgampB/8HXLzYCACABQTBqQSI2AgAgAUEMNgIsIAFBCzYCKCABQQI2AiQgAUEANgIgIAIgAyABQSBqEJ2CgIAAQX9zQQFxRQ0BAkAgASgCjAFBDxCbgoCAAEEBcUUNACABKAKMASEEIAEoAoQBIQUgAUH0AGoaIAEgASkDaDcDACAEIAFB9ABqIAUgARDxgYCAACABIAEoAowBEIGCgIAANgJkIAEoAoQBIAEoAmQQsYKAgAAgASABKAKMASgCBEEMaikCADcDaAwBCyABIAEoAowBEPCBgIAANgJgIAEoAmAoAgAhBiABQfQAaiAGELyCgIAAIAEoAmAQooKAgAAMAAsLIAEoAowBIQcgASgChAEhCCABQfQAahogASABKQNoNwMYIAcgAUH0AGogCCABQRhqEPGBgIAAIAFCADcDWCABQgA3A1ACQAJAIAEoAoQBKAIEQQBLQQFxRQ0AIAEgASgChAEQs4KAgAA2AkwgASABKAKEARC0goCAADYCSCABIAEoAkxBBGopAgA3A1ggASABKAJIQQRqQQhqKQIANwNQDAELIAEgASgCjAEoAgRBDGopAgA3A1ggASABKAKMASgCBEEMaikCADcDUAsgASgChAEhCSABKAKIASEKIAEgASkDWDcDECABIAEpA1A3AwggASAJIAFBEGogAUEIaiAKENeAgIAANgJEIAEoAngQsIyAgAAgASgCRCELIAFBkAFqJICAgIAAIAsPC5EIAR5/I4CAgIAAQaABayEBIAEkgICAgAAgASAANgKYASABQQgQsIKAgAA2ApQBIAFBCBCwgoCAADYCkAECQAJAIAEoApgBQQ8Qm4KAgABBAXFFDQAgASABKAKYARCBgoCAADYCjAEgASgClAEgASgCjAEQsYKAgAAgASgClAEhAiABKAKMAUEEaiEDIAEoAowBQQRqQQhqIQQgASgCkAEhBUEAGkEAGiABIAMpAgA3AxAgASAEKQIANwMIQQAhBiABIAYgAiAGIAYgAUEQaiABQQhqIAUQ1oCAgAA2ApwBDAELAkAgASgCmAFBAxCbgoCAAEEBcUUNACABKAKYASEHIAEoApABIQggASAHQQMgCBDzgYCAADYCiAEgASABKAKIARDQgICAADYChAEgASgCiAEQooKAgAAgASgClAEgASgChAEQsYKAgAAgASgClAEhCSABKAKEAUEEaiEKIAEoAoQBQQRqQQhqIQsgASgCkAEhDEEAGkEAGiABIAopAgA3AyAgASALKQIANwMYQQAhDSABIA0gCSANIA0gAUEgaiABQRhqIAwQ1oCAgAA2ApwBDAELAkAgASgCmAFBFRCbgoCAAEEBcUUNACABIAEoApgBIAEoApQBIAEoApABEJaCgIAANgKcAQwBCwJAIAEoApgBQRYQm4KAgABBAXFFDQAgASABKAKYARDwgYCAADYCgAEgASABKAKAAUEMaikCADcDeCABIAEoAoABQQxqQQhqKQIANwNwIAEoApABIQ5B95KFgAAaQee1hoAAGkGErYaAABogASABKQJ4NwMwIAEgASkCcDcDKEGErYaAACEPQee1hoAAIRBB95KFgAAgECAPIAFBMGogAUEoaiAOEJWBgIAAIAEoApQBIREgASgCkAEhEkEAGkEAGiABIAEpAng3A0AgASABKQJwNwM4QQAhEyABIBMgESATIBMgAUHAAGogAUE4aiASENaAgIAANgJsIAEoAoABEKKCgIAAIAEgASgCbDYCnAEMAQsgASgCmAEoAgQoAhwQn4KAgAAhFCABKAKYASgCBEEMaiEVIAEoApgBKAIEQQxqQQhqIRYgASgCkAEhF0Go8ISAABpBze+FgAAaIAEgFSkCADcDUCABIBYpAgA3A0hBze+FgAAhGEGo8ISAACAYIBQgAUHQAGogAUHIAGogFxCVgYCAACABKAKUASEZIAEoApgBKAIEQQxqIRogASgCmAEoAgRBDGpBCGohGyABKAKQASEcQQAaQQAaIAEgGikCADcDYCABIBspAgA3A1hBACEdIAEgHSAZIB0gHSABQeAAaiABQdgAaiAcENaAgIAANgJoIAEgASgCaDYCnAELIAEoApwBIR4gAUGgAWokgICAgAAgHg8LegEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAFBADYCCAJAA0AgASABKAIMENOBgIAANgIIAkAgASgCCCgCHEERRkEBcUUNACABKAIIEKKCgIAADAILIAEoAggQooKAgABBAUEBcQ0ACwsgAUEQaiSAgICAAA8L0QIBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCCCABQQA2AgQCQANAIAEgASgCCBDTgYCAADYCBAJAIAEoAgQoAhxBFEZBAXFFDQAgASgCBBCigoCAACABQQFBAXE6AA8MAgsCQAJAAkAgASgCBCgCHEUNACABKAIEKAIcQQJGQQFxRQ0BCyABKAIEEKKCgIAADAELAkACQCABKAIEKAIcQQNGQQFxDQAgASgCBCgCHEEgRkEBcQ0AIAEoAgQoAhxBGEZBAXENACABKAIEKAIcQQ9GQQFxRQ0BCwJAAkAgASgCBCgCHEEPRkEBcUUNACABKAIEEKKCgIAAIAEoAggQlIKAgAAMAQsgASgCBBCigoCAAAsMAQsgASgCBBCigoCAACABQQBBAXE6AA8MAgtBAUEBcQ0ACwsgAS0AD0EBcSECIAFBEGokgICAgAAgAg8LmxIBTH8jgICAgABBoAJrIQMgAySAgICAACADIAA2ApwCIAMgATYCmAIgAyACNgKUAiADQYQCakGABBC5goCAABogAygCnAIhBCADKAKUAiEFIAMgBEEVIAUQ84GAgAA2AoACIAMgAygCnAIoAgRBDGopAgA3A/gBA0AgAygCnAJBIhCbgoCAACEGQQAhByAGQQFxIQggByEJAkAgCA0AIAMoApwCQRUQm4KAgAAhCkEAIQsgCkEBcSEMIAshDQJAIAxFDQAgAygCgAJBAEchDkEAIQ8gDkEBcSEQIA8hDSAQRQ0AIAMoApwCKAIEKAIAIAMoAoACKAIAEP+LgIAAQQBGIQ0LIA1Bf3MhCQsCQCAJQQFxRQ0AAkAgAygCnAJBDxCbgoCAAEEBcUUNACADKAKcAiERIAMoApgCIRIgA0GEAmoaIAMgAykD+AE3AwAgESADQYQCaiASIAMQ8YGAgAAgAygCmAIgAygCnAIQgYKAgAAQsYKAgAAgAyADKAKcAigCBEEMaikCADcD+AEMAgsCQCADKAKcAkEXEJuCgIAAQQFxRQ0AIAMoApwCKAIAIRMgA0HYAWogExDPgYCAACADIAMoApwCKAIAENOBgIAANgLUAQJAIAMoAtQBQQBHQQFxRQ0AIAMoAtQBKAIcQRVGQQFxRQ0AIAMoAoACQQBHQQFxRQ0AIAMoAtQBKAIAIAMoAoACKAIAEP+LgIAADQAgAygCnAIoAgQoAgAhFCADQYQCaiAUELyCgIAAIAMoAtQBKAIAIRUgA0GEAmogFRC8goCAACADKAKcAigCBBCigoCAACADKALUARCigoCAACADKAKcAigCABDTgYCAACEWIAMoApwCIBY2AgQMAwsgAygCnAIoAgAhF0EYIRggGCADQQhqaiAYIANB2AFqaikCADcDAEEQIRkgGSADQQhqaiAZIANB2AFqaikCADcDAEEIIRogGiADQQhqaiAaIANB2AFqaikCADcDACADIAMpAtgBNwMIIBcgA0EIahDQgYCAAAJAIAMoAtQBQQBHQQFxRQ0AIAMoAtQBEKKCgIAACwsgAygCnAIoAgQoAgAhGyADQYQCaiAbELyCgIAAIAMoApwCKAIEEKKCgIAAIAMoApwCKAIAENOBgIAAIRwgAygCnAIgHDYCBAwBCwsCQCADKAKcAkEVEJuCgIAAQQFxRQ0AIAMoAoACQQBHQQFxRQ0AIAMoApwCKAIEKAIAIAMoAoACKAIAEP+LgIAADQAgAygCnAIoAgAhHSADQbQBaiAdEM+BgIAAIAMgAygCnAIoAgQ2ArABIAMoApwCKAIAENOBgIAAIR4gAygCnAIgHjYCBAJAAkACQCADKAKcAkEDEJuCgIAAQQFxDQAgAygCnAJBIBCbgoCAAEEBcUUNAQsgAygCgAIoAgAhHyADKAKwAUEMaiEgIAMoArABQQxqQQhqISEgAygClAIhIkHhkYWAABpBjLaGgAAaIAMgICkCADcDYCADICEpAgA3A1hBjLaGgAAhI0HhkYWAACAjIB8gA0HgAGogA0HYAGogIhCVgYCAACADKAKcAigCACEkQRghJSAlIANB6ABqaiAlIANBtAFqaikCADcDAEEQISYgJiADQegAamogJiADQbQBamopAgA3AwBBCCEnICcgA0HoAGpqICcgA0G0AWpqKQIANwMAIAMgAykCtAE3A2ggJCADQegAahDQgYCAACADKAKcAigCBBCigoCAACADKAKwASEoIAMoApwCICg2AgQgAygCnAIoAgQoAgAhKSADQYQCaiApELyCgIAAIAMoApwCKAIEEKKCgIAAIAMoApwCKAIAENOBgIAAISogAygCnAIgKjYCBANAIAMoApwCQSIQm4KAgAAhK0EAISwgK0EBcSEtICwhLgJAIC0NACADKAKcAkEVEJuCgIAAIS9BACEwIC9BAXEhMSAwITICQCAxRQ0AIAMoAoACQQBHITNBACE0IDNBAXEhNSA0ITIgNUUNACADKAKcAigCBCgCACADKAKAAigCABD/i4CAAEEARiEyCyAyQX9zIS4LAkAgLkEBcUUNAAJAIAMoApwCQQ8Qm4KAgABBAXFFDQAgAygCnAIhNiADKAKYAiE3IANBhAJqGiADIAMpA/gBNwMoIDYgA0GEAmogNyADQShqEPGBgIAAIAMoApgCIAMoApwCEIGCgIAAELGCgIAAIAMgAygCnAIoAgRBDGopAgA3A/gBDAILIAMoApwCKAIEKAIAITggA0GEAmogOBC8goCAACADKAKcAigCBBCigoCAACADKAKcAigCABDTgYCAACE5IAMoApwCIDk2AgQMAQsLDAELIAMoApwCKAIEEKKCgIAAIAMoArABITogAygCnAIgOjYCBCADKAKcAigCACE7QRghPCA8IANBiAFqaiA8IANBtAFqaikCADcDAEEQIT0gPSADQYgBamogPSADQbQBamopAgA3AwBBCCE+ID4gA0GIAWpqID4gA0G0AWpqKQIANwMAIAMgAykCtAE3A4gBIDsgA0GIAWoQ0IGAgAALCyADKAKcAiE/IAMoApgCIUAgA0GEAmoaIAMgAykD+AE3A1AgPyADQYQCaiBAIANB0ABqEPGBgIAAIAMoAogCELCMgIAAIAMoApwCIUEgAygClAIhQiADIEFBFSBCEPOBgIAANgKsAQJAIAMoAoACQQBHQQFxRQ0AIAMoAqwBQQBHQQFxRQ0AIAMoAoACKAIAIAMoAqwBKAIAEP+LgIAARQ0AIAMoAoACIUMgAygCrAEhRCADKAKsAUEMaiFFIAMoAqwBQQxqQQhqIUYgAygClAIhRyADIEUpAgA3A0ggAyBGKQIANwNAIEMgRCADQcgAaiADQcAAaiBHEJ+BgIAACyADKAKAAiFIIAMoApgCIUkgAygCrAEhSiADKAKAAkEMaiFLIAMoAqwBQQxqQQhqIUwgAygClAIhTUEBGiADIEspAgA3AzggAyBMKQIANwMwIAMgSCBJIEpBASADQThqIANBMGogTRDWgICAADYCqAEgAygCgAIQooKAgAAgAygCrAEQooKAgAAgAygCqAEhTiADQaACaiSAgICAACBODwtyAQJ/I4CAgIAAQRBrIQEgASAANgIIIAEoAgghAiACQQJLGgJAAkACQAJAAkAgAg4DAAECAwsgAUGciYSAADYCDAwDCyABQbyVhIAANgIMDAILIAFB182FgAA2AgwMAQsgAUGVrISAADYCDAsgASgCDA8LugEBA38jgICAgABBEGshAyADJICAgIAAIAMgATYCDCADIAI2AgggAEEAKQKYwoaAADcCACADQQA2AgQCQANAIAMoAgQgAygCCElBAXFFDQEgAygCDCADKAIEai0AACEEQRghBQJAAkAgBCAFdCAFdRCmgoCAAEUNACAAIAAoAgBBAWo2AgAgAEEANgIEDAELIAAgACgCBEEBajYCBAsgAyADKAIEQQFqNgIEDAALCyADQRBqJICAgIAADwuFAgEJfyOAgICAAEHAAGshBCAEJICAgIAAIAQgADYCPCAEIAE2AjggBCACNgI0IAQgAzYCMCAEIAQoAjwoAgQgBCgCMCgCtAFr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ASADKALUARCogoCAACADIAMoArQBQQFqNgK0AQwACwsLAkAgAygCuAEoAiRBAEdBAXFFDQAgAygCuAEoAiQgAygC2AEgAygC1AEQqIKAgAALDBYLIAMgAygC3AE2ArABAkAgAygCsAEoAhxBAEdBAXFFDQAgA0EANgKsAQJAA0AgAygCrAEgAygCsAEoAhwQt4KAgABJQQFxRQ0BIAMoArABKAIcIAMoAqwBELKCgIAAIAMoAtgBIAMoAtQBEKiCgIAAIAMgAygCrAFBAWo2AqwBDAALCwsMFQsgAyADKALcATYCqAECQCADKAKoASgCGEEAR0EBcUUNACADQQA2AqQBAkADQCADKAKkASADKAKoASgCGBC3goCAAElBAXFFDQEgAygCqAEoAhggAygCpAEQsoKAgAAgAygC2AEgAygC1AEQqIKAgAAgAyADKAKkAUEBajYCpAEMAAsLCwwUCyADIAMoAtwBNgKgAQJAIAMoAqABKAIYQQBHQQFxRQ0AIAMoAqABKAIYIAMoAtgBIAMoAtQBEKiCgIAACwJAIAMoAqABKAIgQQBHQQFxRQ0AIAMoAqABKAIgIAMoAtgBIAMoAtQBEKiCgIAACwwTCyADIAMoAtwBNgKcAQJAIAMoApwBKAIcQQBHQQFxRQ0AIANBADYCmAECQANAIAMoApgBIAMoApwBKAIcELeCgIAASUEBcUUNASADKAKcASgCHCADKAKYARCygoCAACADKALYASADKALUARCogoCAACADIAMoApgBQQFqNgKYAQwACwsLDBILIAMgAygC3AE2ApQBAkAgAygClAEoAhxBAEdBAXFFDQAgA0EANgKQAQJAA0AgAygCkAEgAygClAEoAhwQt4KAgABJQQFxRQ0BIAMoApQBKAIcIAMoApABELKCgIAAIAMoAtgBIAMoAtQBEKiCgIAAIAMgAygCkAFBAWo2ApABDAALCwsMEQsgAyADKALcATYCjAECQCADKAKMASgCHEEAR0EBcUUNACADQQA2AogBAkADQCADKAKIASADKAKMASgCHBC3goCAAElBAXFFDQEgAygCjAEoAhwgAygCiAEQsoKAgAAgAygC2AEgAygC1AEQqIKAgAAgAyADKAKIAUEBajYCiAEMAAsLCwwQCyADIAMoAtwBNgKEAQJAIAMoAoQBKAIcQQBHQQFxRQ0AIANBADYCgAECQANAIAMoAoABIAMoAoQBKAIcELeCgIAASUEBcUUNASADKAKEASgCHCADKAKAARCygoCAACADKALYASADKALUARCogoCAACADIAMoAoABQQFqNgKAAQwACwsLDA8LIAMgAygC3AE2AnwCQCADKAJ8KAIkQQBHQQFxRQ0AIANBADYCeAJAA0AgAygCeCADKAJ8KAIkELeCgIAASUEBcUUNASADKAJ8KAIkIAMoAngQsoKAgAAgAygC2AEgAygC1AEQqIKAgAAgAyADKAJ4QQFqNgJ4DAALCwsMDgsgAyADKALcATYCdAJAIAMoAnQoAiRBAEdBAXFFDQAgA0EANgJwAkADQCADKAJwIAMoAnQoAiQQt4KAgABJQQFxRQ0BIAMoAnQoAiQgAygCcBCygoCAACADKALYASADKALUARCogoCAACADIAMoAnBBAWo2AnAMAAsLCwJAIAMoAnQoAihBAEdBAXFFDQAgAygCdCgCKCADKALYASADKALUARCogoCAAAsCQCADKAJ0KAIsQQBHQQFxRQ0AIAMoAnQoAiwgAygC2AEgAygC1AEQqIKAgAALDA0LIAMgAygC3AE2AmwCQCADKAJsKAIkQQBHQQFxRQ0AIANBADYCaAJAA0AgAygCaCADKAJsKAIkELeCgIAASUEBcUUNASADKAJsKAIkIAMoAmgQsoKAgAAgAygC2AEgAygC1AEQqIKAgAAgAyADKAJoQQFqNgJoDAALCwsCQCADKAJsKAIoQQBHQQFxRQ0AIAMoAmwoAiggAygC2AEgAygC1AEQqIKAgAALDAwLIAMgAygC3AE2AmQCQCADKAJkKAIkQQBHQQFxRQ0AIANBADYCYAJAA0AgAygCYCADKAJkKAIkELeCgIAASUEBcUUNASADKAJkKAIkIAMoAmAQsoKAgAAgAygC2AEgAygC1AEQqIKAgAAgAyADKAJgQQFqNgJgDAALCwsMCwsgAyADKALcATYCXAJAIAMoAlwoAiRBAEdBAXFFDQAgA0EANgJYAkADQCADKAJYIAMoAlwoAiQQt4KAgABJQQFxRQ0BIAMoAlwoAiQgAygCWBCygoCAACADKALYASADKALUARCogoCAACADIAMoAlhBAWo2AlgMAAsLCwJAIAMoAlwoAihBAEdBAXFFDQAgA0EANgJUAkADQCADKAJUIAMoAlwo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AXFFDQECQCACKAIMIAIoAhAQrYKAgABBAXFFDQAgAigCDCEEIAIoAhggBDYCBCACIAIoAhgoAgQgAigCEBCugoCAADYCHAwDCyACIAIoAgwoAgA2AgwMAAsLIAIgAigCGCACKAIQEKqCgIAAQQFxOgALAkAgAi0AC0EBcQ0AIAJBADYCHAwBCyACIAIoAhgoAgQgAigCEBCugoCAADYCHAsgAigCHCEFIAJBIGokgICAgAAgBQ8LiwEBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAIoAghBAWshBAJAIANBfyAEa01BAXENAEGgtYaAAEHb2YWAAEEOQbWPhYAAEIGAgIAAAAsgAigCDCACKAIIQQFraiACKAIIbiACKAIIbCEFIAJBEGokgICAgAAgBQ8LgwEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIMKAIIIAIoAgwoAgRNQQFxDQBBioGEgABB29mFgABBFEG3gISAABCBgICAAAALIAIoAgwoAgggAigCCGogAigCDCgCBE1BAXEhAyACQRBqJICAgIAAIAMPC9ABAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkAgAigCCEEAS0EBcQ0AQaukhoAAQdvZhYAAQRpB6/SEgAAQgYCAgAAACwJAIAIoAgwoAgggAigCCGogAigCDCgCBE1BAXENAEGrgYSAAEHb2YWAAEEbQev0hIAAEIGAgIAAAAsgAiACKAIMQQxqIAIoAgwoAghqNgIEIAIoAgghAyACKAIMIQQgBCADIAQoAghqNgIIIAIoAgQhBSACQRBqJICAgIAAIAUPCwUAQQwPC60BAQR/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggARCvgoCAABCujICAADYCBCABKAIEQQA2AgQgASgCCCECIAEoAgQgAjYCCCABKAIIQQJ0EK6MgIAAIQMgASgCBCADNgIAAkACQCABKAIEKAIAQQBHQQFxDQAgASgCBBCwjICAACABQQA2AgwMAQsgASABKAIENgIMCyABKAIMIQQgAUEQaiSAgICAACAEDwuiAwEFfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGAJAAkAgAigCHCgCBCAC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LQAfQQFxIQMgAkEgaiSAgICAACADDws4AQF/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIMKAIIIAIoAghqIAIoAgwoAgxNQQFxDwvdAgEIfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAIAIoAghBAWpBf09BAXFFDQBBACgCoPmIgABBpMCGgABBABDbi4CAABpBARCAgICAAAALIAJBADYCBAJAAkAgAigCDCgCAEEARkEBcUUNACACIAIoAgwoAgQgAigCCEEBahCxjICAADYCBAwBCyACIAIoAgwoAgAgAigCCEEBahCrgoCAADYCBCACKAIEIQMgAigCDCgCBCEEIAIoAgwoAgxBAWohBQJAIAVFDQAgAyAEIAX8CgAACwsCQCACKAIEQQBGQX9zQX9zQQFxRQ0AQQAoAqD5iIAAIQYgAiACKAIINgIAIAZBwr+GgAAgAhDbi4CAABpBARCAgICAAAALIAIoAgQhByACKAIMIAc2AgQgAigCCCEIIAIoAgwgCDYCDEEBQQFxIQkgAkEQaiSAgICAACAJDwvkAQEGfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQCQAJAAkAgAygCDEEAR0EBcUUNACADKAIIQQBHQQFxRQ0AIAMoAgQNAQsMAQsCQCADKAIMIAMoAgQQvYKAgABBAXENAAwBCyADKAIMKAIEIAMoAgwoAghqIQQgAygCCCEFIAMoAgQhBgJAIAZFDQAgBCAFIAb8CgAACyADKAIEIQcgAygCDCEIIAggByAIKAIIajYCCCADKAIMKAIEIAMoAgwoAghqQQA6AAALIANBEGokgICAgAAPC1kBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAEpAgA3AwACQCACEMuCgIAAQQFxDQAgAigCDCABKAIAIAEoAgQQwIKAgAALIAJBEGokgICAgAAPC1IBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE6AAsgAiACLQALOgAJIAJBADoACiACKAIMIAJBCWoQvIKAgAAgAkEQaiSAgICAAA8LWQEFfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAigCCCEEQSAhBUEYIQYgAyAFIAZ0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ACACQShqENWCgIAAGiACKAJoKAIcIQogAkEgaiAKEJCDgIAAIABByMeFgAAgAkEgahDXgoCAACACQSBqENWCgIAAGiACKAJoKAIgIQsgAkEYaiALEJCDgIAAIABBk8CFgAAgAkEYahDZgoCAACACQRhqENWCgIAAGiACQQFBAXE6AF8CQCACLQBfQQFxDQAgABDVgoCAABoLIAJB4ABqENWCgIAAGgsgAkHwAGokgICAgAAPCzUBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDCAAQQQQ2oKAgAAaIAFBEGokgICAgAAPC0UBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggACACKAIIEIKAgIAAENqCgIAAGiACQRBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAAgAigCCBDbgoCAAEEAENyCgIAAIAJBEGokgICAgAAPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDbgoCAACEFIAMoAhghBiADQQxqIAQgBhDdgoCAACAFIANBDGoQ24KAgAAgBCADKAIUEN6CgIAAENuCgIAAEIOAgIAAIANBDGoQ1YKAgAAaIANBIGokgICAgAAPC2cBA38jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIIIQIgASACNgIMAkAgAhDfgoCAAEEBcUUNACACENuCgIAAEISAgIAAIAJBADYCBAsgASgCDCEDIAFBEGokgICAgAAgAw8LkQEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENuCgIAAIQUgAygCGCEGIANBDGogBCAGEOCCgIAAIAUgA0EMahDbgoCAACAEIAMoAhQQ3oKAgAAQ24KAgAAQg4CAgAAgA0EMahDVgoCAABogA0EgaiSAgICAAA8LkQEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENuCgIAAIQUgAygCGCEGIANBDGogBCAGEOGCgIAAIAUgA0EMahDbgoCAACAEIAMoAhQQ3oKAgAAQ24KAgAAQg4CAgAAgA0EMahDVgoCAABogA0EgaiSAgICAAA8LkQEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENuCgIAAIQUgAygCGCEGIANBDGogBCAGEOKCgIAAIAUgA0EMahDbgoCAACAEIAMoAhQQ3oKAgAAQ24KAgAAQg4CAgAAgA0EMahDVgoCAABogA0EgaiSAgICAAA8LkQEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENuCgIAAIQUgAygCGCEGIANBDGogBCAGEOOCgIAAIAUgA0EMahDbgoCAACAEIAMoAhQQ3oKAgAAQ24KAgAAQg4CAgAAgA0EMahDVgoCAABogA0EgaiSAgICAAA8LTwECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAxD0i4CAADYCACADIAIoAgg2AgQgAkEQaiSAgICAACADDwsfAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwoAgQPC0oBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCCCADKAIEEPSCgIAAIANBEGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCCg4CAABogA0EQaiSAgICAAA8LIwEBfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCCA8LJQEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIEQQhLQQFxDwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQgoOAgAAaIANBEGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCCg4CAABogA0EQaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEIKDgIAAGiADQRBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMg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iYAAQQEhB0EAIAc6AKSqiYAACyADQRhqEPeCgIAAGiADQQA2AhRBACgCoKqJgAAhCCADKAIoIQkgAygCJCEKIANBGGoQ+IKAgAAhCyADIAggCSAKIANBFGogCxCGgICAABD5goCAADYCECADKAIUIQwgA0EMaiAMEPqCgIAAGiAAIAMoAhAQ+4KAgAAgA0EMahD8goCAABogA0EwaiSAgICAAA8LGQEBfyOAgICAAEEQayEBIAEgADYCDEEBDws0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwQ/YKAgAAhAiABQRBqJICAgIAAIAIPC0sBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMIQIgASACEP6CgIAANgIIIAFBCGoQ/4KAgAAgAUEQaiSAgICAACACDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBCAg4CAACECIAFBEGokgICAgAAgAg8LHgEBfyOAgICAAEEQayEBIAEgADkDCCABKwMI/AMPCzEBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwhAyADIAIoAgg2AgAgAw8LPgEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCAAIAIoAggQgYOAgAAgAkEQaiSAgICAAA8LXQEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIIAEoAgghAiABIAI2AgwCQCACKAIAQQBHQQFxRQ0AIAIoAgAQh4CAgAALIAEoAgwhAyABQRBqJICAgIAAIAMPCwkAQaTChoAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQAPCxcBAX8jgICAgABBEGshASABIAA2AgwPCxkBAX8jgICAgABBEGshASABIAA2AgxBAA8LPwEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCAAIAIoAggQ2oKAgAAaIAJBEGokgICAgAAPC04BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAMgAigCCBCIgICAABDagoCAABogAkEQaiSAgICAACADDwueAgELfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiRBAC0ArKqJgABBAXEhBEEAIQUCQCAEQf8BcSAFQf8BcUZBAXFFDQBBw8KGgAAQhIOAgABBw8KGgAAQhYOAgABBARCFgICAACEGQQAgBjYCqKqJgABBASEHQQAgBzoArKqJgAALIAMoAiQhCCADQRhqIAgQhoOAgAAaIANBADYCFEEAKAKoqomAACEJIAMoAiwhCiADKAIoIQsgA0EYahCHg4CAACEMIAkgCiALIANBFGogDBCGgICAABCIg4CAACADKAIUIQ0gA0EMaiANEPqCgIAAGhCJg4CAACADQQxqEPyCgIAAGiADQTBqJICAgIAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCKg4CAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxCLg4CAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQjIOAgAAQjYOAgAAgAigCHBD/goCAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEI6DgIAAIQIgAUEQaiSAgICAACACDwsXAQF/I4CAgIAAQRBrIQEgASAAOQMIDwsNACOAgICAAEEQaxoPCwkAQcTChoAADwscAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIIEI+DgIAAIQIgAUEQaiSAgICAACACDwtGAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIIQMgAigCDCgCACADNgIAIAIoAgwhBCAEIAQoAgBBCGo2AgAPCxwBAX8jgICAgABBEGshASABIAA2AgwgASgCDA8LTgEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwhAiABIAIQ24KAgAA2AgggAkEANgIEIAEoAgghAyABQRBqJICAgIAAIAMPC10BAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQAJAIAIoAghBAEdBAXFFDQAgACACKAIIEIKDgIAAGgwBCyAAENGCgIAACyACQRBqJICAgIAADwuXAQEDfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIsIAIgASkCADcDICACIAIpAiA3AwgCQAJAIAJBCGoQy4KAgABBAXFFDQAgABDRgoCAAAwBCyABKAIAIQMgASgCBCEEIAJBFGogAyAEEJKDgIAAGiAAIAJBFGoQk4OAgAAaIAJBFGoQjY2AgAAaCyACQTBqJICAgIAADwtcAQJ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMIQQgBBCUg4CAABogBCADKAIIIAMoAgQQj42AgAAgA0EQaiSAgICAACAEDwtTAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwhAyACKAIIIQRBACEFIAMgBSAFIAQQlYOAgAAgAkEQaiSAgICAACADDws8AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCECIAIQrIOAgAAaIAFBEGokgICAgAAgAg8LsQIBC38jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCIEEALQC0qomAAEEBcSEFQQAhBgJAIAVB/wFxIAZB/wFxRkEBcUUNAEHMwoaAABCtg4CAAEHMwoaAABCug4CAAEEDEIWAgIAAIQdBACAHNgKwqomAAEEBIQhBACAIOgC0qomAAAsgBCgCICEJIARBGGogCRCvg4CAABogBEEANgIUQQAoArCqiYAAIQogBCgCKCELIAQoAiQhDCAEQRhqELCDgIAAIQ0gBCAKIAsgDCAEQRRqIA0QhoCAgAAQ+YKAgAA2AhAgBCgCFCEOIARBDGogDhD6goCAABogACAEKAIQEPuCgIAAIARBDGoQ/IKAgAAaIARBMGokgICAgAAPC6UBAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAkEEakH1qoSAABDSgoCAACACQQBBAXE6AAMgACACQQRqENOCgIAAIABBn66FgAAgARCXg4CAACABQQRqIQMgAEHL7ISAACADEJiDgIAAIAJBAUEBcToAAwJAIAItAANBAXENACAAENWCgIAAGgsgAkEEahDVgoCAABogAkEQaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENuCgIAAIQUgAygCGCEGIANBDGogBCAGEN2CgIAAIANBDGoQ24KAgAAhByADKAIUIQggA0EEaiAEIAgQmYOAgAAgBSAHIANBBGoQ24KAgAAQg4CAgAAgA0EEahDVgoCAABogA0EMahDVgoCAABogA0EgaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENuCgIAAIQUgAygCGCEGIANBDGogBCAGEJqDgIAAIANBDGoQ24KAgAAhByADKAIUIQggA0EEaiAEIAgQmYOAgAAgBSAHIANBBGoQ24KAgAAQg4CAgAAgA0EEahDVgoCAABogA0EMahDVgoCAABogA0EgaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEL+DgIAAGiADQRBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQgoOAgAAaIANBEGokgICAgAAPC5ICAQF/I4CAgIAAQcAAayECIAIkgICAgAAgAiAANgI8IAJBNGpB9aqEgAAQ0oKAgAAgAkEAQQFxOgAzIAAgAkE0ahDTgoCAACACIAEpAgA3AyAgAkEoahogAiACKQIgNwMAIAJBKGogAhCWg4CAACAAQaWQhIAAIAJBKGoQ2YKAgAAgAkEoahDVgoCAABogAiABQQhqKQIANwMQIAJBGGoaIAIgAikCEDcDCCACQRhqIAJBCGoQloOAgAAgAEGsw4WAACACQRhqEJyDgIAAIAJBGGoQ1YKAgAAaIAJBAUEBcToAMwJAIAItADNBAXENACAAENWCgIAAGgsgAkE0ahDVgoCAABogAkHAAGokgICAgAAPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDbgoCAACEFIAMoAhghBiADQQxqIAQgBhCdg4CAACAFIANBDGoQ24KAgAAgBCADKAIUEN6CgIAAENuCgIAAEIOAgIAAIANBDGoQ1YKAgAAaIANBIGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCCg4CAABogA0EQaiSAgICAAA8LpQEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACQQRqQf6GhIAAENKCgIAAIAJBAEEBcToAAyAAIAJBBGoQ04KAgAAgAEHIhoWAACABEJ+DgIAAIAFBBGohAyAAQciGhYAAIAMQn4OAgAAgAkEBQQFxOgADAkAgAi0AA0EBcQ0AIAAQ1YKAgAAaCyACQQRqENWCgIAAGiACQRBqJICAgIAADwtTAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMENuCgIAAIAMoAgggAygCBBCgg4CAACADQRBqJICAgIAADwtNAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMIAMoAgggAygCBBDIg4CAACADQRBqJICAgIAADwvGBAMFfwF+AX8jgICAgABBgAFrIQIgAiSAgICAACACIAA2AnwgAiABNgJ4AkACQCACKAJ4QQBHQQFxDQAgABDRgoCAAAwBCyACQfAAakH1qoSAABDSgoCAACACQQBBAXE6AG8gACACQfAAahDTgoCAAAJAAkAgAigCeCgCAEEAR0EBcUUNACACKAJ4KAIAIQMgAkHgAGogAxCig4CAABogAEG3koWAACACQeAAahCjg4CAACACQeAAahCNjYCAABoMAQsgAkHYAGoQ0YKAgAAgAEG3koWAACACQdgAahDZgoCAACACQdgAahDVgoCAABoLIAIoAngoAhwQn4KAgAAhBCACQcwAaiAEEKKDgIAAGiAAQeWrhYAAIAJBzABqEKSDgIAAIAJBzABqEI2NgIAAGiACIAIoAnhBBGopAgA3AzggAkHEAGoaIAIgAikCODcDCCACQcQAaiACQQhqEJ6DgIAAIABB4bmFgAAgAkHEAGoQ2YKAgAAgAkHEAGoQ1YKAgAAaIAIoAnhBDGohBUEIIQYgBSAGaikCACEHIAYgAkEgamogBzcDACACIAUpAgA3AyAgAkEwahpBCCEIIAggAkEQamogCCACQSBqaikCADcDACACIAIpAiA3AxAgAkEwaiACQRBqEJuDgIAAIABByOeEgAAgAkEwahDXgoCAACACQTBqENWCgIAAGiACQQFBAXE6AG8CQCACLQBvQQFxDQAgABDVgoCAABoLIAJB8ABqENWCgIAAGgsgAkGAAWokgICAgAAPC1sBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAMQlIOAgAAaIAMgAigCCCACKAIIEKaDgIAAEI+NgIAAIAJBEGokgICAgAAgAw8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENuCgIAAIQUgAygCGCEGIANBDGogBCAGEOOCgIAAIANBDGoQ24KAgAAhByADKAIUIQggA0EEaiAEIAgQpYOAgAAgBSAHIANBBGoQ24KAgAAQg4CAgAAgA0EEahDVgoCAABogA0EMahDVgoCAABogA0EgaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENuCgIAAIQUgAygCGCEGIANBDGogBCAGEN2CgIAAIANBDGoQ24KAgAAhByADKAIUIQggA0EEaiAEIAgQpYOAgAAgBSAHIANBBGoQ24KAgAAQg4CAgAAgA0EEahDVgoCAABogA0EMahDVgoCAABogA0EgaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEKmDgIAAGiADQRBqJICAgIAADws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBDOg4CAACECIAFBEGokgICAgAAgAg8LgwQBA38jgICAgABB0ABrIQMgAySAgICAACADIAA2AkwgAyABNgJIIAMgAjYCRCADQTxqQfWqhIAAENKCgIAAIANBNGpB/oaEgAAQ0oKAgAAgA0EAQQFxOgAzIAAgA0E8ahDTgoCAACADQShqIANBNGoQ04KAgAAgA0EgaiADQTRqENOCgIAAIANBGGogA0E0ahDTgoCAAAJAIAMoAkhBAEdBAXFFDQAgA0EANgIUAkADQCADKAIUIAMoAkgQt4KAgABJQQFxRQ0BIAMgAygCSCADKAIUELKCgIAANgIQAkAgAygCEEEAR0EBcUUNACADKAIQIQQgA0EIaiAEEKGDgIAAIANBKGpByIaFgAAgA0EIahDygoCAACADQQhqENWCgIAAGgsgAyADKAIUQQFqNgIUDAALCwsgAEHduYSAACADQShqEKiDgIAAIAMoAkQhBSADIAUQqYOAgAAaIABB6buFgAAgAxCog4CAACADENWCgIAAGiAAQZC8hIAAIANBGGoQ14KAgAAgAEHVs4SAACADQSBqEKiDgIAAIANBAUEBcToAMyADQRhqENWCgIAAGiADQSBqENWCgIAAGiADQShqENWCgIAAGgJAIAMtADNBAXENACAAENWCgIAAGgsgA0E0ahDVgoCAABogA0E8ahDVgoCAABogA0HQAGokgICAgAAPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDbgoCAACEFIAMoAhghBiADQQxqIAQgBhCag4CAACAFIANBDGoQ24KAgAAgBCADKAIUEN6CgIAAENuCgIAAEIOAgIAAIANBDGoQ1YKAgAAaIANBIGokgICAgAAPC1MBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAIoAgghBEEAIQUgAyAFIAUgBBCqg4CAACACQRBqJICAgIAAIAMPC7ECAQt/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiwgBCABNgIoIAQgAjYCJCAEIAM2AiBBAC0AzKqJgABBAXEhBUEAIQYCQCAFQf8BcSAGQf8BcUZBAXFFDQBBtMOGgAAQz4OAgABBtMOGgAAQ0IOAgABBAxCFgICAACEHQQAgBzYCyKqJgABBASEIQQAgCDoAzKqJgAALIAQoAiAhCSAEQRhqIAkQ0YOAgAAaIARBADYCFEEAKALIqomAACEKIAQoAighCyAEKAIkIQwgBEEYahDSg4CAACENIAQgCiALIAwgBEEUaiANEIaAgIAAEPmCgIAANgIQIAQoAhQhDiAEQQxqIA4Q+oKAgAAaIAAgBCgCEBD7goCAACAEQQxqEPyCgIAAGiAEQTBqJICAgIAADwvnAgEDfyOAgICAAEHAAGshAyADJICAgIAAIAMgADYCPCADIAE2AjggAyACNgI0IANBLGpB9aqEgAAQ0oKAgAAgA0EkakH+hoSAABDSgoCAACADQQBBAXE6ACMgACADQSxqENOCgIAAIAMoAjghBCADQRhqIAQQo4SAgAAgA0EQaiADQSRqENOCgIAAIANBCGogA0EkahDTgoCAACAAQbeShYAAIANBGGoQ2YKAgAAgAygCNCEFIAMgBRCpg4CAABogAEHpu4WAACADEKiDgIAAIAMQ1YKAgAAaIABBkLyEgAAgA0EIahDXgoCAACAAQdWzhIAAIANBEGoQqIOAgAAgA0EBQQFxOgAjIANBCGoQ1YKAgAAaIANBEGoQ1YKAgAAaIANBGGoQ1YKAgAAaAkAgAy0AI0EBcQ0AIAAQ1YKAgAAaCyADQSRqENWCgIAAGiADQSxqENWCgIAAGiADQcAAaiSAgICAAA8LHAEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCxg4CAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxCLg4CAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQsoOAgAAQs4OAgAAgAigCHBD/goCAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEI6DgIAAIQIgAUEQaiSAgICAACACDwsJAEHQwoaAAA8LnwEBBn8jgICAgABBEGshASABJICAgIAAIAEgADYCCCABIAEoAggQtIOAgABBAHRBBGoQroyAgAA2AgQgASgCCBC0g4CAACECIAEoAgQgAjYCACABKAIEQQRqIQMgASgCCBC1g4CAACEEIAEoAggQtIOAgABBAHQhBQJAIAVFDQAgAyAEIAX8CgAACyABKAIEIQYgAUEQaiSAgICAACAGDwtGAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIIQMgAigCDCgCACADNgIAIAIoAgwhBCAEIAQoAgBBCGo2AgAPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMELaDgIAAIQIgAUEQaiSAgICAACACDws/AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBC3g4CAABC4g4CAACECIAFBEGokgICAgAAgAg8LYQEEfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwhAgJAAkAgAhC5g4CAAEEBcUUNACACELqDgIAAIQMMAQsgAhC7g4CAACEDCyADIQQgAUEQaiSAgICAACAEDwthAQR/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCECAkACQCACELmDgIAAQQFxRQ0AIAIQvIOAgAAhAwwBCyACEL2DgIAAIQMLIAMhBCABQRBqJICAgIAAIAQPCxwBAX8jgICAgABBEGshASABIAA2AgwgASgCDA8LOAEDfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQALQQd2IQJBACEDIAJB/wFxIANB/wFxR0EBcQ8LHwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIEDwsnAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwtAAtB/wBxQf8BcQ8LHwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIADws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBC+g4CAACECIAFBEGokgICAgAAgAg8LHAEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMDwtTAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwhAyACKAIIIQRBACEFIAMgBSAFIAQQwIOAgAAgAkEQaiSAgICAACADDwuxAgELfyOAgICAAEEwayEEIAQkgICAgAAgBCAANgIsIAQgATYCKCAEIAI2AiQgBCADNgIgQQAtALyqiYAAQQFxIQVBACEGAkAgBUH/AXEgBkH/AXFGQQFxRQ0AQZ/DhoAAEMGDgIAAQZ/DhoAAEMKDgIAAQQMQhYCAgAAhB0EAIAc2AriqiYAAQQEhCEEAIAg6ALyqiYAACyAEKAIgIQkgBEEYaiAJEMODgIAAGiAEQQA2AhRBACgCuKqJgAAhCiAEKAIoIQsgBCgCJCEMIARBGGoQxIOAgAAhDSAEIAogCyAMIARBFGogDRCGgICAABD5goCAADYCECAEKAIUIQ4gBEEMaiAOEPqCgIAAGiAAIAQoAhAQ+4KAgAAgBEEMahD8goCAABogBEEwaiSAgICAAA8LGQEBfyOAgICAAEEQayEBIAEgADYCDEECDws0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwQxYOAgAAhAiABQRBqJICAgIAAIAIPC4ABAQN/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhQgAiABNgIQIAIoAhQhAyACIAMQi4OAgAA2AgwgAigCECEEIAIgAkEMajYCHCACIAQ2AhggAigCHCACKAIYEMaDgIAAEMeDgIAAIAIoAhwQ/4KAgAAgAkEgaiSAgICAACADDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBCOg4CAACECIAFBEGokgICAgAAgAg8LCQBBoMOGgAAPCx8BAX8jgICAgABBEGshASABIAA2AgggASgCCCgCAA8LRgEDfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCCCEDIAIoAgwoAgAgAzYCACACKAIMIQQgBCAEKAIAQQhqNgIADwueAgELfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiRBAC0AxKqJgABBAXEhBEEAIQUCQCAEQf8BcSAFQf8BcUZBAXFFDQBBqMOGgAAQyYOAgABBqMOGgAAQyoOAgABBARCFgICAACEGQQAgBjYCwKqJgABBASEHQQAgBzoAxKqJgAALIAMoAiQhCCADQRhqIAgQy4OAgAAaIANBADYCFEEAKALAqomAACEJIAMoAiwhCiADKAIoIQsgA0EYahDMg4CAACEMIAkgCiALIANBFGogDBCGgICAABCIg4CAACADKAIUIQ0gA0EMaiANEPqCgIAAGhCJg4CAACADQQxqEPyCgIAAGiADQTBqJICAgIAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBDNg4CAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxCLg4CAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQxoOAgAAQx4OAgAAgAigCHBD/goCAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEI6DgIAAIQIgAUEQaiSAgICAACACDwsJAEGsw4aAAA8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQgYyAgAAhAiABQRBqJICAgIAAIAIPCxkBAX8jgICAgABBEGshASABIAA2AgxBAg8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMENODgIAAIQIgAUEQaiSAgICAACACDwuAAQEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIUIAIgATYCECACKAIUIQMgAiADEIuDgIAANgIMIAIoAhAhBCACIAJBDGo2AhwgAiAENgIYIAIoAhwgAigCGBCyg4CAABCzg4CAACACKAIcEP+CgIAAIAJBIGokgICAgAAgAw8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQjoOAgAAhAiABQRBqJICAgIAAIAIPCwkAQbjDhoAADwuOAQEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACIAIoAggQ1YOAgAAQuYGAgAA2AgQgAkEAQQFxOgADIAAgAigCBCACKAIIEKeDgIAAIAJBBGoQu4GAgAAgAkEBQQFxOgADAkAgAi0AA0EBcQ0AIAAQ1YKAgAAaCyACQRBqJICAgIAADws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBC1g4CAACECIAFBEGokgICAgAAgAg8LhAQBCn8jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABNgI4IAMgAjYCNCADQQA2AjAgA0EAOgAvIAIQ14OAgAAhBCADQQBBAXE6ABcgA0EAQQFxOgAWQQAhBSAEQQFxIQYgBSEHAkAgBg0AIAIQ2IOAgAAhCEEAIQkgCEEBcSEKIAkhByAKDQAgA0EYaiACENmDgIAAIANBAUEBcToAFyADQSBqIANBGGoQ2oOAgAAgA0EBQQFxOgAWIANBIGpB7qqEgAAQ24OAgAAhBwsgByELAkAgAy0AFkEBcUUNACADQSBqEI2NgIAAGgsCQCADLQAXQQFxRQ0AIANBGGoQ1YKAgAAaCwJAIAtBAXFFDQACQCACQYK+hYAAENyDgIAAQQFxRQ0AIANBDGogAkGCvoWAABDdg4CAACADQQxqEN6DgIAAIQwgA0EMahDVgoCAABogAyAMQQFxOgAVAkAgAy0AFUEBcUUNACADQQE6AC8gAyADQS9qNgIwCwsLIAMgAygCOBDVg4CAACADKAIwELqBgIAANgIIIAMoAgggAygCOBDVg4CAABDFgICAACADQQBBAXE6AAcgACADKAIIIAMoAjgQq4OAgAAgAygCCBDygICAACADQQFBAXE6AAcCQCADLQAHQQFxDQAgABDVgoCAABoLIANBwABqJICAgIAADws/AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBDbgoCAAEECRkEBcSECIAFBEGokgICAgAAgAg8LPwECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQ24KAgABBBEZBAXEhAiABQRBqJICAgIAAIAIPC0sBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggACACKAIIENuCgIAAEImAgIAAENqCgIAAGiACQRBqJICAgIAADwtMAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgghAyAAIAMQ24KAgABBACADEN+DgIAAIAJBEGokgICAgAAPC6YBAQV/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEIAIgAigCBBCmg4CAADYCAAJAAkAgAigCACACKAIIELaDgIAAR0EBcUUNACACQQBBAXE6AA8MAQsgAigCCCEDIAIoAgQhBCACKAIAIQUgAiADQQBBfyAEIAUQlI2AgABBAEZBAXE6AA8LIAItAA9BAXEhBiACQRBqJICAgIAAIAYPC90BAQV/I4CAgIAAQTBrIQIgAiSAgICAACACIAA2AiwgAiABNgIoIAIoAiwhAyACQRBqQfWqhIAAENKCgIAAIAJBGGogAkEQakHSq4WAABDgg4CAACACQSBqIAJBGGpBgoCEgAAQ4YOAgAAgAigCKCEEIAJBCGogBBCCg4CAABogAkEgakHJ94SAACADIAJBCGoQ4oOAgAAhBSACQQhqENWCgIAAGiACQSBqENWCgIAAGiACQRhqENWCgIAAGiACQRBqENWCgIAAGiAFQQFxIQYgAkEwaiSAgICAACAGDwuHAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCGCEEIAQQ24KAgAAhBSADKAIUIQYgA0EMaiAEIAYQ44OAgAAgACAFIANBDGoQ24KAgAAQioCAgAAQ2oKAgAAaIANBDGoQ1YKAgAAaIANBIGokgICAgAAPC0oBA38jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMIQIgAhDbgoCAAEEAIAIQ5IOAgABBAXEhAyABQRBqJICAgIAAIAMPC7ECAQt/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiwgBCABNgIoIAQgAjYCJCAEIAM2AiBBAC0A5KqJgABBAXEhBUEAIQYCQCAFQf8BcSAGQf8BcUZBAXFFDQBB+8OGgAAQkoSAgABB+8OGgAAQk4SAgABBAxCFgICAACEHQQAgBzYC4KqJgABBASEIQQAgCDoA5KqJgAALIAQoAiAhCSAEQRhqIAkQlISAgAAaIARBADYCFEEAKALgqomAACEKIAQoAighCyAEKAIkIQwgBEEYahCVhICAACENIAQgCiALIAwgBEEUaiANEIaAgIAAEJaEgIAANgIQIAQoAhQhDiAEQQxqIA4Q+oKAgAAaIAAgBCgCEBCOhICAACAEQQxqEPyCgIAAGiAEQTBqJICAgIAADwuHAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCGCEEIAQQ24KAgAAhBSADKAIUIQYgA0EMaiAEIAYQ7oOAgAAgACAFIANBDGoQ24KAgAAQioCAgAAQ2oKAgAAaIANBDGoQ1YKAgAAaIANBIGokgICAgAAPC4cBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIYIQQgBBDbgoCAACEFIAMoAhQhBiADQQxqIAQgBhDvg4CAACAAIAUgA0EMahDbgoCAABCKgICAABDagoCAABogA0EMahDVgoCAABogA0EgaiSAgICAAA8LZgECfyOAgICAAEEQayEEIAQkgICAgAAgBCAANgIMIAQgATYCCCAEIAI2AgQgBCADNgIAIAQoAgwQ24KAgAAgBCgCCCAEKAIEIAQoAgAQ8IOAgABBAXEhBSAEQRBqJICAgIAAIAUPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCCg4CAABogA0EQaiSAgICAAA8LuQIBDX8jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkQQAtAOyqiYAAQQFxIQRBACEFAkAgBEH/AXEgBUH/AXFGQQFxRQ0AQYTEhoAAEJiEgIAAQYTEhoAAEJmEgIAAQQMQhYCAgAAhBkEAIAY2AuiqiYAAQQEhB0EAIAc6AOyqiYAACyADKAIkIQggA0EYaiAIEJSEgIAAGiADQQA2AhRBACgC6KqJgAAhCSADKAIsIQogAygCKCELIANBGGoQlYSAgAAhDCADIAkgCiALIANBFGogDBCGgICAABD2g4CAAEEBcToAEyADKAIUIQ0gA0EMaiANEPqCgIAAGiADLQATQQFxEPeDgIAAIQ4gA0EMahD8goCAABogDkEBcSEPIANBMGokgICAgAAgDw8LqwEBAn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAigCGBC0g4CAACEDIAJBCGogAxC5goCAABogAigCGBDVg4CAACACQQhqELaBgIAAIAJBAEEBcToAByAAIAJBCGoQuoKAgAAQooOAgAAaIAIoAgwQsIyAgAAgAkEBQQFxOgAHAkAgAi0AB0EBcQ0AIAAQjY2AgAAaCyACQSBqJICAgIAADwurAQECfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGCACKAIYELSDgIAAIQMgAkEIaiADELmCgIAAGiACKAIYENWDgIAAIAJBCGoQt4GAgAAgAkEAQQFxOgAHIAAgAkEIahC6goCAABCig4CAABogAigCDBCwjICAACACQQFBAXE6AAcCQCACLQAHQQFxDQAgABCNjYCAABoLIAJBIGokgICAgAAPC4ACAQN/I4CAgIAAQcAAayEBIAEkgICAgAAgASAANgI8IAEQvIGAgAA2AjggARC9gYCAADYCNCABQQBBAXE6ADMgAUGDlIaAABCig4CAABogASgCNCECIAFBDGogASACEOiDgIAAIAFBGGogAUEMakGNlIaAABDog4CAACABKAI4IQMgAUEkaiABQRhqIAMQ6IOAgAAgACABQSRqQc+shoAAEOiDgIAAIAFBJGoQjY2AgAAaIAFBGGoQjY2AgAAaIAFBDGoQjY2AgAAaIAEQjY2AgAAaIAFBAUEBcToAMwJAIAEtADNBAXENACAAEI2NgIAAGgsgAUHAAGokgICAgAAPC1EBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCCCADKAIEEJaNgIAAEOmDgIAAGiADQRBqJICAgIAADwvfAQEIfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFCACKAIYIQMgAiADNgIcIAIoAhQhBCACQRNqIAQQm4SAgAAhBSADIAUpAgA3AgBBCCEGIAMgBmogBSAGaigCADYCACACQQhqQQA2AgAgAkIANwMAIAIoAhQhByAHIAIpAgA3AgBBCCEIIAcgCGogAiAIaigCADYCACACKAIUQQAQnISAgAACQCADELmDgIAAQQFxDQAgAyADELaDgIAAEJyEgIAACyACKAIcIQkgAkEgaiSAgICAACAJDwsQAEHQqomAABDrg4CAABoPC0IBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMIQIgAkGQgICAABDtg4CAABogAUEQaiSAgICAACACDwtdAEHmiISAAEGRgICAABD8g4CAAEGhqIWAAEGSgICAABD9g4CAAEHxhYSAAEGTgICAABD+g4CAAEHA+oWAAEGUgICAABD+g4CAAEGu7ISAAEGVgICAABD/g4CAAA8LYwECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAyACKAIINgIAIANBADYCBCACKAIIEYGAgIAAgICAgAAgAxDNi4CAACACQRBqJICAgIAAIAMPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBCCg4CAABogA0EQaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEIKDgIAAGiADQRBqJICAgIAADwtgAQJ/I4CAgIAAQRBrIQQgBCSAgICAACAEIAA2AgwgBCABNgIIIAQgAjYCBCAEIAM2AgAgBCgCDCAEKAIIIAQoAgQgBCgCABDxg4CAAEEBcSEFIARBEGokgICAgAAgBQ8LyQIBDn8jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCIEEALQDcqomAAEEBcSEFQQAhBgJAIAVB/wFxIAZB/wFxRkEBcUUNAEHAw4aAABDyg4CAAEHAw4aAABDzg4CAAEEBEIWAgIAAIQdBACAHNgLYqomAAEEBIQhBACAIOgDcqomAAAsgBCgCJCEJIAQoAiAhCiAEQRBqIAkgChD0g4CAABogBEEANgIMQQAoAtiqiYAAIQsgBCgCLCEMIAQoAighDSAEQRBqEPWDgIAAIQ4gBCALIAwgDSAEQQxqIA4QhoCAgAAQ9oOAgABBAXE6AAsgBCgCDCEPIARBBGogDxD6goCAABogBC0AC0EBcRD3g4CAACEQIARBBGoQ/IKAgAAaIBBBAXEhESAEQTBqJICAgIAAIBEPCxkBAX8jgICAgABBEGshASABIAA2AgxBAw8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEPiDgIAAIQIgAUEQaiSAgICAACACDwvHAQEGfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIYIAMgATYCFCADIAI2AhAgAygCGCEEIAMgBBD5g4CAADYCDCADKAIUIQUgAygCECEGIAMgA0EMajYCJCADIAU2AiAgAyAGNgIcIAMoAiQgAygCIBD6g4CAABCNg4CAACADKAIkIQcgAygCHCEIIAMgBzYCLCADIAg2AiggAygCLCADKAIoEIyDgIAAEI2DgIAAIAMoAiwQ/4KAgAAgA0EwaiSAgICAACAEDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBD7g4CAACECIAFBEGokgICAgAAgAg8LIwEBfyOAgICAAEEQayEBIAEgADkDCCABKwMIQQC3YkEBcQ8LHwEBfyOAgICAAEEQayEBIAEgADoADyABLQAPQQFxDwsJAEHEw4aAAA8LHAEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMDwtiAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASABKAIIENuCgIAANgIEAkAgASgCCBDfgoCAAEEBcUUNACABKAIEEIuAgIAACyABKAIEIQIgAUEQaiSAgICAACACDwscAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwPC5gBAQh/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAJBloCAgAA2AgAgAigCDCEDIAJBB2oQz4OAgAAhBCACQQdqENCDgIAAIQUgAigCABCBhICAACEGIAIoAgAhByACKAIIIQhBACEJIAMgBCAFIAYgByAIIAlBAXEgCUEBcRCMgICAACACQRBqJICAgIAADwuYAQEIfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACQZeAgIAANgIAIAIoAgwhAyACQQdqEIOEgIAAIQQgAkEHahCEhICAACEFIAIoAgAQhYSAgAAhBiACKAIAIQcgAigCCCEIQQAhCSADIAQgBSAGIAcgCCAJQQFxIAlBAXEQjICAgAAgAkEQaiSAgICAAA8LmAEBCH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkGYgICAADYCACACKAIMIQMgAkEHahCHhICAACEEIAJBB2oQiISAgAAhBSACKAIAEImEgIAAIQYgAigCACEHIAIoAgghCEEAIQkgAyAEIAUgBiAHIAggCUEBcSAJQQFxEIyAgIAAIAJBEGokgICAgAAPC5gBAQh/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAJBmYCAgAA2AgAgAigCDCEDIAJBB2oQi4SAgAAhBCACQQdqEIyEgIAAIQUgAigCABCNhICAACEGIAIoAgAhByACKAIIIQhBACEJIAMgBCAFIAYgByAIIAlBAXEgCUEBcRCMgICAACACQRBqJICAgIAADwuKAQEEfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGCACKAIcIQMgAigCGCEEIAJBBGogBBCOhICAACACQRBqIAJBBGogAxGCgICAAICAgIAAIAJBEGoQjIOAgAAhBSACQRBqENWCgIAAGiACQQRqEI2NgIAAGiACQSBqJICAgIAAIAUPCx0BAX8jgICAgABBEGshASABIAA2AgxB0MOGgAAPC7YBAQV/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADKAIsIQQgAygCKCEFIANBEGogBRCOhICAACADKAIkIQYgA0EIaiAGEPuCgIAAIANBHGogA0EQaiADQQhqIAQRg4CAgACAgICAACADQRxqEIyDgIAAIQcgA0EcahDVgoCAABogA0EIahDVgoCAABogA0EQahCNjYCAABogA0EwaiSAgICAACAHDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQMPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCPhICAACECIAFBEGokgICAgAAgAg8LHQEBfyOAgICAAEEQayEBIAEgADYCDEHgw4aAAA8LigEBBH8jgICAgABBMGshAiACJICAgIAAIAIgADYCLCACIAE2AiggAigCLCEDIAIoAighBCACQRBqIAQQjoSAgAAgAkEcaiACQRBqIAMRgoCAgACAgICAACACQRxqELKDgIAAIQUgAkEcahCNjYCAABogAkEQahCNjYCAABogAkEwaiSAgICAACAFDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCQhICAACECIAFBEGokgICAgAAgAg8LHQEBfyOAgICAAEEQayEBIAEgADYCDEHww4aAAA8LXgEDfyOAgICAAEEgayEBIAEkgICAgAAgASAANgIcIAEoAhwhAiABQRBqIAIRhICAgACAgICAACABQRBqELKDgIAAIQMgAUEQahCNjYCAABogAUEgaiSAgICAACADDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQEPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCRhICAACECIAFBEGokgICAgAAgAg8LHQEBfyOAgICAAEEQayEBIAEgADYCDEH4w4aAAA8LSgEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCAAIAIoAghBBGogAigCCCgCABCSg4CAABogAkEQaiSAgICAAA8LCQBB1MOGgAAPCwkAQejDhoAADwsJAEH0w4aAAA8LGQEBfyOAgICAAEEQayEBIAEgADYCDEECDws0AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwQl4SAgAAhAiABQRBqJICAgIAAIAIPC4ABAQN/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhQgAiABNgIQIAIoAhQhAyACIAMQi4OAgAA2AgwgAigCECEEIAIgAkEMajYCHCACIAQ2AhggAigCHCACKAIYEPqDgIAAEI2DgIAAIAIoAhwQ/4KAgAAgAkEgaiSAgICAACADDws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBCOg4CAACECIAFBEGokgICAgAAgAg8LHgEBfyOAgICAAEEQayEBIAEgADkDCCABKwMI/AMPCwkAQfzDhoAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCahICAACECIAFBEGokgICAgAAgAg8LCQBBiMSGgAAPC1gBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIIELmDgIAAQQFxDQAgAigCCBCdhICAAAsgAigCCCEDIAJBEGokgICAgAAgAw8LHgEBfyOAgICAAEEQayECIAIgADYCDCACIAE2AggPCxcBAX8jgICAgABBEGshASABIAA2AgwPCwkAEOqDgIAADwvPAwMEfwF+A38jgICAgABB4ABrIQIgAiSAgICAACACIAA2AlwgAiABNgJYAkACQCACKAJYQQBHQQFxDQAgABDRgoCAAAwBCyACQQBBAXE6AFcgABCghICAACACKAJYIQMgAkHEAGogAxDwgICAACACQcwAahogAiACKQJENwMAIAJBzABqIAIQkYOAgAAgAEHlq4WAACACQcwAahDUgoCAACACQcwAahDVgoCAABogAigCWEEEaiEEQQghBSAEIAVqKQIAIQYgBSACQShqaiAGNwMAIAIgBCkCADcDKCACQTxqGkEIIQcgByACQQhqaiAHIAJBKGpqKQIANwMAIAIgAikCKDcDCCACQTxqIAJBCGoQm4OAgAAgAEHI54SAACACQTxqENeCgIAAIAJBPGoQ1YKAgAAaIAIoAlgoAhQhCCACQSBqIAgQ8IKAgAAgAEHVs4SAACACQSBqEKiDgIAAIAJBIGoQ1YKAgAAaIAIoAlgoAhghCSACQRhqIAkQoYSAgAAgAEG57oSAACACQRhqENeCgIAAIAJBGGoQ1YKAgAAaIAJBAUEBcToAVwJAIAItAFdBAXENACAAENWCgIAAGgsLIAJB4ABqJICAgIAADws5AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgABCNgICAABDagoCAABogAUEQaiSAgICAAA8LiwIBAn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQAJAIAIoAhhBAEdBAXENACAAENGCgIAADAELIAJBAEEBcToAFyAAEKKEgIAAIAJBADYCEAJAA0AgAigCECACKAIYELeCgIAASUEBcUUNASACIAIoAhggAigCEBCygoCAADYCDAJAIAIoAgxBAEdBAXFFDQAgAigCDCEDIAJBBGogAxCjhICAACAAIAJBEGogAkEEahCkhICAACACQQRqENWCgIAAGgsgAiACKAIQQQFqNgIQDAALCyACQQFBAXE6ABcCQCACLQAXQQFxDQAgABDVgoCAABoLCyACQSBqJICAgIAADws5AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgABCOgICAABDagoCAABogAUEQaiSAgICAAA8LuwUBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQAJAIAIoAghBAEdBAXENACAAENGCgIAADAELIAIoAggoAgAhAyADQR5LGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAw4fAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8LIAAgAigCCBCfhICAAAwfCyAAIAIoAggQpYSAgAAMHgsgACACKAIIEKaEgIAADB0LIAAgAigCCBCphICAAAwcCyAAIAIoAggQqoSAgAAMGwsgACACKAIIEKyEgIAADBoLIAAgAigCCBCthICAAAwZCyAAIAIoAggQroSAgAAMGAsgACACKAIIEK+EgIAADBcLIAAgAigCCBCwhICAAAwWCyAAIAIoAggQsYSAgAAMFQsgACACKAIIELKEgIAADBQLIAAgAigCCBCzhICAAAwTCyAAIAIoAggQtISAgAAMEgsgACACKAIIELWEgIAADBELIAAgAigCCBC2hICAAAwQCyAAIAIoAggQt4SAgAAMDwsgACACKAIIELiEgIAADA4LIAAgAigCCBC5hICAAAwNCyAAIAIoAggQuoSAgAAMDAsgACACKAIIELuEgIAADAsLIAAgAigCCBC8hICAAAwKCyAAIAIoAggQvYSAgAAMCQsgACACKAIIEL6EgIAADAgLIAAgAigCCBC/hICAAAwHCyAAIAIoAggQwISAgAAMBgsgACACKAIIEMGEgIAADAULIAAgAigCCBDChICAAAwECyAAIAIoAggQw4SAgAAMAwsgACACKAIIEMSEgIAADAILIAAgAigCCBDFhICAAAwBCyAAENGCgIAACyACQRBqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ24KAgAAhBSADKAIYIQYgA0EMaiAEIAYQyoSAgAAgBSADQQxqENuCgIAAIAQgAygCFBDegoCAABDbgoCAABCDgICAACADQQxqENWCgIAAGiADQSBqJICAgIAADwvPAwMEfwF+A38jgICAgABB4ABrIQIgAiSAgICAACACIAA2AlwgAiABNgJYAkACQCACKAJYQQBHQQFxDQAgABDRgoCAAAwBCyACQQBBAXE6AFcgABCghICAACACKAJYIQMgAkHEAGogAxDwgICAACACQcwAahogAiACKQJENwMAIAJBzABqIAIQkYOAgAAgAEHlq4WAACACQcwAahDUgoCAACACQcwAahDVgoCAABogAigCWEEEaiEEQQghBSAEIAVqKQIAIQYgBSACQShqaiAGNwMAIAIgBCkCADcDKCACQTxqGkEIIQcgByACQQhqaiAHIAJBKGpqKQIANwMAIAIgAikCKDcDCCACQTxqIAJBCGoQm4OAgAAgAEHI54SAACACQTxqENeCgIAAIAJBPGoQ1YKAgAAaIAIoAlgoAhQhCCACQSBqIAgQ8IKAgAAgAEHVs4SAACACQSBqEKiDgIAAIAJBIGoQ1YKAgAAaIAIoAlgoAhghCSACQRhqIAkQkIOAgAAgAEG6kYSAACACQRhqENaCgIAAIAJBGGoQ1YKAgAAaIAJBAUEBcToAVwJAIAItAFdBAXENACAAENWCgIAAGgsLIAJB4ABqJICAgIAADwupBQMEfwF+B38jgICAgABBgAFrIQIgAiSAgICAACACIAA2AnwgAiABNgJ4AkACQCACKAJ4QQBHQQFxDQAgABDRgoCAAAwBCyACQQBBAXE6AHcgABCghICAACACKAJ4IQMgAkHkAGogAxDwgICAACACQewAahogAiACKQJkNwMAIAJB7ABqIAIQkYOAgAAgAEHlq4WAACACQewAahDUgoCAACACQewAahDVgoCA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CRCjhICAACAAQd6NhYAAIAJB2ABqENeCgIAAIAJB2ABqENWCgIAAGiACKAKYASgCHCEKIAJB0ABqIAoQoYOAgAAgAEG6roWAACACQdAAahDXgoCAACACQdAAahDVgoCAABogAigCmAEoAiAhCyACQcgAaiALEKGEgIAAIABB3oWEgAAgAkHIAGoQ1IKAgAAgAkHIAGoQ1YKAgAAaIAIoApgBKAIkIQwgAkHAAGogDBCjhICAACAAQf+NhYAAIAJBwABqEKuEgIAAIAJBwABqENWCgIAAGiACKAKYAS0AKCENIAJBAUEAIA1BAXEbQQFxOgA/IABBu8SFgAAgAkE/ahCnhICAACACKAKYASgCLCEOIAJBLGogDhCSgYCAACACQTRqGiACIAIpAiw3AyAgAkE0aiACQSBqEJGDgIAAIABB6buFgAAgAkE0ahCog4CAACACQTRqENWCgIAAGiACQQFBAXE6AJcBAkAgAi0AlwFBAXENACAAENWCgIAAGgsLIAJBoAFqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ24KAgAAhBSADKAIYIQYgA0EMaiAEIAYQ7oOAgAAgBSADQQxqENuCgIAAIAQgAygCFBDegoCAABDbgoCAABCDgICAACADQQxqENWCgIAAGiADQSBqJICAgIAADwv2BAMEfwF+Bn8jgICAgABBgAFrIQIgAiSAgICAACACIAA2AnwgAiABNgJ4AkACQCACKAJ4QQBHQQFxDQAgABDRgoCAAAwBCyACQQBBAXE6AHcgABCghICAACACKAJ4IQMgAkHkAGogAxDwgICAACACQewAahogAiACKQJkNwMIIAJB7ABqIAJBCGoQkYOAgAAgAEHlq4WAACACQewAahDUgoCAACACQewAahDVgoCAABogAigCeEEEaiEEQQghBSAEIAVqKQIAIQYgBSACQcgAamogBjcDACACIAQpAgA3A0ggAkHcAGoaQQghByAHIAJBEGpqIAcgAkHIAGpqKQIANwMAIAIgAikCSDcDECACQdwAaiACQRBqEJuDgIAAIABByOeEgAAgAkHcAGoQ14KAgAAgAkHcAGoQ1YKAgAAaIAIoAngoAhQhCCACQcAAaiAIEPCCgIAAIABB1bOEgAAgAkHA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8ABrIQIgAiSAgICAACACIAA2AmwgAiABNgJoAkACQCACKAJoQQBHQQFxDQAgABDRgoCAAAwBCyACQQBBAXE6AGcgABCghICAACACKAJoIQMgAkHUAGogAxDwgICAACACQdwAahogAiACKQJUNwMAIAJB3ABqIAIQkYOAgAAgAEHlq4WAACACQdwAahDUgoCAACACQdwAahDVgoCAABogAigCaEEEaiEEQQghBSAEIAVqKQIAIQYgBSACQThqaiAGNwMAIAIgBCkCADcDOCACQcwAahpBCCEHIAcgAkEIamogByACQThqaikCADcDACACIAIpAjg3AwggAkHMAGogAkEIahCbg4CAACAAQcjnhIAAIAJBzABqENeCgIAAIAJBzABqENWCgIAAGiACKAJoKAIUIQggAkEwaiAIEPCCgIAAIABB1bOEgAAgAkEwahCog4CAACACQTBqENWCgIAAGiACKAJoKAIYIQkgAkEoaiAJEKGDgIAAIABB5Y+EgAAgAkEoahDlgoCAACACQShqENWCgIAAGiACKAJoKAIcIQogAkEgaiAKEKGEgIAAIABBue6EgAAgAkEgahDXgoCAACACQSBqENWCgIAAGiACKAJoKAIgIQsgAkEYaiALEKGDgIAAIABB4sGFgAAgAkEYahDYgoCAACACQRhqENWCgIAAGiACQQFBAXE6AGcCQCACLQBnQQFxDQAgABDVgoCAABoLCyACQfAAaiSAgICAAA8LvwQDBH8BfgV/I4CAgIAAQfAAayECIAIkgICAgAAgAiAANgJsIAIgATYCaAJAAkAgAigCaEEAR0EBcQ0AIAAQ0YKAgAAMAQsgAkEAQQFxOgBnIAAQoISAgAAgAigCaCEDIAJB1ABqIAMQ8ICAgAAgAkHcAGoaIAIgAikCVDcDACACQdwAaiACEJGDgIAAIABB5auFgAAgAkHcAGoQ1IKAgAAgAkHcAGoQ1YKAgAAaIAIoAmhBBGohBEEIIQUgBCAFaikCACEGIAUgAkE4amogBjcDACACIAQpAgA3AzggAkHMAGoaQQghByAHIAJBCGpqIAcgAkE4amopAgA3AwAgAiACKQI4NwMIIAJBzABqIAJBCGoQm4OAgAAgAEHI54SAACACQcwAahDXgoCAACACQcwAahDVgoCAABogAigCaCgCFCEIIAJBMGogCBDwgoCAACAAQdWzhIAAIAJBMGoQqIOAgAAgAkEwahDVgoCAABogAigCaCgCGCEJIAJBKGogCRChg4CAACAAQbyLhYAAIAJBKGoQ2IKAgAAgAkEoahDVgoCAABogAigCaCgCHCEKIAJBIGogChChhICAACAAQbnuhIAAIAJBIGoQ14KAgAAgAkEgahDVgoCAABogAigCaCgCICELIAJBGGogCxChg4CAACAAQZqJhYAAIAJBGGoQ2IKAgAAgAkEYahDVgoCAABogAkEBQQFxOgBnAkAgAi0AZ0EBcQ0AIAAQ1YKAgAAaCwsgAkHwAGokgICAgAAPC78EAwR/AX4FfyOAgICAAEHwAGshAiACJICAgIAAIAIgADYCbCACIAE2AmgCQAJAIAIoAmhBAEdBAXENACAAENGCgIAADAELIAJBAEEBcToAZyAAEKCEgIAAIAIoAmghAyACQdQAaiADEPCAgIAAIAJB3ABqGiACIAIpAlQ3AwAgAkHcAGogAhCRg4CAACAAQeWrhYAAIAJB3ABqENSCgIAAIAJB3ABqENWCgIAAGiACKAJoQQRqIQRBCCEFIAQgBWopAgAhBiAFIAJBOGpqIAY3AwAgAiAEKQIANwM4IAJBzABqGkEIIQcgByACQQhqaiAHIAJBOGpqKQIANwMAIAIgAikCODcDCCACQcwAaiACQQhqEJuDgIAAIABByOeEgAAgAkHMAGoQ14KAgAAgAkHMAGoQ1YKAgAAaIAIoAmgoAhQhCCACQTBqIAgQ8IKAgAAgAEHVs4SAACACQTBqEKiDgIAAIAJBMGoQ1YKAgAAaIAIoAmgoAhghCSACQShqIAkQoYOAgAAgAEG8i4WAACACQShqENiCgIAAIAJBKGoQ1YKAgAAaIAIoAmgoAhwhCiACQSBqIAoQoYSAgAAgAEG57oSAACACQSBqENeCgIAAIAJBIGoQ1YKAgAAaIAIoAmgoAiAhCyACQRhqIAsQoYOAgAAgAEGaiYWAACACQRhqENiCgIAAIAJBGGoQ1YKAgAAaIAJBAUEBcToAZwJAIAItAGdBAXENACAAENWCgIAAGgsLIAJB8ABqJICAgIAADwu/BAMEfwF+BX8jgICAgABB8ABrIQIgAiSAgICAACACIAA2AmwgAiABNgJoAkACQCACKAJoQQBHQQFxDQAgABDRgoCAAAwBCyACQQBBAXE6AGcgABCghICAACACKAJoIQMgAkHUAGogAxDwgICAACACQdwAahogAiACKQJUNwMAIAJB3ABqIAIQkYOAgAAgAEHlq4WAACACQdwAahDUgoCAACACQdwAahDVgoCAABogAigCaEEEaiEEQQghBSAEIAVqKQIAIQYgBSACQThqaiAGNwMAIAIgBCkCADcDOCACQcwAahpBCCEHIAcgAkEIamogByACQThqaikCADcDACACIAIpAjg3AwggAkHMAGogAkEIahCbg4CAACAAQcjnhIAAIAJBzABqENeCgIAAIAJBzABqENWCgIAAGiACKAJoKAIUIQggAkEwaiAIEPCCgIAAIABB1bOEgAAgAkEwahCog4CAACACQTBqENWCgIAAGiACKAJoKAIYIQkgAkEoaiAJEKGDgIAAIABBvIuFgAAgAkEoahDYgoCAACACQShqENWCgIAAGiACKAJoKAIcIQogAkEgaiAKEKGEgIAAIABBue6EgAAgAkEgahDXgoCAACACQSBqENWCgIAAGiACKAJoKAIgIQsgAkEYaiALEKGDgIAAIABBmomFgAAgAkEYahDYgoCAACACQRhqENWCgIAAGiACQQFBAXE6AGcCQCACLQBnQQFxDQAgABDVgoCAABoLCyACQfAAaiSAgICAAA8LzwMDBH8BfgN/I4CAgIAAQeAAayECIAIkgICAgAAgAiAANgJcIAIgATYCWAJAAkAgAigCWEEAR0EBcQ0AIAAQ0YKAgAAMAQsgAkEAQQFxOgBXIAAQoISAgAAgAigCWCEDIAJBxABqIAMQ8ICAgAAgAkHMAGoaIAIgAikCRDcDACACQcwAaiACEJGDgIAAIABB5auFgAAgAkHMAGoQ1IKAgAAgAkHMAGoQ1YKAgAAaIAIoAlhBBGohBEEIIQUgBCAFaikCACEGIAUgAkEoamogBjcDACACIAQpAgA3AyggAkE8ahpBCCEHIAcgAkEIamogByACQShqaikCADcDACACIAIpAig3AwggAkE8aiACQQhqEJuDgIAAIABByOeEgAAgAkE8ahDXgoCAACACQTxqENWCgIAAGiACKAJYKAIUIQggAkEgaiAIEPCCgIAAIABB1bOEgAAgAkEgahCog4CAACACQSBqENWCgIAAGiACKAJYKAIYIQkgAkEYaiAJEKGDgIAAIABBt5KFgAAgAkEYahDZgoCAACAC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ACACQcgAahDYgoCAACACQcgAahDVgoCAABogAigCiAEoAhwhCiACQcAAaiAKEKGDgIAAIABBupGEgAAgAkHAAGoQ1oKAgAAgAkHAAGoQ1YKAgAAaIAIoAogBKAIgIQsgAkE4aiALEKGDgIAAIABBmomFgAAgAkE4ahDYgoCAACACQThqENWCgIAAGiACKAKIASgCJCEMIAJBMGogDBChhICAACAAQbnuhIAAIAJBMGoQ14KAgAAgAkEwahDVgoCAABogAigCiAEoAighDSACQShqIA0QoYSAgAAgAEGyt4SAACACQShqEMaEgIAAIAJBKGoQ1YKAgAAaIAIoAogBKAIsIQ4gAkEgaiAOEKOEgIAAIABBjqWFgAAgAkEgahDYgoCAACACQSBqENWCgIAAGiACKAKIASgCMCEPIAJBGGogDxCjhICAACAAQc66hYAAIAJBGGoQ14KAgAAgAkEYahDVgoCAABogAkEBQQFxOgCHAQJAIAItAIcBQQFxDQAgABDVgoCAABoLCyACQZABaiSAgICAAA8LsgYDBH8Bfgl/I4CAgIAAQZABayECIAIkgICAgAAgAiAANgKMASACIAE2AogBAkACQCACKAKIAUEAR0EBcQ0AIAAQ0YKAgAAMAQsgAkEAQQFxOgCHASAAEKCEgIAAIAIoAogBIQMgAkH0AGogAxDwgICAACACQfwAahogAiACKQJ0NwMAIAJB/ABqIAIQkYOAgAAgAEHlq4WAACACQfwAahDUgoCAACACQfwAahDVgoCAABogAigCiAFBBGohBEEIIQUgBCAFaikCACEGIAUgAkHYAGpqIAY3AwAgAiAEKQIANwNYIAJB7ABqGkEIIQcgByACQQhqaiAHIAJB2ABqaikCADcDACACIAIpAlg3AwggAkHsAGogAkEIahCbg4CAACAAQcjnhIAAIAJB7ABqENeCgIAAIAJB7ABqENWCgIAAGiACKAKIASgCFCEIIAJB0ABqIAgQ8IKAgAAgAEHVs4SAACACQdAAahCog4CAACACQdAAahDVgoCAABogAigCiAEoAhghCSACQcgAaiAJEKGDgIAAIABBvIuFgAAgAkHIAGoQ2IKAgAAgAkHIAGoQ1YKAgAAaIAIoAogBKAIcIQogAkHAAGogChChg4CAACAAQbqRhIAAIAJBwABqENaCgIAAIAJBwABqENWCgIAAGiACKAKIASgCICELIAJBOGogCxChg4CAACAAQZqJhYAAIAJBOGoQ2IKAgAAgAkE4ahDVgoCAABogAigCiAEoAiQhDCACQTBqIAwQoYSAgAAgAEG57oSAACACQTBqENeCgIAAIAJBMGoQ1YKAgAAaIAIoAogBKAIoIQ0gAkEoaiANEKGEgIAAIABBsreEgAAgAkEoahDGhICAACACQShqENWCgIAAGiACKAKIASgCLCEOIAJBIGogDhCjhICAACAAQY6lhYAAIAJBIGoQ2IKAgAAgAkEgahDVgoCAABogAigCiAEoAjAhDyACQRhqIA8Qo4SAgAAgAEHOuoWAACACQRhqENeCgIAAIAJBGGoQ1YKAgAAaIAJBAUEBcToAhwECQCACLQCHAUEBcQ0AIAAQ1YKAgAAaCwsgAkGQAWokgICAgAAPC7AFAwR/AX4HfyOAgICAAEGAAWshAiACJICAgIAAIAIgADYCfCACIAE2AngCQAJAIAIoAnhBAEdBAXENACAAENGCgIAADAELIAJBAEEBcToAdyAAEKCEgIAAIAIoAnghAyACQeQAaiADEPCAgIAAIAJB7ABqGiACIAIpAmQ3AwAgAkHsAGogAhCRg4CAACAAQeWrhYAAIAJB7ABqENSCgIAAIAJB7ABqENWCgIAAGiACKAJ4QQRqIQRBCCEFIAQgBWopAgAhBiAFIAJByABqaiAGNwMAIAIgBCkCADcDSCACQdwAahpBCCEHIAcgAkEIamogByACQcgAamopAgA3AwAgAiACKQJINwMIIAJB3ABqIAJBCGoQm4OAgAAgAEHI54SAACACQdwAahDXgoCAACACQdwAahDVgoCAABogAigCeCgCFCEIIAJBwABqIAgQ8IKAgAAgAEHVs4SAACACQcAAahCog4CAACACQcAAahDVgoCAABogAigCeCgCGCEJIAJBOGogCRChg4CAACAAQbyLhYAAIAJBOGoQ2IKAgAAgAkE4ahDVgoCAABogAigCeCgCHCEKIAJBMGogChChg4CAACAAQbqRhIAAIAJBMGoQ1oKAgAAgAkEwahDVgoCAABogAigCeCgCICELIAJBKGogCxChg4CAACAAQZqJhYAAIAJBKGoQ2IKAgAAgAkEoahDVgoCAABogAigCeCgCJCEMIAJBIGogDBChhICAACAAQYmuhIAAIAJBIGoQxoSAgAAgAkEgahDVgoCAABogAigCeCgCKCENIAJBGGogDRCjhICAACAAQc66hYAAIAJBGGoQ14KAgAAgAkEYahDVgoCAABogAkEBQQFxOgB3AkAgAi0Ad0EBcQ0AIAAQ1YKAgAAaCwsgAkGAAWokgICAgAAPC7AFAwR/AX4HfyOAgICAAEGAAWshAiACJICAgIAAIAIgADYCfCACIAE2AngCQAJAIAIoAnhBAEdBAXENACAAENGCgIAADAELIAJBAEEBcToAdyAAEKCEgIAAIAIoAnghAyACQeQAaiADEPCAgIAAIAJB7ABqGiACIAIpAmQ3AwAgAkHsAGogAhCRg4CAACAAQeWrhYAAIAJB7ABqENSCgIAAIAJB7ABqENWCgIAAGiACKAJ4QQRqIQRBCCEFIAQgBWopAgAhBiAFIAJByABqaiAGNwMAIAIgBCkCADcDSCACQdwAahpBCCEHIAcgAkEIamogByACQcgAamopAgA3AwAgAiACKQJINwMIIAJB3ABqIAJBCGoQm4OAgAAgAEHI54SAACACQdwAahDXgoCAACACQdwAahDVgoCAABogAigCeCgCFCEIIAJBwABqIAgQ8IKAgAAgAEHVs4SAACACQcAAahCog4CAACACQcAAahDVgoCAABogAigCeCgCGCEJIAJBOGogCRChg4CAACAAQbyLhYAAIAJBOGoQ2IKAgAAgAkE4ahDVgoCAABogAigCeCgCHCEKIAJBMGogChChg4CAACAAQbqRhIAAIAJBMGoQ1oKAgAAgAkEwahDVgoCAABogAigCeCgCICELIAJBKGogCxChg4CAACAAQZqJhYAAIAJBKGoQ2IKAgAAgAkEoahDVgoCAABogAigCeCgCJCEMIAJBIGogDBChhICAACAAQYmuhIAAIAJBIGoQxoSAgAAgAkEgahDVgoCAABogAigCeCgCKCENIAJBGGogDRCjhICAACAAQc66hYAAIAJBGGoQ14KAgAAgAkEYahDVgoCAABogAkEBQQFxOgB3AkAgAi0Ad0EBcQ0AIAAQ1YKAgAAaCwsgAkGAAWokgICAgAAPC7AFAwR/AX4HfyOAgICAAEGAAWshAiACJICAgIAAIAIgADYCfCACIAE2AngCQAJAIAIoAnhBAEdBAXENACAAENGCgIAADAELIAJBAEEBcToAdyAAEKCEgIAAIAIoAnghAyACQeQAaiADEPCAgIAAIAJB7ABqGiACIAIpAmQ3AwAgAkHsAGogAhCRg4CAACAAQeWrhYAAIAJB7ABqENSCgIAAIAJB7ABqENWCgIAAGiACKAJ4QQRqIQRBCCEFIAQgBWopAgAhBiAFIAJByABqaiAGNwMAIAIgBCkCADcDSCACQdwAahpBCCEHIAcgAkEIamogByACQcgAamopAgA3AwAgAiACKQJINwMIIAJB3ABqIAJBCGoQm4OAgAAgAEHI54SAACACQdwAahDXgoCAACACQdwAahDVgoCAABogAigCeCgCFCEIIAJBwABqIAgQ8IKAgAAgAEHVs4SAACACQcAAahCog4CAACACQcAAahDVgoCAABogAigCeCgCGCEJIAJBOGogCRChg4CAACAAQbyLhYAAIAJBOGoQ2IKAgAAgAkE4ahDVgoCAABogAigCeCgCHCEKIAJBMGogChChg4CAACAAQbqRhIAAIAJBMGoQ1oKAgAAgAkEwahDVgoCAABogAigCeCgCICELIAJBKGogCxChg4CAACAAQZqJhYAAIAJBKGoQ2IKAgAAgAkEoahDVgoCAABogAigCeCgCJCEMIAJBIGogDBChhICAACAAQYmuhIAAIAJBIGoQxoSAgAAgAkEgahDVgoCAABogAigCeCgCKCENIAJBGGogDRCjhICAACAAQc66hYAAIAJBGGoQ14KAgAAgAkEYahDVgoCAABogAkEBQQFxOgB3AkAgAi0Ad0EBcQ0AIAAQ1YKAgAAaCwsgAkGAAWokgICAgAAPC7AFAwR/AX4HfyOAgICAAEGAAWshAiACJICAgIAAIAIgADYCfCACIAE2AngCQAJAIAIoAnhBAEdBAXENACAAENGCgIAADAELIAJBAEEBcToAdyAAEKCEgIAAIAIoAnghAyACQeQAaiADEPCAgIAAIAJB7ABqGiACIAIpAmQ3AwAgAkHsAGogAhCRg4CAACAAQeWrhYAAIAJB7ABqENSCgIAAIAJB7ABqENWCgIAAGiACKAJ4QQRqIQRBCCEFIAQgBWopAgAhBiAFIAJByABqaiAGNwMAIAIgBCkCADcDSCACQdwAahpBCCEHIAcgAkEIamogByACQcgAamopAgA3AwAgAiACKQJINwMIIAJB3ABqIAJBCGoQm4OAgAAgAEHI54SAACACQdwAahDXgoCAACACQdwAahDVgoCAABogAigCeCgCFCEIIAJBwABqIAgQ8IKAgAAgAEHVs4SAACACQcAAahCog4CAACACQcAAahDVgoCAABogAigCeCgCGCEJIAJBOGogCRChg4CAACAAQbyLhYAAIAJBOGoQ2IKAgAAgAkE4ahDVgoCAABogAigCeCgCHCEKIAJBMGogChChg4CAACAAQbqRhIAAIAJBMGoQ1oKAgAAgAkEwahDVgoCAABogAigCeCgCICELIAJBKGogCxChg4CAACAAQZqJhYAAIAJBKGoQ2IKAgAAgAkEoahDVgoCAABogAigCeCgCJCEMIAJBIGogDBChhICAACAAQYmuhIAAIAJBIGoQxoSAgAAgAkEgahDVgoCAABogAigCeCgCKCENIAJBGGogDRCjhICAACAAQZKRhIAAIAJBGGoQxoSAgAAgAkEYahDVgoCAABogAkEBQQFxOgB3AkAgAi0Ad0EBcQ0AIAAQ1YKAgAAaCwsgAkGAAWokgICAgAAPC/0EAwR/AX4GfyOAgICAAEGAAWshAiACJICAgIAAIAIgADYCfCACIAE2AngCQAJAIAIoAnhBAEdBAXENACAAENGCgIAADAELIAJBAEEBcToAdyAAEKCEgIAAIAIoAnghAyACQeQAaiADEPCAgIAAIAJB7ABqGiACIAIpAmQ3AwggAkHsAGogAkEIahCRg4CAACAAQeWrhYAAIAJB7ABqENSCgIAAIAJB7ABqENWCgIAAGiACKAJ4QQRqIQRBCCEFIAQgBWopAgAhBiAFIAJByABqaiAGNwMAIAIgBCkCADcDSCACQdwAahpBCCEHIAcgAkEQamogByACQcgAamopAgA3AwAgAiACKQJINwMQIAJB3ABqIAJBEGoQm4OAgAAgAEHI54SAACACQdwAahDXgoCAACACQdwAahDVgoCAABogAigCeCgCFCEIIAJBwABqIAgQ8IKAgAAgAEHVs4SAACACQcAAahCog4CAACACQcAAahDVgoCAABogAigCeCgCGCEJIAJBOGogCRChg4CAACAAQbyLhYAAIAJBOGoQ2IKAgAAgAkE4ahDVgoCAABogAigCeCgCHCEKIAJBMGogChChg4CAACAAQbqRhIAAIAJBMGoQ1oKAgAAgAkEwahDVgoCAABogAigCeCgCICELIAJBKGogCxChg4CAACAAQZqJ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IABB1bOEgAAgAkHAAGoQqIOAgAAgAkHAAGoQ1YKAgAAaIAIoAngoAhghCSACQThqIAkQoYOAgAAgAEG8i4WAACACQThqENiCgIAAIAJBOGoQ1YKAgAAaIAIoAngoAhwhCiACQTBqIAoQoYOAgAAgAEG6kYSAACACQTBqENaCgIAAIAJBMGoQ1YKAgAAaIAIoAngoAiAhCyACQShqIAsQoYOAgAAgAEGaiYWAACACQShqENiCgIAAIAJBKGoQ1YKAgAAaIAIoAngoAiQhDCACQSBqIAwQoYSAgAAgAEGJroSAACACQSBqEMaEgIAAIAJBIGoQ1YKAgAAaIAJBAUEBcToAdwJAIAItAHdBAXENACAAENWCgIAAGgsLIAJBgAFqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ24KAgAAhBSADKAIYIQYgA0EMaiAEIAYQyISAgAAgBSADQQxqENuCgIAAIAQgAygCFBDegoCAABDbgoCAABCDgICAACADQQxqENWCgIAAGiADQSBqJICAgIAADwuvAQEGfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ24KAgAAhBSADKAIYIQYgA0EMaiAEIAYQmoOAgAAgA0EMahDbgoCAACEHIAMoAhQhCCADQQRqIAQgCBCohICAACAFIAcgA0EEahDbgoCAABCDgICAACADQQRqENWCgIAAGiADQQxqENWCgIAAGiADQSBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQgoOAgAAaIANBEGokgICAgAAPC68BAQZ/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDbgoCAACEFIAMoAhghBiADQQxqIAQgBhDjgoCAACADQQxqENuCgIAAIQcgAygCFCEIIANBBGogBCAIEKiEgIAAIAUgByADQQRqENuCgIAAEIOAgIAAIANBBGoQ1YKAgAAaIANBDGoQ1YKAgAAaIANBIGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBDUhICAABogA0EQaiSAgICAAA8LUwEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAigCCCEEQQAhBSADIAUgBSAEEMyEgIAAIAJBEGokgICAgAAgAw8LsQIBC38jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCIEEALQD0qomAAEEBcSEFQQAhBgJAIAVB/wFxIAZB/wFxRkEBcUUNAEGQxIaAABDNhICAAEGQxIaAABDOhICAAEEDEIWAgIAAIQdBACAHNgLwqomAAEEBIQhBACAIOgD0qomAAAsgBCgCICEJIARBGGogCRDPhICAABogBEEANgIUQQAoAvCqiYAAIQogBCgCKCELIAQoAiQhDCAEQRhqENCEgIAAIQ0gBCAKIAsgDCAEQRRqIA0QhoCAgAAQ+YKAgAA2AhAgBCgCFCEOIARBDGogDhD6goCAABogACAEKAIQEPuCgIAAIARBDGoQ/IKAgAAaIARBMGokgICAgAAPCxkBAX8jgICAgABBEGshASABIAA2AgxBAg8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMENGEgIAAIQIgAUEQaiSAgICAACACDwuJAQEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIUIAIgATYCECACKAIUIQMgAiADEIuDgIAANgIMIAIoAhAhBCACIAJBDGo2AhwgAiAENgIYIAIoAhwgAigCGC0AAEEBcRDShICAAEEBcRDThICAACACKAIcEP+CgIAAIAJBIGokgICAgAAgAw8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQjoOAgAAhAiABQRBqJICAgIAAIAIPCwkAQZTEhoAADwsfAQF/I4CAgIAAQRBrIQEgASAAOgAOIAEtAA5BAXEPC0kBA38jgICAgABBEGshAiACIAA2AgwgAiABOgALIAItAAtBAXEhAyACKAIMKAIAIAM2AgAgAigCDCEEIAQgBCgCAEEIajYCAA8LUwEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAigCCCEEQQAhBSADIAUgBSAEENWEgIAAIAJBEGokgICAgAAgAw8LsQIBC38jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCIEEALQD8qomAAEEBcSEFQQAhBgJAIAVB/wFxIAZB/wFxRkEBcUUNAEGcxIaAABDWhICAAEGcxIaAABDXhICAAEEDEIWAgIAAIQdBACAHNgL4qomAAEEBIQhBACAIOgD8qomAAAsgBCgCICEJIARBGGogCRDYhICAABogBEEANgIUQQAoAviqiYAAIQogBCgCKCELIAQoAiQhDCAEQRhqENmEgIAAIQ0gBCAKIAsgDCAEQRRqIA0QhoCAgAAQ+YKAgAA2AhAgBCgCFCEOIARBDGogDhD6goCAABogACAEKAIQEPuCgIAAIARBDGoQ/IKAgAAaIARBMGokgICAgAAPCxkBAX8jgICAgABBEGshASABIAA2AgxBAg8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMENqEgIAAIQIgAUEQaiSAgICAACACDwuAAQEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIUIAIgATYCECACKAIUIQMgAiADEIuDgIAANgIMIAIoAhAhBCACIAJBDGo2AhwgAiAENgIYIAIoAhwgAigCGBDbhICAABDchICAACACKAIcEP+CgIAAIAJBIGokgICAgAAgAw8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQjoOAgAAhAiABQRBqJICAgIAAIAIPCwkAQaDEhoAADwsfAQF/I4CAgIAAQRBrIQEgASAANgIIIAEoAggoAgAPC0YBA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgghAyACKAIMKAIAIAM2AgAgAigCDCEEIAQgBCgCAEEIajYCAA8L0S4BA38jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIIIQIgAkHBAksaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOwgIAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wGAAoECggKDAoQChQKGAocCiAKJAooCiwKM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hIAANgIMDFcLIAFB8LqEgAA2AgwMVgsgAUGjqYSAADYCDAxVCyABQZHbhYAANgIMDFQLIAFBsI6EgAA2AgwMUwsgAUGovYWAADYCDAxSCyABQZ2qhIAANgIMDFELIAFB1++EgAA2AgwMUAsgAUHV7YSAADYCDAxPCyABQaSIhYAANgIMDE4LIAFB1YyFgAA2AgwMTQsgAUGwuYWAADYCDAxMCyABQeHOhYAANgIMDEsLIAFB4syEgAA2AgwMSgsgAUHA8oSAADYCDAxJCyABQY63hIAANgIMDEgLIAFB/NqEgAA2AgwMRwsgAUHx54SAADYCDAxGCyABQYmRhYAANgIMDEULIAFBp/OEgAA2AgwMRAsgAUH2tYWAADYCDAxDCyABQdLEhYAANgIMDEILIAFBiMCFgAA2AgwMQQsgAUGtuoSAADYCDAxACyABQfS/hIAANgIMDD8LIAFBmcKFgAA2AgwMPgsgAUHv7ISAADYCDAw9CyABQfmOhYAANgIMDDwLIAFB9OaEgAA2AgwMOwsgAUG59ISAADYCDAw6CyABQaCOhYAANgIMDDkLIAFB4vKEgAA2AgwMOAsgAUHhxIWAADYCDAw3CyABQcHOhYAANgIMDDYLIAFB78eFgAA2AgwMNQsgAUG/4YSAADYCDAw0CyABQZ6phYAANgIMDDMLIAFBipCFgAA2AgwMMgsgAUH+xIWAADYCDAwxCyABQZ/NhIAANgIMDDALIAFBo5KEgAA2AgwMLwsgAUGJkoSAADYCDAwuCyABQcn+hIAANgIMDC0LIAFB/r6EgAA2AgwMLAsgAUG5+YSAADYCDAwrCyABQeWThYAANgIMDCoLIAFB6cSEgAA2AgwMKQsgAUGt54SAADYCDAwoCyABQY+KhIAANgIMDCcLIAFB4KqFgAA2AgwMJgsgAUHX8oSAADYCDAwlCyABQZvohIAANgIMDCQLIAFBkvSEgAA2AgwMIwsgAUGpv4WAADYCDAwiCyABQbyDhIAANgIMDCELIAFBuceFgAA2AgwMIAsgAUGR84SAADYCDAwfCyABQZXEhIAANgIMDB4LIAFBsayEgAA2AgwMHQsgAUHQrISAADYCDAwcCyABQbDDhYAANgIMDBsLIAFBlNiEgAA2AgwMGgsgAUGJ2YSAADYCDAwZCyABQeKGhYAANgIMDBgLIAFBgOGEgAA2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EGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw/oeAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw/oeAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwgoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwhoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwiIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwiIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwiIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwioiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwioiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwioiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwjoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwkoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwlIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwlIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwlIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwloiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwloiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwloiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwmoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwnoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwoIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwoIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwoIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwooiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwooiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwooiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwpoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwqoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwrIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwrIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwrIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwroiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwroiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwroiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwsoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwtoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwuoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwvoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwwoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwxoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwyoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCwzoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0IiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0IiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0IiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0oiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0oiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw0oiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1IiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1IiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1IiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1oiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1oiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw1oiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2IiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2IiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2IiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2oiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2oiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw2oiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw3IiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw3IiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw3IiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw3oiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQCw3oiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiAC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IAIoAgxBAXQ2AggCQCACKAIIIAIoAgxJQQFxRQ0AIAJBAEEBcToAHwwDCyACIAIoAgg2AgwMAAsLIAIgAigCGCgCCCACKAIMQQJ0ELGMgIAANgIEAkAgAigCBEEARkEBcUUNACACQQBBAXE6AB8MAQsgAigCBCEEIAIoAhggBDYCCCACKAIMIQUgAigCGCAFNgIEIAJBAUEBcToAHwsgAi0AH0EBcSEGIAJBIGokgICAgAAgBg8LpQEBBn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIMQQEQsIaAgABBAXFFDQAgAigCDCgCCEEEaiEDIAIoAgwoAgghBCACKAIMKAIAQQJ0IQUCQCAFRQ0AIAMgBCAF/AoAAAsgAigCCCEGIAIoAgwoAgggBjYCACACKAIMIQcgByAHKAIAQQFqNgIACyACQRBqJICAgIAADwu7AQEGfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAIAIoAggoAgBBAEtBAXFFDQAgAigCDCACKAIIKAIAELCGgIAAQQFxRQ0AIAIoAgwoAgggAigCDCgCAEECdGohAyACKAIIKAIIIQQgAigCCCgCAEECdCEFAkAgBUUNACADIAQgBfwKAAALIAIoAggoAgAhBiACKAIMIQcgByAGIAcoAgBqNgIACyACQRBqJICAgIAADwuGAQEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCBEEAS0EBcUUNACABKAIMKAIIELCMgIAAIAEoAgwhAiABQQA2AgAgAUEANgIEIAFBADYCCCACIAEpAgA3AgBBCCEDIAIgA2ogASADaigCADYCAAsgAUEQaiSAgICAAA8L60ABAn8jgICAgABB4ANrIQIgAiSAgICAACACIAA2AtwDIAIgATYC2AMgAigC2AMvAQBBf2ohAyADQZYBSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAw6XAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBCyACIAIoAtgDNgLUAyACKALcAyACKALUAygCEBC0hoCAACACKALcAyACKALUAygCFBC0hoCAAAyXAQsgAiACKALYAzYC0AMgAigC3AMgAigC0AMoAhAQtIaAgAAgAigC3AMgAigC0AMoAhQQtIaAgAAMlgELIAIgAigC2AM2AswDIAIoAtwDIAIoAswDKAIQELSGgIAAIAIoAtwDIAIoAswDKAIUELSGgIAADJUBCyACIAIoAtgDNgLIAyACKALcAyACKALIAygCEBC0hoCAACACKALcAyACKALIAygCFBC0hoCAAAyUAQsgAiACKALYAzYCxAMgAigC3AMgAigCxANBEGoQtYaAgAAMkwELIAIgAigC2AM2AsADIAIoAtwDIAIoAsADQRBqELWGgIAADJIBCyACIAIoAtgDNgK8AwJAIAIoArwDKAIQQQBHQQFxRQ0AIAIoAtwDIAIoArwDKAIQELSGgIAACyACKALcAyACKAK8A0EUahC1hoCAAAJAIAIoArwDKAIgQQBHQQFxRQ0AIAIoAtwDIAIoArwDKAIgELSGgIAACyACKALcAyACKAK8A0EkahC1hoCAAAyRAQsgAiACKALYAzYCuAMgAigC3AMgAigCuAMoAhAQtIaAgAAgAigC3AMgAigCuAMoAhQQtIaAgAAMkAELIAIgAigC2AM2ArQDAkAgAigCtAMoAhBBAEdBAXFFDQAgAigC3AMgAigCtAMoAhAQtIaAgAALDI8BCwyOAQsgAiACKALYAzYCsAMCQCACKAKwAygCGEEAR0EBcUUNACACKALcAyACKAKwAygCGBC0hoCAAAsCQCACKAKwAygCHEEAR0EBcUUNACACKALcAyACKAKwAygCHBC0hoCAAAsCQCACKAKwAygCIEEAR0EBcUUNACACKALcAyACKAKwAygCIBC0hoCAAAsCQCACKAKwAygCJEEAR0EBcUUNACACKALcAyACKAKwAygCJBC0hoCAAAsMjQELIAIgAigC2AM2AqwDAkAgAigCrAMoAhBBAEdBAXFFDQAgAigC3AMgAigCrAMoAhAQtIaAgAALDIwBCwyLAQsgAiACKALYAzYCqAMgAigCqANBEGoQmIuAgAACQCACKAKoAygCHEEAR0EBcUUNACACKALcAyACKAKoAygCHBC0hoCAAAsCQCACKAKoAygCIEEAR0EBcUUNACACKALcAyACKAKoAygCIBC0hoCAAAsMigELDIkBCyACIAIoAtgDNgKkAwJAIAIoAqQDKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAqQDKAIQELSGgIAACyACKALcAyACKAKkA0EUahC1hoCAAAyIAQsgAiACKALYAzYCoAMCQCACKAKgAygCEEEAR0EBcUUNACACKALcAyACKAKgAygCEBC0hoCAAAsMhwELIAIgAigC2AM2ApwDAkAgAigCnAMoAhBBAEdBAXFFDQAgAigC3AMgAigCnAMoAhAQtIaAgAALIAIoAtwDIAIoApwDKAI0ELSGgIAADIYBCyACIAIoAtgDNgKYAwJAIAIoApgDKAIQQQBHQQFxRQ0AIAIoAtwDIAIoApgDKAIQELSGgIAACwJAIAIoApgDKAIwQQBHQQFxRQ0AIAIoAtwDIAIoApgDKAIwELSGgIAACwJAIAIoApgDKAI8QQBHQQFxRQ0AIAIoAtwDIAIoApgDKAI8ELSGgIAACwyFAQsgAiACKALYAzYClAMCQCACKAKUAygCEEEAR0EBcUUNACACKALcAyACKAKUAygCEBC0hoCAAAsgAigC3AMgAigClAMoAjgQtIaAgAAMhAELIAIgAigC2AM2ApADAkAgAigCkAMoAhBBAEdBAXFFDQAgAigC3AMgAigCkAMoAhAQtIaAgAALIAIoAtwDIAIoApADKAI0ELSGgIAADIMBCyACIAIoAtgDNgKMAyACKALcAyACKAKMAygCEBC0hoCAAAyCAQsgAiACKALYAzYCiAMgAigC3AMgAigCiAMoAhAQtIaAgAAgAigC3AMgAigCiAMoAhQQtIaAgAAMgQELIAIgAigC2AM2AoQDAkAgAigChAMoAhBBAEdBAXFFDQAgAigC3AMgAigChAMoAhAQtIaAgAALIAIoAtwDIAIoAoQDQRRqELWGgIAAAkAgAigChAMoAiBBAEdBAXFFDQAgAigC3AMgAigChAMoAiAQtIaAgAALDIABCyACIAIoAtgDNgKAAwJAIAIoAoADKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAoADKAIQELSGgIAACyACKALcAyACKAKAA0EUahC1hoCAAAJAIAIoAoADKAIgQQBHQQFxRQ0AIAIoAtwDIAIoAoADKAIgELSGgIAACwx/CyACIAIoAtgDNgL8AiACKAL8AkEQahCYi4CAACACKALcAyACKAL8AigCJBC0hoCAAAJAIAIoAvwCKAIwQQBHQQFxRQ0AIAIoAtwDIAIoAvwCKAIwELSGgIAACwJAIAIoAvwCKAI0QQBHQQFxRQ0AIAIoAtwDIAIoAvwCKAI0ELSGgIAACwx+CyACIAIoAtgDNgL4AiACKALcAyACKAL4AigCJBC0hoCAAAx9CyACIAIoAtgDNgL0AiACKALcAyACKAL0AigCJBC0hoCAAAx8CyACIAIoAtgDNgLwAiACKALcAyACKALwAigCJBC0hoCAAAx7Cwx6Cwx5CyACIAIoAtgDNgLsAiACKALcAyACKALsAigCHBC0hoCAAAx4CyACIAIoAtgDNgLoAiACKALcAyACKALoAigCJBC0hoCAAAx3CyACIAIoAtgDNgLkAiACKALcAyACKALkAigCJBC0hoCAAAx2CyACIAIoAtgDNgLgAiACKALcAyACKALgAigCJBC0hoCAAAx1CyACIAIoAtgDNgLcAiACKALcAyACKALcAigCEBC0hoCAACACKALcAyACKALcAigCHBC0hoCAAAx0CyACIAIoAtgDNgLYAgJAIAIoAtgCKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAtgCKAIQELSGgIAACwxzCyACIAIoAtgDNgLUAiACKALcAyACKALUAigCEBC0hoCAACACKALcAyACKALUAigCHBC0hoCAAAxyCyACIAIoAtgDNgLQAiACKALcAyACKALQAigC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KAIkELSGgIAACwJAIAIoAuwBKAIwQQBHQQFxRQ0AIAIoAtwDIAIoAuwBKAIwELSGgIAACyACKALcAyACKALsASgCQBC0hoCAAAxPCyACIAIoAtgDNgLoAQJAIAIoAugBKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIQELSGgIAACwJAIAIoAugBKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIkELSGgIAACwJAIAIoAugBKAIwQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIwELSGgIAACyACKALcAyACKALoASgCPBC0hoCAAAxOCyACIAIoAtgDNgLkASACKALcAyACKALkASgCEBC0hoCAAAJAIAIoAuQBKAIcQQBHQQFxRQ0AIAIoAtwDIAIoAuQBKAIcELSGgIAACwJAIAIoAuQBKAIoQQBHQQFxRQ0AIAIoAtwDIAIoAuQBKAIoELSGgIAACwxNCyACIAIoAtgDNgLgASACKALcAyACKALgASgCJBC0hoCAAAxMCyACIAIoAtgDNgLcASACKALcAyACKALcASgCJBC0hoCAAAxLCyACIAIoAtgDNgLYASACKALcAyACKALYASgCJBC0hoCAAAxKCwxJCwxICyACIAIoAtgDNgLUASACKALcAyACKALUASgCHBC0hoCAAAxHCyACIAIoAtgDNgLQASACKALQAUEQahCti4CAAAxGCyACIAIoAtgDNgLMASACKALcAyACKALMAUEYahC1hoCAAAxFCyACIAIoAtgDNgLIASACKALcAyACKALIAUEYahC1hoCAAAxECyACIAIoAtgDNgLEASACKALcAyACKALEAUEYahC1hoCAAAxDCyACIAIoAtgDNgLAASACKALcAyACKALAAUEYahC1hoCAAAxCCyACIAIoAtgDNgK8ASACKALcAyACKAK8AUEYahC1hoCAAAxBCwxACww/CyACIAIoAtgDNgK4ASACKALcAyACKAK4AUEQahC1hoCAAAw+Cww9CyACIAIoAtgDNgK0ASACKAK0AUEQahCYi4CAAAJAIAIoArQBKAI0QQBHQQFxRQ0AIAIoAtwDIAIoArQBKAI0ELSGgIAACwJAIAIoArQBKAI4QQBHQQFxRQ0AIAIoAtwDIAIoArQBKAI4ELSGgIAACww8CyACIAIoAtgDNgKwASACKALcAyACKAKwASgCIBC0hoCAAAw7CyACIAIoAtgDNgKsASACKALcAyACKAKsASgCIBC0hoCAAAw6CyACIAIoAtgDNgKoASACKALcAyACKAKoASgCIBC0hoCAAAw5Cww4Cww3CyACIAIoAtgDNgKkASACKALcAyACKAKkASgCIBC0hoCAAAw2CyACIAIoAtgDNgKgASACKAKgAUEoahDCi4CAAAw1CyACIAIoAtgDNgKcASACKALcAyACKAKcASgCEBC0hoCAACACKALcAyACKAKcASgCFBC0hoCAAAw0CyACIAIoAtgDNgKYASACKALcAyACKAKYASgCEBC0hoCAACACKALcAyACKAKYASgCFBC0hoCAAAwzCyACIAIoAtgDNgKUASACKALcAyACKAKUASgCEBC0hoCAACACKALcAyACKAKUAUEUahC1hoCAAAwyCwwxCyACIAIoAtgDNgKQASACKAKQAUEQahCYi4CAACACKALcAyACKAKQASgCJBC0hoCAAAJAIAIoApABKAIoQQBHQQFxRQ0AIAIoAtwDIAIoApABKAIoELSGgIAACwwwCyACIAIoAtgDNgKMASACKALcAyACKAKMAUEQahC1hoCAAAJAIAIoAowBKAIcQQBHQQFxRQ0AIAIoAtwDIAIoAowBKAIcELSGgIAACyACKALcAyACKAKMAUEgahC1hoCAAAwvCyACIAIoAtgDNgKIASACKALcAyACKAKIAUEQahC1hoCAAAJAIAIoAogBKAIcQQBHQQFxRQ0AIAIoAtwDIAIoAogBKAIcELSGgIAACyACKALcAyACKAKIAUEgahC1hoCAACACKALcAyACKAKIASgCRBC0hoCAAAwuCyACIAIoAtgDNgKEAQJAIAIoAoQBKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAoQBKAIQELSGgIAACwwtCwwsCwwrCwwqCwwpCyACIAIoAtgDNgKAASACKALcAyACKAKAASgCHBC0hoCAAAwoCyACIAIoAtgDNgJ8IAIoAtwDIAIoAnwoAiQQtIaAgAAMJwsgAiACKALYAzYCeCACKALcAyACKAJ4KAIQELSGgIAAIAIoAtwDIAIoAngoAhQQtIaAgAAMJgsgAiACKALYAzYCdCACKALcAyACKAJ0QRBqELWGgIAAIAIoAtwDIAIoAnRBHGoQtYaAgAACQCACKAJ0KAIoQQBHQQFxRQ0AIAIoAtwDIAIoAnQoAigQtIaAgAALIAIoAtwDIAIoAnRBLGoQtYaAgAAgAigC3AMgAigCdEE4ahC1hoCAAAJAIAIoAnQoAkRBAEdBAXFFDQAgAigC3AMgAigCdCgCRBC0hoCAAAsCQCACKAJ0KAJIQQBHQQFxRQ0AIAIoAtwDIAIoAnQoAkgQtIaAgAALDCULIAIgAigC2AM2AnACQCACKAJwKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAnAoAhAQtIaAgAALDCQLIAIgAigC2AM2AmwgAigC3AMgAigCbCgCEBC0hoCAAAwjCyACIAIoAtgDNgJoIAIoAtwDIAIoAmgoAhAQtIaAgAAMIgsgAiACKALYAzYCZAJAIAIoAmQoAhBBAEdBAXFFDQAgAigC3AMgAigCZCgCEBC0hoCAAAsMIQsgAiACKALYAzYCYAJAIAIoAmAoAhBBAEdBAXFFDQAgAigC3AMgAigCYCgCEBC0hoCAAAsMIAsgAiACKALYAzYCXCACKAJcQRBqEJiLgIAAIAIoAtwDIAIoAlwoAhwQtIaAgAAMHwsgAiACKALYAzYCWAJAIAIoAlgoAhBBAEdBAXFFDQAgAigC3AMgAigCWCgCEBC0hoCAAAsCQCACKAJYKAIUQQBHQQFxRQ0AIAIoAtwDIAIoAlgoAhQQtIaAgAALDB4LIAIgAigC2AM2AlQgAigCVEEQahCti4CAACACKAJUQSBqEK2LgIAADB0LDBwLIAIgAigC2AM2AlAgAigCUEEoahDCi4CAAAwbCwwaCwwZCyACIAIoAtgDNgJMIAIoAtwDIAIoAkwoAhAQtIaAgAAgAigC3AMgAigCTCgCHBC0hoCAAAwYCyACIAIoAtgDNgJIIAIoAtwDIAIoAkhBGGoQtYaAgAACQCACKAJIKAIsQQBHQQFxRQ0AIAIoAtwDIAIoAkgoAiwQtIaAgAALAkAgAigCSCgCOEEAR0EBcUUNACACKALcAyACKAJIKAI4ELSGgIAACwJAIAIoAkgoAjxBAEdBAXFFDQAgAigC3AMgAigCSCgCPBC0hoCAAAsMFwsMFgsMFQsgAiACKALYAzYCRAJAIAIoAkQoAhhBAEdBAXFFDQAgAigC3AMgAigCRCgCGBC0hoCAAAsMFAsMEwsgAiACKALYAzYCQCACKALcAyACKAJAKAIQELSGgIAADBILIAIgAigC2AM2AjwgAigCPEEQahCYi4CAACACKALcAyACKAI8KAIsELSGgIAAAkAgAigCPCgCMEEAR0EBcUUNACACKALcAyACKAI8KAIwELSGgIAACwwRCwwQCyACIAIoAtgDNgI4IAIoAjhBEGoQwouAgAAMDwsMDgsgAiACKALYAzYCNAJAIAIoAjQoAhhBAEdBAXFFDQAgAigC3AMgAigCNCgCGBC0hoCAAAsMDQsgAiACKALYAzYCMCACKALcAyACKAIwQRBqELWGgIAADAwLIAIgAigC2AM2AiwgAigCLEEoahDCi4CAAAwLCyACIAIoAtgDNgIoAkAgAigCKCgCIEEAR0EBcUUNACACKALcAyACKAIoKAIgELSGgIAACwJAIAIoAigoAixBAEdBAXFFDQAgAigC3AMgAigCKCgCLBC0hoCAAAsMCgsgAiACKALYAzYCJCACKAIkQShqEMKLgIAADAkLDAgLIAIgAigC2AM2AiAgAigC3AMgAigCIEEQahC1hoCAAAwHCyACIAIoAtgDNgIcIAIoAtwDIAIoAhwoAhgQtIaAgAACQCACKAIcKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAhwoAiQQtIaAgAALAkAgAigCHCgCKEEAR0EBcUUNACACKALcAyACKAIcKAIoELSGgIAACwwGCyACIAIoAtgDNgIYIAIoAtwDIAIoAhgoAigQtIaAgAACQCACKAIYKAIsQQBHQQFxRQ0AIAIoAtwDIAIoAhgoAiwQtIaAgAALDAULIAIgAigC2AM2AhQgAigC3AMgAigCFEEYahC1hoCAAAJAIAIoAhQoAixBAEdBAXFFDQAgAigC3AMgAigCFCgCLBC0hoCAAAsMBAsgAiACKALYAzYCECACKALcAyACKAIQKAIoELSGgIAAAkAgAigCECgCLEEAR0EBcUUNACACKALcAyACKAIQKAIsELSGgIAACwwDCyACIAIoAtgDNgIMIAIoAgxBKGoQwouAgAAMAgsgAiACKALYAzYCCAJAIAIoAggoAiBBAEdBAXFFDQAgAigC3AMgAigCCCgCIBC0hoCAAAsMAQtB5r6GgABB8tmFgABBjAFBmYOEgAAQgYCAgAAACyACKALYAxCwjICAACACQeADaiSAgICAAA8LuwEBBn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEANgIAA0AgAigCACACKAIIKAIASSEDQQAhBCADQQFxIQUgBCEGAkAgBUUNACACKAIIKAIIIAIoAgBBAnRqKAIAIQcgAiAHNgIEIAdBAEchBgsCQCAGQQFxRQ0AIAIoAgwgAigCBBC0hoCAACACIAIoAgBBAWo2AgAMAQsLIAIoAggQs4aAgAAgAkEQaiSAgICAAA8LdAECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCCCEEAkAgAygCDCADKAIEIAQRgICAgACAgICAAEEBcUUNACADKAIMIAMoAgggAygCBBC3hoCAAAsgA0EQaiSAgICAAA8LnVkBAn8jgICAgABBsAVrIQMgAySAgICAACADIAA2AqwFIAMgATYCqAUgAyACNgKkBSADKAKsBS8BAEF/aiEEIARBlwFLGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAEDpgBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAQsgAyADKAKsBTYCoAUgAygCoAUoAhAgAygCqAUgAygCpAUQtoaAgAAgAygCoAUoAhQgAygCqAUgAygC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AygCjAQoAiQgAygCqAUgAygCpAUQtoaAgAAMfQsgAyADKAKsBTYCiAQgAygCiAQoAiQgAygCqAUgAygCpAUQtoaAgAAMfAsgAyADKAKsBTYChAQgAygChAQoAiQgAygCqAUgAygCpAUQtoaAgAAMewsMegsMeQsgAyADKAKsBTYCgAQgAygCgAQoAhwgAygCqAUgAygCpAUQtoaAgAAMeAsgAyADKAKsBTYC/AMgAygC/AMoAiQgAygCqAUgAygCpAUQtoaAgAAMdwsgAyADKAKsBTYC+AMgAygC+AMoAiQgAygCqAUgAygCpAUQtoaAgAAMdgsgAyADKAKsBTYC9AMgAygC9AMoAiQgAygCqAUgAygCpAUQtoaAgAAMdQsgAyADKAKsBTYC8AMgAygC8AMoAhAgAygCqAUgAygCpAUQtoaAgAAgAygC8AMoAhwgAygCqAUgAygCpAUQtoaAgAAMdAsgAyADKAKsBTYC7AMCQCADKALsAygCEEEAR0EBcUUNACADKALsAygCECADKAKoBSADKAKkBRC2hoCAAAsMcwsgAyADKAKsBTYC6AMgAygC6AMoAhAgAygCqAUgAygCpAUQtoaAgAAgAygC6AMoAhwgAygCqAUgAygCpAUQtoaAgAAMcgsgAyADKAKsBTYC5AMgAygC5AMoAhAgAygCqAUgAygCpAUQtoaAgAAgAygC5AMoAhwgAygCqAUgAygCpAUQtoaAgAAMcQsgAyADKAKsBTYC4AMCQCADKALgAygCEEEAR0EBcUUNACADKALgAygCECADKAKoBSADKAKkBRC2hoCAAAsMcAsgAyADKAKsBTYC3AMgAygC3AMoAhAgAygCqAUgAygCpAUQtoaAgAAgAygC3AMoAhwgAygCqAUgAygCpAUQtoaAgAAMbwsMbgsMbQsgAyADKAKsBTYC2AMgAygC2AMoAhwgAygCqAUgAygCpAUQtoaAgAAMbAsgAyADKAKsBTYC1AMCQCADKALUAygCHEEAR0EBcUUNACADKALUAygCHCADKAKoBSADKAKkBRC2hoCAAAsCQCADKALUAygCIEEAR0EBcUUNACADKALUAygCICADKAKoBSADKAKkBRC2hoCAAAsCQCADKALUAygCJEEAR0EBcUUNACADKALUAygCJCADKAKoBSADKAKkBRC2hoCAAAsMawsgAyADKAKsBTYC0AMgAygC0AMoAhggAygCqAUgAygCpAUQtoaAgAAMagsgAyADKAKsBTYCzAMCQCADKALMAygCGEEAR0EBcUUNACADKALMAygCGCADKAKoBSADKAKkBRC2hoCAAAsMaQsgAyADKAKsBTYCyAMCQCADKALIAygCGEEAR0EBcUUNACADKALIAygCGCADKAKoBSADKAKkBRC2hoCAAAsMaAsgAyADKAKsBTYCxAMgAygCxAMoAhggAygCqAUgAygCpAUQtoaAgAAMZwsgAyADKAKsBTYCwAMCQCADKALAAygCGEEAR0EBcUUNACADKALAAygCGCADKAKoBSADKAKkBRC2hoCAAAsMZgsMZQsgAyADKAKsBTYCvAMCQCADKAK8AygCEEEAR0EBcUUNACADKAK8AygCECADKAKoBSADKAKkBRC2hoCAAAsgAygCvAMoAhQgAygCqAUgAygCpAUQtoaAgAAgAyADKAK8A0EYajYCuAMgA0EANgK0AwJAA0AgAygCtAMgAygCuAMoAgBJQQFxRQ0BIAMoArgDKAIIIAMoArQDQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoArQDQQFqNgK0AwwACwsgAygCvAMoAiQgAygCqAUgAygCpAUQtoaAgAAMZAsgAyADKAKsBTYCsAMCQCADKAKwAygCEEEAR0EBcUUNACADKAKwAygCECADKAKoBSADKAKkBRC2hoCAAAsCQCADKAKwAygCFEEAR0EBcUUNACADKAKwAygCFCADKAKoBSADKAKkBRC2hoCAAAsMYwsMYgsgAyADKAKsBTYCrAMgAygCrAMoAhAgAygCqAUgAygCpAUQtoaAgAAgAygCrAMoAhQgAygCqAUgAygCpAUQtoaAgAACQCADKAKsAygCGEEAR0EBcUUNACADKAKsAygCGCADKAKoBSADKAKkBRC2hoCAAAsMYQsMYAsMXwsgAyADKAKsBTYCqAMCQCADKAKoAygCEEEAR0EBcUUNACADKAKoAygCECADKAKoBSADKAKkBRC2hoCAAAsMXgsgAyADKAKsBTYCpAMgAygCpAMoAiQgAygCqAUgAygCpAUQtoaAgAAMXQsgAyADKAKsBTYCoAMgAygCoAMoAiQgAygCqAUgAygCpAUQtoaAgAAMXAsgAyADKAKsBTYCnAMgAygCnAMoAiQgAygCqAUgAygCpAUQtoaAgAAMWwsMWgsMWQsgAyADKAKsBTYCmAMgAygCmAMoAhwgAygCqAUgAygCpAUQtoaAgAAMWAsgAyADKAKsBTYClAMgAyADKAKUA0EYajYCkAMgA0EANgKMAwJAA0AgAygCjAMgAygCkAMoAgBJQQFxRQ0BIAMoApADKAIIIAMoAowDQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAowDQQFqNgKMAwwACwsMVwsgAyADKAKsBTYCiAMCQCADKAKIAygCEEEAR0EBcUUNACADKAKIAygCECADKAKoBSADKAKkBRC2hoCAAAsgAyADKAKIA0EUajYChAMgA0EANgKAAwJAA0AgAygCgAMgAygChAMoAgBJQQFxRQ0BIAMoAoQDKAIIIAMoAoADQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAoADQQFqNgKAAwwACwsCQCADKAKIAygCIEEAR0EBcUUNACADKAKIAygCICADKAKoBSADKAKkBRC2hoCAAAsMVgsgAyADKAKsBTYC/AIgAygC/AIoAhggAygCqAUgAygCpAUQtoaAgAACQCADKAL8AigCJEEAR0EBcUUNACADKAL8AigCJCADKAKoBSADKAKkBRC2hoCAAAsCQCADKAL8AigCKEEAR0EBcUUNACADKAL8AigCKCADKAKoBSADKAKkBRC2hoCAAAsMVQsgAyADKAKsBTYC+AIgAygC+AIoAhAgAygCqAUgAygCpAUQtoaAgAAMVAsgAyADKAKsBTYC9AIgAygC9AIoAhAgAygCqAUgAygCpAUQtoaAgAAMUwsMUgsgAyADKAKsBTYC8AIgAygC8AIoAhAgAygCqAUgAygCpAUQtoaAgAACQCADKALwAigCFEEAR0EBcUUNACADKALwAigCFCADKAKoBSADKAKkBRC2hoCAAAsMUQsgAyADKAKsBTYC7AICQCADKALsAigCEEEAR0EBcUUNACADKALsAigCECADKAKoBSADKAKkBRC2hoCAAAsCQCADKALsAigCJEEAR0EBcUUNACADKALsAigCJCADKAKoBSADKAKkBRC2hoCAAAsCQCADKALsAigCMEEAR0EBcUUNACADKALsAigCMCADKAKoBSADKAKkBRC2hoCAAAsgAygC7AIoAjwgAygCqAUgAygCpAUQtoaAgAAMUAsgAyADKAKsBTYC6AICQCADKALoAigCEEEAR0EBcUUNACADKALoAigCECADKAKoBSADKAKkBRC2hoCAAAsCQCADKALoAigCJEEAR0EBcUUNACADKALoAigCJCADKAKoBSADKAKkBRC2hoCAAAsCQCADKALoAigCMEEAR0EBcUUNACADKALoAigCMCADKAKoBSADKAKkBRC2hoCAAAsgAygC6AIoAkAgAygCqAUgAygCpAUQtoaAgAAMTwsgAyADKAKsBTYC5AICQCADKALkAigCEEEAR0EBcUUNACADKALkAigCECADKAKoBSADKAKkBRC2hoCAAAsCQCADKALkAigCJEEAR0EBcUUNACADKALkAigCJCADKAKoBSADKAKkBRC2hoCAAAsCQCADKALkAigCMEEAR0EBcUUNACADKALkAigCMCADKAKoBSADKAKkBRC2hoCAAAsgAygC5AIoAjwgAygCqAUgAygCpAUQtoaAgAAMTgsgAyADKAKsBTYC4AIgAygC4AIoAhAgAygCqAUgAygCpAUQtoaAgAACQCADKALgAigCHEEAR0EBcUUNACADKALgAigCHCADKAKoBSADKAKkBRC2hoCAAAsCQCADKALgAigCKEEAR0EBcUUNACADKALgAigCKCADKAKoBSADKAKkBRC2hoCAAAsMTQsgAyADKAKsBTYC3AIgAygC3AIoAiQgAygCqAUgAygCpAUQtoaAgAAMTAsgAyADKAKsBTYC2AIgAygC2AIoAiQgAygCqAUgAygCpAUQtoaAgAAMSwsgAyADKAKsBTYC1AIgAygC1AIoAiQgAygCqAUgAygCpAUQtoaAgAAMSgsMSQsMSAsgAyADKAKsBTYC0AIgAygC0AIoAhwgAygCqAUgAygCpAUQtoaAgAAMRwsMRgsgAyADKAKsBTYCzAIgAyADKALMAkEYajYCyAIgA0EANgLEAgJAA0AgAygCxAIgAygCyAIoAgBJQQFxRQ0BIAMoAsgCKAIIIAMoAsQCQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAsQCQQFqNgLEAgwACwsMRQsgAyADKAKsBTYCwAIgAyADKALAAkEYajYCvAIgA0EANgK4AgJAA0AgAygCuAIgAygCvAIoAgBJQQFxRQ0BIAMoArwCKAIIIAMoArgCQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoArgCQQFqNgK4AgwACwsMRAsgAyADKAKsBTYCtAIgAyADKAK0AkEYajYCsAIgA0EANgKsAgJAA0AgAygCrAIgAygCsAIoAgBJQQFxRQ0BIAMoArACKAIIIAMoAqwCQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAqwCQQFqNgKsAgwACwsMQwsgAyADKAKsBTYCqAIgAyADKAKoAkEYajYCpAIgA0EANgKgAgJAA0AgAygCoAIgAygCpAIoAgBJQQFxRQ0BIAMoAqQCKAIIIAMoAqACQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAqACQQFqNgKgAgwACwsMQgsgAyADKAKsBTYCnAIgAyADKAKcAkEYajYCmAIgA0EANgKUAgJAA0AgAygClAIgAygCmAIoAgBJQQFxRQ0BIAMoApgCKAIIIAMoApQCQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoApQCQQFqNgKUAgwACwsMQQsMQAsMPwsgAyADKAKsBTYCkAIgAyADKAKQAkEQajYCjAIgA0EANgKIAgJAA0AgAygCiAIgAygCjAIoAgBJQQFxRQ0BIAMoAowCKAIIIAMoAogCQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAogCQQFqNgKIAgwACwsMPgsMPQsgAyADKAKsBTYChAICQCADKAKEAigCNEEAR0EBcUUNACADKAKEAigCNCADKAKoBSADKAKkBRC2hoCAAAsCQCADKAKEAigCOEEAR0EBcUUNACADKAKEAigCOCADKAKoBSADKAKkBRC2hoCAAAsMPAsgAyADKAKsBTYCgAIgAygCgAIoAiAgAygCqAUgAygCpAUQtoaAgAAMOwsgAyADKAKsBTYC/AEgAygC/AEoAiAgAygCqAUgAygCpAUQtoaAgAAMOgsgAyADKAKsBTYC+AEgAygC+AEoAiAgAygCqAUgAygCpAUQtoaAgAAMOQsMOAsMNwsgAyADKAKsBTYC9AEgAygC9AEoAiAgAygCqAUgAygCpAUQtoaAgAAMNgsMNQsgAyADKAKsBTYC8AEgAygC8AEoAhAgAygCqAUgAygCpAUQtoaAgAAgAygC8AEoAhQgAygCqAUgAygCpAUQtoaAgAAMNAsgAyADKAKsBTYC7AEgAygC7AEoAhAgAygCqAUgAygCpAUQtoaAgAAgAygC7AEoAhQgAygCqAUgAygCpAUQtoaAgAAMMwsgAyADKAKsBTYC6AEgAygC6AEoAhAgAygCqAUgAygCpAUQtoaAgAAgAyADKALoAUEUajYC5AEgA0EANgLgAQJAA0AgAygC4AEgAygC5AEoAgBJQQFxRQ0BIAMoAuQBKAIIIAMoAuABQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAuABQQFqNgLgAQwACwsMMgsMMQsgAyADKAKsBTYC3AEgAygC3AEoAiQgAygCqAUgAygCpAUQtoaAgAACQCADKALcASgCKEEAR0EBcUUNACADKALcASgCKCADKAKoBSADKAKkBRC2hoCAAAsMMAsgAyADKAKsBTYC2AEgAyADKALYAUEQajYC1AEgA0EANgLQAQJAA0AgAygC0AEgAygC1AEoAgBJQQFxRQ0BIAMoAtQBKAIIIAMoAtABQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAtABQQFqNgLQAQwACwsCQCADKALYASgCHEEAR0EBcUUNACADKALYASgCHCADKAKoBSADKAKkBRC2hoCAAAsgAyADKALYAUEgajYCzAEgA0EANgLIAQJAA0AgAygCyAEgAygCzAEoAgBJQQFxRQ0BIAMoAswBKAIIIAMoAsgBQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoAsgBQQFqNgLIAQwACwsMLwsgAyADKAKsBTYCxAEgAyADKALEAUEQajYCwAEgA0EANgK8AQJAA0AgAygCvAEgAygCwAEoAgBJQQFxRQ0BIAMoAsABKAIIIAMoArwBQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoArwBQQFqNgK8AQwACwsCQCADKALEASgCHEEAR0EBcUUNACADKALEASgCHCADKAKoBSADKAKkBRC2hoCAAAsgAyADKALEAUEgajYCuAEgA0EANgK0AQJAA0AgAygCtAEgAygCuAEoAgBJQQFxRQ0BIAMoArgBKAIIIAMoArQBQQJ0aigCACADKAKoBSADKAKkBRC2hoCAACADIAMoArQBQQFqNgK0AQwACwsgAygCxAEoAkQgAygCqAUgAygCpAUQtoaAgAAM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BCAANgIMIAQgATYCCCAEIAI2AgQgBCADNgIAIAQoAgxB/AFqIAQoAgggBCgCBCAEKAIAEN6EgIAAGiAEQRBqJICAgIAADwvdAQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgxBsAJqEMKLgIAAIAEoAgxBiAJqEOKEgIAAIAEoAgxB/AFqEOKEgIAAIAEoAgxB3AFqEMqGgIAAIAEoAgxB6AFqEMuGgIAAIAEoAgxBvAJqEKOLgIAAIAEoAgxBzAJqELqLgIAAAkADQCABKAIMKAKUAkEAR0EBcUUNASABKAIMEMyGgIAADAALCwJAA0AgASgCDCgCsAFBBE9BAXFFDQEgASgCDBDNhoCAAAwACwsgAUEQaiSAgICAAA8LeQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEgASgCDCgCBDYCCAJAA0AgASgCCEEAR0EBcUUNASABIAEoAggoAgA2AgQgASABKAIINgIAIAEoAgAQsIyAgAAgASABKAIENgIIDAALCyABQRBqJICAgIAADwt5AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASABKAIMKAIENgIIAkADQCABKAIIQQBHQQFxRQ0BIAEgASgCCCgCADYCBCABIAEoAgg2AgAgASgCABCwjICAACABIAEoAgQ2AggMAAsLIAFBEGokgICAgAAPC3QBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABIAEoAgwoApQCNgIIIAEoAggoAgAhAiABKAIMIAI2ApQCIAEoAghBBGoQzoaAgAAgASgCCEEQahCzhoCAACABKAIIELCMgIAAIAFBEGokgICAgAAPC+MBAQV/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQAJAIAEoAgwoArABDQAgASgCDCgCHEEANgIADAELAkACQCABKAIMKAKwAUEESUEBcUUNACABKAIMIQIgAiACKAKwAUF/ajYCsAEgASgCDEEcakEEaiABKAIMKAKwAUEkbGohAyABKAIMIAM2AhwMAQsgASgCDCEEIAQgBCgCsAFBf2o2ArABIAEgASgCDCgCHCgCIDYCCCABKAIMKAIcELCMgIAAIAEoAgghBSABKAIMIAU2AhwLCyABQRBqJICAgIAADwtMAQF/I4CAgIAAQRBrIQEg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CyABQSBqJICAgIAAIAsPCz4BAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMQQ4Q8IaAgABBAXEhAiABQRBqJICAgIAAIAIPC7ADAQ9/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggASACKAIIKAIcNgIgIAIoAgghAyADIAMoArABQQFqNgKwAQJAAkACQCACKAIIKAKwAUEDS0EBcUUNAEEkEK6MgIAAIQQgAigCCCAENgIcAkAgAigCCCgCHEEARkEBcUUNACACQQBBAXE6AA8MAwsgAigCCCgCHCEFIAUgASkCADcCAEEgIQYgBSAGaiABIAZqKAIANgIAQRghByAFIAdqIAEgB2opAgA3AgBBECEIIAUgCGogASAIaikCADcCAEEIIQkgBSAJaiABIAlqKQIANwIADAELIAIoAghBHGpBBGogAigCCCgCsAFBJGxqIQogCiABKQIANwIAQSAhCyAKIAtqIAEgC2ooAgA2AgBBGCEMIAogDGogASAMaikCADcCAEEQIQ0gCiANaiABIA1qKQIANwIAQQghDiAKIA5qIAEgDmopAgA3AgAgAigCCEEcakEEaiACKAIIKAKwAUEkbGohDyACKAIIIA82AhwLIAJBAUEBcToADwsgAi0AD0EBcSEQIAJBEGokgICAgAAgEA8LgQEBBX8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhxBiAJqIQQgAygCGCEFIAMoAhggAygCFGohBiADKAIUIQcgAyADKAIYNgIEIAMgBzYCACAEIAUgBkGIASADEOGEgIAAGiADQSBqJICAgIAADwupBAMCfwF+EX8jgICAgABB4ABrIQUgBSSAgICAACAFIAA2AlwgBSABOgBbIAUgAjoAWiAFIAM6AFkgBSAEOgBYIAVB0ABqQQA2AgAgBUHIAGohBkIAIQcgBiAHNwMAIAVBwABqIAc3AwAgBUE4aiAHNwMAIAUgBzcDMCAFQQY2AjAgBSAFLQBbQQFxOgA4IAUgBS0AWkEBcToAOSAFIAUtAFk6ADogBSAFLQBYOgA7IAUgBUEwakEEakEIajYCLCAFKAIsIQggCEEDaiEJQQAhCiAJIAooAM/piIAANgAAIAggCigAzOmIgAA2AAAgBUEDNgIoAkAgBS0AWEH/AXFF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BGpBf2oQt4uAgAAaCyABIAEoAggoAtABLQAAOgADAkAgASgCBEECRkEBcUUNACABIAEoAggoAtABLQABOgADCyABKAIEIQIgASgCCCEDIAMgAiADKALQAWo2AtABIAEgAS0AAzoADwwBCyABKAIIIQQgBCgC0AEhBSAEIAVBAWo2AtABIAEgBS0AADoADwsgAS0AD0H/AXEhBiABQRBqJICAgIAAIAYPC2EBAn8jgICAgABBEGshASABIAA6AA4gAS0ADiECAkACQAJAIAJBKEYNACACQTxGDQAgAkHbAEYNACACQfsARw0BCyABIAEtAA46AA8MAQsgAUEAOgAPCyABLQAPQf8BcQ8LiQEBAn8jgICAgABBEGshASABIAA6AA4gAS0ADiECAkACQAJAAkACQAJAIAJBKEYNACACQTxGDQMgAkHbAEYNASACQfsARg0CDAQLIAFBKToADwwECyABQd0AOgAPDAMLIAFB/QA6AA8MAgsgAUE+OgAPDAELIAEgAS0ADjoADwsgAS0AD0H/AXEPC7YEAwJ/AX4RfyOAgICAAEHgAGshAyADJICAgIAAIAMgADYCXCADIAE6AFsgAyACOgBaIAMgAy0AWkH/AXEQg4eAgAA6AFkgAyADLQBaQf8BcRCEh4CAADoAWCADQdAAakEANgIAIANByABqIQRCACEFIAQgBTcDACADQcAAaiAFNwMAIANBOGogBTcDACADIAU3AzAgA0EENgIwIAMgAy0AW0EBcToAOCADIAMtAFk6ADkgAyADLQBYOgA6IAMgA0EwakEEakEHajYCLCADKAIsIQYgBkEHaiEHQQAhCCAHIAgoAOHpiIAANgAAIAYgCCkA2umIgAA3AAAgA0EHNgIoAkAgAy0AWEH/AXFFDQAgAy0AWCEJIAMoAiwhCiADKAIoIQsgAyALQQFqNgIoIAogC2ogCToAAAsCQCADLQBbQQFxRQ0AIAMoAiwhDCADKAIoIQ0gAyANQQFqNgIoIAwgDWpBIzoAAAsCQCADLQBZQf8BcUUNACADLQBZIQ4gAygCLCEPIAMoAighECADIBBBAWo2AiggDyAQaiAOOgAACyADKAJcQQA2AvACIAMoAlwhEUEgIRIgAyASaiASIANBMGpqKAIANgIAQRghEyADIBNqIBMgA0EwamopAwA3AwBBECEUIAMgFGogFCADQTBqaikDADcDAEEIIRUgAyAVaiAVIANBMGpqKQMANwMAIAMgAykDMDcDACARIAMQ+IaAgABBAXEhFiADQeAAaiSAgICAACAWDwtTAQV/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCECQQAhA0EAIQQgAiADQQFxIARB/wFxEIWHgIAAQQFxIQUgAUEQaiSAgICAACAFDwteAQV/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCECQQAhA0EAIQQgAiADQQFxIANBAXEgBEH/AXEgBEH/AXEQ+oaAgABBAXEhBSABQRBqJICAgIAAIAUPC9cJASV/I4CAgIAAQcAAayEBIAEkgICAgAAgASAANgI4AkACQCABKAI4KALQASABKAI4KAK4AU9BAXFFDQAgASgCOCABKAI4QcgBakGBARC8h4CAACABQTo2AjwMAQsgAUEBOgA3IAEoAjgoAtABLQAAQV9qIQIgAkHdAEsaAkACQAJAAkACQAJAIAIOXgAABQAFAQEFBQABAAQAAAIDAwMDAwMDAwMAAAAAAAAABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAUFBQEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFCyABKAI4IQMgAyADKALQAUEBajYC0AEgAUE6NgI8DAULIAEoAjghBCAEIAQoAtABQQFqNgLQASABKAI4QYABEPCGgIAAIQUgAUE6QRcgBUEBcRs2AjwMBAsgASgCOCEGIAYgBigC0AFBAWo2AtABIAEoAjggASgCOCgC0AEgASgCOCgCuAEgASgCOCgC0AFrEOmGgIAAIQcgASAHNgIwAkAgB0EAS0EBcUUNAANAIAEoAjAhCCABKAI4IQkgCSAIIAkoAtABajYC0AEgASgCOCABKAI4KALQASABKAI4KAK4ASABKAI4KALQAWsQ6YaAgAAhCiABIAo2AjAgCkEAS0EBcQ0ACyABKAI4KAL4AkEBTSELIAFBqQFBqAEgC0EBcRs2AiwgASgCOEGIAmohDCABKAI4KALMASENIAEoAjgoAtABIQ4gASgCLCEPIAEoAjgoAtABIAEoAjgoAswBayEQIAEgASgCOCgCzAE2AhQgASAQNgIQIAwgDSAOIA8gAUEQahDhhICAABoLIAFBOjYCPAwDCyABKAI4KALQASABKAI4KAK4ASABKAI4KALQAWsQiouAgAAhESABKAI4IRIgEiARIBIoAtABajYC0AEgASgCOEGAARDwhoCAACETIAFBOkH6ACATQQFxGzYCPAwCCyABKAI4IRQgFCAUKALQAUEBajYC0AEgAUEAOgA3CyABKAI4IAEoAjgoAtABIAEoAjgoArgBIAEoAjgoAtABaxDphoCAACEVIAEgFTYCKAJAAkAgFUEAS0EBcUUNAANAIAEoAighFiABKAI4IRcgFyAWIBcoAtABajYC0AEgAS0ANyEYQQAhGSAYQQFxIRogGSEbAkAgGkUNACABKAI4IAEoAjgoAtABIAEoAjgoArgBIAEoAjgoAtABaxDphoCAACEcIAEgHDYCKCAcQQBLIRsLIBtBAXENAAsMAQsCQAJAIAEoAjgQ/IaAgABB/wFxEISLgIAAQQFxRQ0AIAEoAjggASgCOEHIAWpBgQEQvIeAgAAMAQsgASgCOCgC+AJBAU0hHSABQakBQagBIB1BAXEbNgIkIAEoAjgoAtABIR4gASgCOCgCoAIoAgAhHyABIB4gASgCOCgC0AEgASgCOCgCuAEgASgCOCgC0AFrIB8RgICAgACAgICAAGo2AiAgASgCOEGIAmohICABKAI4KALMASEhIAEoAiAhIiABKAIkISMgASgCICABKAI4KALMAWshJCABIAEoAjgoAswBNgIEIAEgJDYCACAgICEgIiAjIAEQ4YSAgAAaCwsgAUE6NgI8CyABKAI8ISUgAUHAAGokgICAgAAgJQ8LlwUBEn8jgICAgABBMGshASABJICAgIAAIAEgADYCLCABKAIsQcAAQf8BcRDuhoCAACECIAFBJEHDACACQQFxGzYCKCABIAEoAiwoArgBNgIkIAEoAiwgASgCLCgC0AEgASgCJCABKAIsKALQAWsQioeAgAAhAyABIAM2AiACQAJAIANBAEtBAXFFDQAgASgCICEEIAEoAiwhBSAFIAQgBSgC0AFqNgLQAQJAA0AgASgCLCABKAIsKALQASABKAIkIAEoAiwoAtABaxDphoCAACEGIAEgBjYCICAGQQBLQQFxRQ0BIAEoAiAhByABKAIsIQggCCAHIAgoAtABajYC0AEMAAsLDAELAkACQCABKAIsKALQASABKAIkSUEBcUUNACABKAIsKALQAS0AAEH/AXEQ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ASgCLCgCtAE2AhggAUEANgIcIAFBADYCICABQQA2AiQgAiABKQIMNwIAQRghBSACIAVqIAUgAUEMamooAgA2AgBBECEGIAIgBmogBiABQQxqaikCADcCAEEIIQcgAiAHaiAHIAFBDGpqKQIANwIAIAEoAighCCABQTBqJICAgIAAIAgPC1UBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgxBvAJqIAMoAgggAygCBBCii4CAACEEIANBEGokgICAgAAgBA8L2AEBB38jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAiACKAIcQRQQtIeAgAA2AhQgAigCFCEDIAJBPjsBACACQQA7AQIgAigCHCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIEIAIgAigCHCgCtAE2AgggAiACKAIcKAK0ATYCDCACIAIoAhg2AhAgAyACKQIANwIAQRAhBiADIAZqIAIgBmooAgA2AgBBCCEHIAMgB2ogAiAHaikCADcCACACKAIUIQggAkEgaiSAgICAACAIDwvWAQEDfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAIAIoAgwQmoqAgAANACACKAIIKAIIIQMgAigCDCADNgIICyACKAIIKAIMIQQgAigCDCAENgIMIAIoAgxBEGogAigCCBCvhoCAAAJAIAIoAggvAQBB//8DcUGLAUZBAXFFDQACQAJAIAIoAgwvAQJB//8DcUEgcUUNACACKAIMQcAAQf//A3EQsoeAgAAMAQsgAigCDEEgQf//A3EQsoeAgAALCyACQRBqJICAgIAADwuqAQEFfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAyADKAIcQSBB//8DcRDBiYCAADYCECADKAIQQQhqIQQgAyADKAIcKAK0ATYCCCADIAMoAhwoArQBNgIMIAQgAykCCDcCACADKAIYIQUgAygCECAFNgIwIAMoAhQhBiADKAIQIAY2AhwgAygCECEHIANBIGokgICAgAAgBw8LlgIBCX8jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCICAEIAQoAixBAEH//wNxEMGJgIAANgIcIAQoAiwoArQBIQUgBCgCHCAFNgIIIAQoAiwoArgBIQYgBCgCHCAGNgIMIAQoAighByAEKAIcIAc2AhAgBCgCHEEUaiEIIARBADYCFCAEQQA2AhggCCAEKQIUNwIAIAQoAhxBIGohCSAEQQA2AgwgBEEANgIQIAkgBCkCDDcCACAEKAIgIQogBCgCHCAKNgIwIAQoAiwgBCgCJCAEKAIkEIGMgIAAEKaHgIAAIQsgBCgCHCALNgIcIAQoAhwhDCAEQTBqJICAgIAAIAwPC9gCAQl/I4CAgIAAQcAAayEDIAMkgICAgAAgAyAANgI8IAMgATYCOCADIAI2AjQgAyADKAI8QSgQtIeAgAA2AjAgAygCMCEEIANBwAA7AQggA0EAOwEKIAMoAjwhBSAFKAIAQQFqIQYgBSAGNgIAIAMgBjYCDCADIAMoAjwoArQBNgIQIAMgAygCPCgCtAE2AhQgAyADKAI4NgIYIAMgAygCPCgCtAE2AhwgAyADKAI8KAK0ATYCICADIAMoAjQ2AiQgAyADKAI8KAK0ATYCKCADIAMoAjwoArQBNgIsIAQgAykCCDcCAEEgIQcgBCAHaiAHIANBCGpqKQIANwIAQRghCCAEIAhqIAggA0EIamopAgA3AgBBECEJIAQgCWogCSADQQhqaikCADcCAEEIIQogBCAKaiAKIANBCGpqKQIANwIAIAMoAjAhCyADQcAAaiSAgICAACALDwtmAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwgAigCCBDch4CAACACKAIMQRBqIAIoAggQsYaAgAAgAigCCEEBQf//A3EQsoeAgAAgAkEQaiSAgICAAA8L7AEBCH8jgICAgABBMGshASABJICAgIAAIAEgADYCLCABIAEoAixBHBC0h4CAADYCKCABKAIoIQIgAUHaADsBDCABQQQ7AQ4gASgCLCEDIAMoAgBBAWohBCADIAQ2AgAgASAENgIQIAFBADYCFCABQQA2AhggAUEANgIcIAFBADYCICABQQA2AiQgAiABKQIMNwIAQRghBSACIAVqIAUgAUEMamooAgA2AgBBECEGIAIgBmogBiABQQxqaikCADcCAEEIIQcgAiAHaiAHIAFBDGpqKQIANwIAIAEoAighCCABQTBqJICAgIAAIAgPC4QDAQt/I4CAgIAAQcAAayECIAIkgICAgAAgAiAANgI8IAIgATYCOCACIAIoAjxBNBC0h4CAADYCNCACKAI0IQMgAkGPATsBACACQRI7AQIgAigCPCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIEIAIgAigCPCgCtAE2AgggAiACKAI8KAK0ATYCDCACQRBqQgA3AgAgAiACKAI8KAK0ATYCGCACIAIoAjwoArQBNgIcIAJBIGpCADcCACACQQA2AiggAkEANgIsIAJBADYCMCADIAIpAgA3AgBBMCEGIAMgBmogAiAGaigCADYCAEEoIQcgAyAHaiACIAdqKQIANwIAQSAhCCADIAhqIAIgCGopAgA3AgBBGCEJIAMgCWogAiAJaikCADcCAEEQIQogAyAKaiACIApqKQIANwIAQQghCyADIAtqIAIgC2opAgA3AgAgAigCNEEoaiACKAI4IAIoAjgQgYyAgAAQvYuAgAAgAigCNCEMIAJBwABqJICAgIAAIAwPC7cBAQZ/I4CAgIAAQSBrIQEgASSAgICAACABIAA2AhwgASABKAIcQRAQtIeAgAA2AhggASgCGCECIAFBkAE7AQggAUECOwEKIAEoAhwhAyADKAIAQQFqIQQgAyAENgIAIAEgBDYCDCABIAEoAhwoArQBNgIQIAEgASgCHCgCuAE2AhQgAiABKQIINwIAQQghBSACIAVqIAUgAUEIamopAgA3AgAgASgCGCEGIAFBIGokgICAgAAgBg8LtwUBCn8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjAgBCAEKAI8QSAQtIeAgAA2AiwCQAJAIAQoAjBBAEdBAXFFDQAgBCgCMCgCDCAEKAI4KAIMS0EBcUUNACAEIAQoAjAoAgw2AigMAQsCQAJAIAQoAjQoAgBBpAFHQQFxRQ0AIAQgBCgCNCgCCDYCKAwBCyAEIAQoAjgoAgw2AigLCwJAIAQoAjgvAQBB//8DcUGNAUZBAXFFDQAgBCgCOCEFIAUgBS8BAkH//wNxQRJyOwECCyAEQQA7ASYCQCAEKAI4LwEAQf//A3FBBkZBAXENACAEKAI4LwEAQf//A3FBwQBGQQFxDQAgBCgCOC8BAEH//wNxQfoARkEBcQ0AIAQoAjBBAEdBAXFFDQAgBCgCMC8BAEH//wNxQQZGQQFxDQAgBCgCMC8BAEH//wNxQcEARkEBcQ0AIAQoAjAvAQBB//8DcUH6AEZBAXENACAEIAQoAjgvAQJB//8DcSAEKAIwLwECQf//A3FxQQJxOwEmCyAEKAIsIQYgBEEIOwEEIAQgBC8BJjsBBiAEKAI8IQcgBygCAEEBaiEIIAcgCDYCACAEIAg2AgggBCAEKAI4KAIINgIMIAQgBCgCKDYCECAEIAQoAjg2AhQgBCAEKAIwNgIYIARBBGpBGGohCQJAAkAgBCgCNCgCAEGkAUZBAXFFDQAgCUEANgIAIAlBADYCBAwBCyAJIAQoAjQoAgQ2AgAgCSAEKAI0KAIINgIECyAGIAQpAgQ3AgBBGCEKIAYgCmogCiAEQQRqaikCADcCAEEQIQsgBiALaiALIARBBGpqKQIANwIAQQghDCAGIAxqIAwgBEEEamopAgA3AgAgBCgCLCENIARBwABqJICAgIAAIA0PC8cBAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkACQCACKAIILwEAQf//A3FBCEZBAXFFDQAgAigCCCgCEC8BAEH//wNxQY8BRkEBcQ0BCyACKAIMQQRB//8DcRCKiICAAAsgAigCDEEQaiACKAIIEK+GgIAAAkAgAigCDCgCCEEARkEBcUUNACACKAIIKAIIIQMgAigCDCADNgIICyACKAIIKAIMIQQgAigCDCAENgIMIAJBEGokgICAgAAPC0MBA38jgICAgABBEGshAiACIAA2AgwgAiABOwEKIAIvAQpB//8DcSEDIAIoAgwhBCAEIAMgBC8BAkH//wNxcjsBAg8L/AIBCn8jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABNgI4IAMgAjYCNCADIAMoAjxBMBC0h4CAADYCMCADKAIwIQQgA0GVATsBACADQQA7AQIgAygCPCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIEIAMgAygCPCgCtAE2AgggAyADKAI8KAK0ATYCDCADIAMoAjwoArQBNgIQIAMgAygCPCgCtAE2AhQgAyADKAI8KAK0ATYCGCADIAMoAjwoArQBNgIcIAMgAygCPCgCtAE2AiAgAyADKAI8KAK0ATYCJCADIAMoAjg2AiggAyADKAI0NgIsIAQgAykCADcCAEEoIQcgBCAHaiADIAdqKQIANwIAQSAhCCAEIAhqIAMgCGopAgA3AgBBGCEJIAQgCWogAyAJaikCADcCAEEQIQogBCAKaiADIApqKQIANwIAQQghCyAEIAtqIAMgC2opAgA3AgAgAygCMCEMIANBwABqJICAgIAAIAwPC44BAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgghAyACQQEgAxC3jICAADYCBAJAIAIoAgRBAEZBAXFFDQBBACgCoPmIgAAhBCACIAIoAgg2AgAgBEGlv4aAACACENuLgIAAGhDSi4CAAAALIAIoAgQhBSACQRBqJICAgIAAIAUPC6kCAQt/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgggAyABNgIEIAMgAjYCAAJAA0AgAygCBEEDaiADKAIATSEEQQAhBSAEQQFxIQYgBSEHAkAgBkUNACADKAIEIQggAygCACADKAIEayEJIAMoAggtAIMDIQogAygCCCgCoAIhCyAIQS0gCSAKQQFxIAsQtIuAgAAhDCADIAw2AgQgDEEARyEHCwJAIAdBAXFFDQACQCADKAIEQQNqIAMoAgBNQQFxRQ0AIAMoAgQtAAFB/wFxQSpGQQFxRQ0AIAMoAgQtAAJB/wFxQS1GQQFxRQ0AIAMgAygCBDYCDAwDCyADIAMoAgRBAWo2AgQMAQsLIANBADYCDAsgAygCDCENIANBEGokgICAgAAgDQ8LkAEBC38jgICAgABBEGshASABIAA6AA8gAS0AD0H/AXFBJ0YhAkEBIQMgAkEBcSEEIAMhBQJAIAQNACABLQAPQf8BcUEiRiEGQQEhByAGQQFxIQggByEFIAgNACABLQAPQf8BcUE6RiEJQQEhCiAJQQFxIQsgCiEFIAsNACABLQAPQf8BcUE7RiEFCyAFQQFxDwuiAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBAJAAkAgAigCBEEERkEBcUUNACACKAIIQc+QhYAAQQQQw4uAgAANACACQQA2AgwMAQsCQCACKAIEQQVGQQFxRQ0AIAIoAghB5amFgABBBRDDi4CAAA0AIAJBATYCDAwBCyACQQI2AgwLIAIoAgwhAyACQRBqJICAgIAAIAMPC38BB38jgICAgABBEGshAiACIAA2AgwgAiABOgALIAIgAigCDCgClAI2AgQDQCACLQALIQMgAigCBCADOgAdIAIoAgQtAB4hBEEAIQUgBEEBcSEGIAUhBwJAIAYNACACKAIEKAIAIQggAiAINgIEIAhBAEchBwsgB0EBcQ0ACw8L4QEBB38jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQCQAJAIAIoAgRBAExBAXFFDQAgAkEANgIMDAELAkAgAigCCC0AAEH/AXFBgAFIQQFxRQ0AIAIoAggtAABB/wFxQd8ARiEDQQEhBCADQQFxIQUgBCEGAkAgBQ0AIAIoAggtAABB/wFxLQDA2IaAAEH/AXFBAnEhB0EBQQAgBxtBAEchBgsgAiAGQQFxNgIMDAELIAIgAigCCCACKAIEEOOEgIAANgIMCyACKAIMIQggAkEQaiSAgICAACAIDwsrAQJ/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwhAiACIAIoAgBBAXY2AgAPC+sIARN/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYIAJBxAA2AhQgAigCGEEAOgAAAkACQCACKAIcQX8Q9YaAgABB/wFxQTBGQQFxRQ0AIAIoAhwoAtABLQAAQVJqIQMgA0HKAEsaAkACQAJAAkACQAJAAkACQCADDksFBwMDAwMDAwMDBwcHBwcHBwcHBwEHAAYHBwcHBwcHBwcCBwcHBwcHBwcEBwcHBwcHAwcHAQcABgcHBwcHBwcHBwIHBwcHBwcHBwQHCyACKAIcIQQgBCAEKALQAUEBajYC0AECQAJAIAIoAhwQ/IaAgABB/wFxEJKLgIAAQQFxRQ0AIAIoAhwgAigCHCgC0AEQzIeAgAAhBSACKAIcIQYgBiAFIAYoAtABajYC0AEMAQsgAigCHEHfAEH/AXEQ7oaAgAAaIAIoAhxBmwEQgYeAgAALDAYLIAIoAhwhByAHIAcoAtABQQFqNgLQAQJAAkAgAigCHBD8hoCAAEH/AXEQj4uAgABBAXFFDQAgAigCHCACKAIcKALQARDNh4CAACEIIAIoAhwhCSAJIAggCSgC0AFqNgLQAQwBCyACKAIcQd8AQf8BcRDuhoCAABogAigCHEGaARCBh4CAAAsgAigCHEEEOwHcAgwFCyACKAIcIQogCiAKKALQAUEBajYC0AECQAJAIAIoAhwQ/IaAgABB/wFxEJGLgIAAQQFxRQ0AIAIoAhwgAigCHCgC0AEQzoeAgAAhCyACKAIcIQwgDCALIAwoAtABajYC0AEMAQsgAigCHEHfAEH/AXEQ7oaAgAAaIAIoAhxBngEQgYeAgAALIAIoAhxBEDsB3AIMBAsgAigCHCACKAIcKALQARDOh4CAACENIAIoAhwhDiAOIA0gDigC0AFqNgLQASACKAIcQRA7AdwCDAMLIAIoAhwhDyAPIA8oAtABQQFqNgLQAQJAAkAgAigCHBD8hoCAAEH/AXEQk4uAgABBAXFFDQAgAigCHCACKAIcKALQARDPh4CAACEQIAIoAhwhESARIBAgESgC0AFqNgLQAQwBCyACKAIcQd8AQf8BcRDuhoCAABogAigCHEGdARCBh4CAAAsgAigCHEEgOwHcAgwCCyACIAIoAhwgAigCGBDQh4CAADYCFAwBCyACIAIoAhwgAigCGBDQh4CAADYCFAsMAQsgAigCHCACKAIcKALQARDMh4CAACESIAIoAhwhEyATIBIgEygC0AFqNgLQASACIAIoAhwgAigCGBDQh4CAADYCFAsCQCACKAIcQQAQ9YaAgABB/wFxQS5GQQFxRQ0AIAIoAhxBARD1hoCAAEH/AXEQkouAgABBAXFFDQAgAiACKAIcKALQATYCECACIAIoAhwoAtABQQJqNgIMIAIgAigCDCACKAIcKAK4ASACKAIMaxCKi4CAACACKAIMajYCDCACKAIcIAIoAhAgAigCDEGcARDEhoCAAAsgAigCFCEUIAJBIGokgICAgAAgFA8LWAEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDCADKAIIKAIEIAMoAggoAgggAygCBBDEhoCAACADQRBqJICAgIAADwugAgECfyOAgICAAEEwayEHIAckgICAgAAgByAANgIoIAcgATYCJCAHIAI2AiAgByADNgIcIAcgBDYCGCAHIAU2AhQgByAGNgIQAkACQCAHKAIkIAcoAiAgBygCHBDoi4CAAA0AIAcgBygCKCgCBDYCDAJAAkAgBygCKCgCBEGAAXFFDQAgBygCKEEIEOeGgIAADAELIAcoAiggBygCGBDnhoCAAAJAIAcoAhhBAUZBAXFFDQAgBygCKEEBOgCAAwsCQCAHKAIQQQFHQQFxRQ0AIAcoAgxBgRRxDQAgBygCKEGBCBDnhoCAACAHIAcoAhA2AiwMAwsLIAcgBygCFDYCLAwBCyAHQQE2AiwLIAcoAiwhCCAHQTBqJICAgIAAIAgPCz8BAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMQRRqENKHgIAAQQFxIQIgAUEQaiSAgICAACACDwtQAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwgAigCCCgCBCACKAIIKAIIENSHgIAAIQMgAkEQaiSAgICAACADDwvHAQECfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFCACIAIoAhgoApQCNgIQIAJBADYCDAJAAkADQCACKAIQQQBHQQFxRQ0BAkAgAigCEEEEaiACKAIUENOHgIAAQX9HQQFxRQ0AIAIgAigCDDYCHAwDCwJAIAIoAhAtAB5BAXFFDQAMAgsgAiACKAIQKAIANgIQIAIgAigCDEEBajYCDAwACwsgAkF/NgIcCyACKAIcIQMgAkEgaiSAgICAACADDwtvAQF/I4CAgIAAQRBrIQIgAiAAOgAPIAIgAToADgJAIAItAA5B/wFxQQFxRQ0AIAIgAi0AD0H/AXFBnwFxOgAPCwJAIAItAA5B/wFxQQJxRQ0AIAIgAi0AD0H/AXFBgAFyOgAPCyACLQAPQf8BcQ8LlgEBAn8jgICAgABBIGshBSAFJICAgIAAIAUgADYCHCAFIAE2AhggBSACNgIUIAUgAzoAEyAFIAQ6ABICQCAFLQATQf8BcUEIcUUNACAFKAIUIQYgBSAFLQASQf8BcTYCACAGQfrthYAAIAUQ9oqAgAALIAUoAhwgBSgCGCAFLQASQf8BcRDEh4CAACAFQSBqJICAgIAADwtWAQJ/I4CAgIAAQRBrIQEgASAAOgAPAkACQCABLQAPQf8BcUE5TEEBcUUNACABLQAPQf8BcUEwayECDAELIAEtAA9B/wFxQQdxQQlqIQILIAJB/wFxDwv9AQEFfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI6AAcCQCADLQAHQf8BcUGAAU5BAXFFDQACQCADKAIMKALwAkEAR0EBcUUNACADKAIMKALwAkHA44eAAEZBAXFFDQAgAygCDCgCoAJBwOOHgABHQQFxRQ0AIAMoAgxBiAJqIQQgAygCDCgCzAEhBSADKAIMKALQASEGIAMgAygCDCgCoAIoAhA2AgAgBCAFIAZBuQEgAxDhhICAABoLIAMoAgwoAqACIQcgAygCDCAHNgLwAgsgAygCCCADLQAHQf8BcRD6ioCAACADQRBqJICAgIAADwuNAgECfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIYIAMgATYCFCADIAI2AhAgA0EANgIMIANBADYCCAJAA0AgAygCCCADKAIQSUEBcUUNAQJAIAMoAghFDQAgAyADKAIMQQR0NgIMCyADIAMoAhQgAygCCGotAABB/wFxEMOHgIAAQf8BcSADKAIMcjYCDCADIAMoAghBAWo2AggMAAsLAkACQCADKAIMQYCwA09BAXFFDQAgAygCDEH/vwNNQQFxRQ0AIAMoAhggAygCFCADKAIUIAMoAhBqQdAAEMSGgIAAIANB/f8DNgIcDAELIAMgAygCDDYCHAsgAygCHCEEIANBIGokgICAgAAgBA8LzAIBBH8jgICAgABBIGshBiAGJICAgIAAIAYgADYCHCAGIAE2AhggBiACOgAXIAYgAzYCECAGIAQ2AgwgBiAFNgIIAkACQCAGKAIIQYABT0EBcQ0AIAYtABdB/wFxQQRxRQ0BCwJAIAYoAhwoAvACQQBHQQFxRQ0AIAYoAhwoAvACQcDjh4AAR0EBcUUNACAGKAIcQYgCaiEHIAYoAhAhCCAGKAIMIQkgBiAGKAIcKALwAigCEDYCACAHIAggCUG5ASAGEOGEgIAAGgsgBigCHEHA44eAADYC8AILAkAgBigCGCAGKAIIEPuKgIAAQQFxDQAgBigCHCAGKAIQIAYoAgxB0AAQxIaAgAAgBigCGEHvAUH/AXEQ+oqAgAAgBigCGEG/AUH/AXEQ+oqAgAAgBigCGEG9AUH/AXEQ+oqAgAALIAZBIGokgICAgAAPC44CAQp/I4CAgIAAQSBrIQQgBCSAgICAACAEIAA2AhwgBCABOgAbIAQgAjoAGiAEIAM2AhQgBCgCHEH8AWohBSAEKAIcKALMASEGIAQoAhwoAtABIQcCQAJAIAQtABtB/wFxQQFxRQ0AQZqshoAAIQgMAQsgBC0AG0H/AXFBAnEhCUGWrIaAAEGHwoaAACAJGyEICyAIIQoCQAJAIAQtABpB/wFxQQFxRQ0AQZqshoAAIQsMAQsgBC0AGkH/AXFBAnEhDEGWrIaAAEGHwoaAACAMGyELCyALIQ0gBCAEKAIUNgIIIAQgDTYCBCAEIAo2AgAgBSAGIAdBtgIgBBDhhICAABogBEEgaiSAgICAAA8L2wMBD38jgICAgABBIGshBCAEJICAgIAAIAQgADYCHCAEIAE2AhggBCACNgIUIAQgAzoAEwJAAkAgBCgCHC0AgwNBAXFFDQAgBCgCHCgCoAIoAgAhBSAEIAQoAhwoAtABIAQoAhwoArgBIAQoAhwoAtABayAFEYCAgIAAgICAgAA2AgwMAQsgBCAEKAIcKALQASAEKAIcKAK4ASAEKAIcKALQAWsQ44SAgAA2AgwLAkACQCAEKAIMQQFGQQFxRQ0AIAQoAhwhBiAEKAIYIQcgBCgCFCEIIAQtABMhCSAEKAIcIQogCigC0AEhCyAKIAtBAWo2AtABIAstAAAhDCAELQATIQ0gDEH/AXEgDUH/AXEQwYeAgAAhDiAGIAcgCCAJQf8BcSAOQf8BcRDCh4CAAAwBCwJAAkAgBCgCDEEBS0EBcUUNAAJAAkAgBC0AE0H/AXFBCHFFDQAgBCgCFCEPDAELIAQoAhghDwsgBCAPNgIIIAQoAgggBCgCHCgC0AEgBCgCDBD5ioCAACAEKAIMIRAgBCgCHCERIBEgECARKALQAWo2AtABDAELIAQoAhwhEiASIBIoAtABQQFqNgLQASAEKAIcQcsAEIGHgIAACwsgBEEgaiSAgICAAA8LxAEBBH8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAAkAgASgCDC0AgwNBAXFFDQAgASgCDCgCoAIoAgAhAiABIAEoAgwoAtABIAEoAgwoArgBIAEoAgwoAtABayACEYCAgIAAgICAgAA2AggMAQsgASABKAIMKALQASABKAIMKAK4ASABKAIMKALQAWsQ44SAgAA2AggLAkACQCABKAIIDQBBASEDDAELIAEoAgghAwsgAyEEIAFBEGokgICAgAAgBA8LlQEBA38jgICAgABBEGshASABIAA6AA4gASABLQAOQf8BcTYCCAJAAkACQCABKAIIQSBNQQFxDQAgASgCCCECQf4AIAJJQQFxRQ0BCyABQQBBAXE6AA8MAQsgASgCCEEga0EFdiEDIAFBsOiIgAAgA0ECdGooAgAgASgCCEEfcXZBAXFBAEdBAXE6AA8LIAEtAA9BAXEPC4gBAQF/I4CAgIAAQRBrIQIgAiAANgIIIAIgATYCBCACQQA2AgACQAJAA0AgAigCACACKAIESUEBcUUNAQJAIAIoAgggAigCAGotAABB/wFxQYABcUUNACACQQBBAXE6AA8MAwsgAiACKAIAQQFqNgIADAALCyACQQFBAXE6AA8LIAItAA9BAXEPC38BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEANgIEIAIgAigCCCACKAIMKAK4ASACKAIIayACQQRqEIyLgIAANgIAIAIoAgwgAigCCCACKAIAIAIoAgQQ0YeAgAAgAigCACEDIAJBEGokgICAgAAgAw8LfwECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACQQA2AgQgAiACKAIIIAIoAgwoArgBIAIoAghrIAJBBGoQh4uAgAA2AgAgAigCDCACKAIIIAIoAgAgAigCBBDRh4CAACACKAIAIQMgAkEQaiSAgICAACADDwt/AQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAJBADYCBCACIAIoAgggAigCDCgCuAEgAigCCGsgAkEEahCJi4CAADYCACACKAIMIAIoAgggAigCACACKAIEENGHgIAAIAIoAgAhAyACQRBqJICAgIAAIAMPC38BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEANgIEIAIgAigCCCACKAIMKAK4ASACKAIIayACQQRqEI6LgIAANgIAIAIoAgwgAigCCCACKAIAIAIoAgQQ0YeAgAAgAigCACEDIAJBEGokgICAgAAgAw8L5gQBDH8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAkHEADYCAAJAAkAgAigCCBD8hoCAAEH/AXFBLkZBAXFFDQACQAJAIAIoAghBARD1hoCAAEH/AXEQkouAgABBAXFFDQAgAigCCCEDIAMgAygC0AFBAmo2AtABIAIoAgggAigCCCgC0AEQzIeAgAAhBCACKAIIIQUgBSAEIAUoAtABajYC0AEgAkE2NgIADAELIAIgAigCADYCDAwCCwsCQAJAIAIoAggQ/IaAgABB/wFx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AjACQCADKAIwQQBHQQFxRQ0AIANBKGpBADYCACADQgA3AyAgAygCPEHMAmohBCADKAI8KALsAiEFIAMoAjwoAqACKAIQIQYgAygCMCEHIANBIGogBCAFIAYgBxDoioCAACADKAI8QfwBaiEIIAMoAjAoAgghCSADKAIwKAIMIQogA0EgahDzioCAACELIANBIGoQ8oqAgAAhDCADKAI8QcwCaiENIAMoAjQoAgghDiADKAI8KALsAiEPIANBGGogDSAOIA8QuYuAgAAgAyADKAIYNgIIIAMgDDYCBCADIAs2AgAgCCAJIApBsAIgAxDhhICAABogA0EgahD/ioCAAAsgA0HAAGokgICAgAAPCzsBAX8jgICAgABBEGshAiACIAE2AgwgAEGkATYCACAAIAIoAgwoArQBNgIEIAAgAigCDCgCtAE2AggPC6ACAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkAgAigCDCgCEA0AIAIoAgwoAhxBAEdBAXENACACKAIIKAIIIQMgAigCDCADNgIICyACKAIMQRBqIAIoAggQr4aAgAAgAigCCCgCDCEEIAIoAgwgBDYCDAJAAkAgAigCCC8BAEH//wNxQQZGQQFxDQAgAigCCC8BAEH//wNxQcEARkEBcQ0AIAIoAggvAQBB//8DcUH6AEZBAXENACACKAIILwECQf//A3FBAnENAQsgAigCDEECQf//A3EQioiAgAALAkAgAigCCC8BAEH//wNxQYsBRkEBcUUNACACKAIMQQRB//8DcRCyh4CAAAsgAkEQaiSAgICAAA8L1QEBA38jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIIKAIAQSBGQQFxDQAgAigCCCgCAEGVAUZBAXENACACKAIIKAIAQaMBRkEBcQ0AIAIoAggoAgBBpAFGQQFxDQBBi5KGgABB+NKFgABB5BBByaiEgAAQgYCAgAAACyACKAIIKAIIIQMgAigCDCADNgIMIAIoAgxBJGohBCACIAIoAggoAgQ2AgAgAiACKAIIKAIINgIEIAQgAikCADcCACACQRBqJICAgIAADws4AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEEYahC6h4CAACABQRBqJICAgIAADwucAQECfyOA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IAIgAigCKCgCCEF/ajYCDCACIAYgAkEEahCEiICAADYCICADIAIpAhA3AgBBECEHIAMgB2ogByACQRBqaigCADYCAEEIIQggAyAIaiAIIAJBEGpqKQIANwIAIAIoAiQhCSACQTBqJICAgIAAIAkPC5ICAQd/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYAkAgAigCGCgCAEH6AEZBAXENAEH1j4aAAEH40oWAAEHNMEGdooWAABCBgICAAAALIAIgAigCHEEUELSHgIAANgIUIAIoAhQhAyACQe8AOwEAIAJBADsBAiACKAIcIQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgQgAiACKAIYKAIENgIIIAIgAigCGCgCCDYCDCACIAIoAhwgAigCGBDDiYCAADYCECADIAIpAgA3AgBBECEGIAMgBmogAiAGaigCADYCAEEIIQcgAyAHaiACIAdqKQIANwIAIAIoAhQhCCACQSBqJICAgIAAIAgPC+EBAQd/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYIAIgAigCHEEUELSHgIAANgIUIAIoAhQhAyACQT47AQAgAkEAOwECIAIoAhwhBCAEKAIAQQFqIQUgBCAFNgIAIAIgBTYCBCACIAIoAhgoAgQ2AgggAiACKAIYKAIINgIMIAIgAigCHCACKAIYEL+HgIAANgIQIAMgAikCADcCAEEQIQYgAyAGaiACIAZqKAIANgIAQQghByADIAdqIAIgB2opAgA3AgAgAigCFCEIIAJBIGokgICAgAAgCA8LkAIBB38jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQCACKAIYKAIAQRdGQQFxDQBBz4+GgABB+NKFgABBuhJB+qGFgAAQgYCAgAAACyACIAIoAhxBFBC0h4CAADYCFCACKAIUIQMgAkEKOwEAIAJBADsBAiACKAIcIQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgQgAiACKAIYKAIENgIIIAIgAigCGCgCCDYCDCACIAIoAhwgAigCGBC/h4CAADYCECADIAIpAgA3AgBBECEGIAMgBmogAiAGaigCADYCAEEIIQcgAyAHaiACIAdqKQIANwIAIAIoAhQhCCACQSBqJICAgIAAIAgPC4ICAQJ/I4CAgIAA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RQ0AIAJBADYCECACQQA2AhQgAyACKQIQNwIADAELIAIgAigCGCgCBDYCCCACIAIoAhgoAgg2AgwgAyACKQIINwIACyACKAIYKAIIIQQgAigCHCAENgIMDwudAwENfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgA0EBOgATIANBADYCDCADQQA2AgQDQCADKAIEIAMoAhgoAgBJIQRBACEFIARBAXEhBiAFIQcCQCAGRQ0AIAMoAhgoAgggAygCBEECdGooAgAhCCADIAg2AgggCEEARyEHCwJAIAdBAXFFDQACQAJAIAMoAggvAQBB//8DcUGNAUZBAXENACADKAIIIQkgAygCGCgCCCEKIAMoAgwhCyADIAtBAWo2AgwgCiALQQJ0aiAJNgIAIANBADoAEwwBCyADIAMoAgg2AgACQCADLQATQQFxRQ0AIAMoAgBBKGogAygCFBCUiICAAAsCQAJAIAMoAgAoAiwNACADKAIcIAMoAggQtIaAgAAMAQsgAygCCCEMIAMoAhgoAgghDSADKAIMIQ4gAyAOQQFqNgIMIA0gDkECdGogDDYCAAsgA0EBOgATCyADIAMoAgRBAWo2AgQMAQsLIAMoAgwhDyADKAIYIA82AgAgA0EgaiSAgICAAA8LkgIBB38jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQCACKAIYKAIAQcMARkEBcQ0AQYOHhoAAQfjShYAAQfsnQdShhYAAEIGAgIAAAAsgAiACKAIcQRQQtIeAgAA2AhQgAigCFCEDIAJBzwA7AQAgAkEAOwECIAIoAhwhBCAEKAIAQQFqIQUgBCAFNgIAIAIgBTYCBCACIAIoAhgoAgQ2AgggAiACKAIYKAIINgIMIAIgAigCHCACKAIYEL+HgIAANgIQIAMgAikCADcCAEEQIQYgAyAGaiACIAZqKAIANgIAQQghByADIAdqIAIgB2opAgA3AgAgAigCFCEIIAJBIGokgICAgAAgCA8LpAQBD38jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABOwE6IAMgAjYCNAJAIAMoAjQoAgBBxABGQQFxDQBB8vaFgABB+NKFgABBliZBlpmFgAAQgYCAgAAACyADIAMoAjxBIBC0h4CAADYCMCADKAIwIQQg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KAI0IQMgAkGUATsBBCACQQA7AQYgAigCPCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIIIAIgAigCOCgCBDYCDCACQQA2AhAgAiACKAI4KAIENgIUIAIgAigCOCgCCDYCGCACQQA2AhwgAkEANgIgIAJBADYCJCACQQA2AiggAkEANgIsIAJBADYCMCADIAIpAgQ3AgBBKCEGIAMgBmogBiACQQRqaikCADcCAEEgIQcgAyAHaiAHIAJBBGpqKQIANwIAQRghCCADIAhqIAggAkEEamopAgA3AgBBECEJIAMgCWogCSACQQRqaikCADcCAEEIIQogAyAKaiAKIAJBBGpqKQIANwIAIAIoAjQhCyACQcAAaiSAgICAACALDwtYAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAggoAgwhAyACKAIMIAM2AgwgAigCDEEYaiACKAIIEK+GgIAAIAJBEGokgICAgAAPC6ECAQx/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADKAIsQcwCaiADKAIsKALsAiADKAIoIAMoAiRBAEEBcRDcioCAACEEIAMgBDYCIAJAIARBAEdBAXFFDQAgAygCLEH8AWohBSADKAIkKAIIIQYgAygCJCgCDCEHIAMoAixBzAJqIQggAygCJCgCCCEJIAMoAiwoAuwCIQogA0EYaiAIIAkgChC5i4CAACADKAIYIQsgAygCLEHMAmohDCADKAIgKAIIIQ0gAygCLCgC7AIhDiADQRBqIAwgDSAOELmLgIAAIAMgAygCEDYCBCADIAs2AgAgBSAGIAdBsQIgAxDhhICAABoLIANBMGokgICAgAAPC2ABA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAggoAgghAyACKAIMIAM2AgwgAigCDEEkaiEEIAIgAigCCCgCBDYCACACIAIoAggoAgg2AgQgBCACKQIANwIADwtdAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCAJAIAIoAggoAgwgAigCDCgCDEtBAXFFDQAgAigCCCgCDCEDIAIoAgwgAzYCDAsgAigCCCEEIAIoAgwgBDYCLA8LjQEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCAC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BDYCBAwACwsgAkEQaiSAgICAAA8L/gIBDH8jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkAkAgAygCKCgCAEHYAEZBAXENAEH47oWAAEH40oWAAEHGL0HYloWAABCBgICAAAALIAMgAygCLEEcELSHgIAANgIgIAMoAiAhBCADQQRqIQUgA0HrADsBBCADQQA7AQYgAygCLCEGIAYoAgBBAWohByAGIAc2AgAgAyAHNgIIIAVBCGohCCADIAMoAigoAgQ2AgwgCEEEaiEJAkACQCADKAIkQQBGQQFxRQ0AIAMoAigoAgghCgwBCyADKAIkKAIMIQoLIAkgCjYCACADIAMoAiQ2AhQgAyADKAIoKAIENgIYIAMgAygCKCgCCDYCHCAEIAMpAgQ3AgBBGCELIAQgC2ogCyADQQRqaigCADYCAEEQIQwgBCAMaiAMIANBBGpqKQIANwIAQQghDSAEIA1qIA0gA0EEamopAgA3AgAgAygCICEOIANBMGokgICAgAAgDg8LzgIBDH8jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkIAMgAygCLEEcELSHgIAANgIgIAMoAiAhBCADQQRqIQUgA0GEATsBBCADQQA7AQYgAygCLCEGIAYoAgBBAWohByAGIAc2AgAgAyAHNgIIIAVBCGohCCADIAMoAigoAgQ2AgwgCEEEaiEJAkACQCADKAIkQQBGQQFxRQ0AIAMoAigoAgghCgwBCyADKAIkKAIMIQoLIAkgCjYCACADIAMoAigoAgQ2AhQgAyADKAIoKAIINgIYIAMgAygCJDYCHCAEIAMpAgQ3AgBBGCELIAQgC2ogCyADQQRqaigCADYCAEEQIQwgBCAMaiAMIANBBGpqKQIANwIAQQghDSAEIA1qIA0gA0EEamopAgA3AgAgAygCICEOIANBMGokgICAgAAgDg8LqQIBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEAOgAHIAIgAigCDCgCmAI2AgACQAJAA0AgAigCAEEAR0EBcUUNASACKAIAKAIAIQMgA0E1SxoCQAJAAkACQAJAAkACQCADDjYEAAAAAAMDAwMDAAACAgICAwMDAwMAAAAAAAAAAAMDAwMDAAACAgICAAAAAAAA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AgBBICEHIAMgB2ogByACQQhqaikCADcCAEEYIQggAyAIaiAIIAJBCGpqKQIANwIAQRAhCSADIAlqIAkgAkEIamopAgA3AgBBCCEKIAMgCmogCiACQQhqaikCADcCACACKAI0IQsgAkHAAGokgICAgAAgCw8LpQEBA38jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIMKAIIIAIoAggoAghLQQFxRQ0AIAIoAggoAgghAyACKAIMIAM2AggLAkAgAigCDCgCDCACKAIIKAIMSUEBcUUNACACKAIIKAIMIQQgAigCDCAENgIMCyACKAIMIAIoAgxBGGogAigCCBCGioCAACACQRBqJICAgIAADwuaAQEDfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCGEEkaiEEIAMgAygCFCgCBDYCDCADIAMoAhQoAgg2AhAgBCADKQIMNwIAIAMoAhQoAgghBSADKAIYIAU2AgwgAygCGCADKAIcIAMoAhQQh4qAgABB//8DcRCyh4CAACADQSBqJICAgIAADwuHAQEGfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgATYCGCAEIAI2AhQgBCADNgIQIAQoAhwhBSAEKAIYIQYgBCgCFCEHIAQoAhAhCCAEQQA2AgQgBEEANgIIIARBADYCDCAFIAYgByAIIARBBGoQkYiAgAAhCSAEQSBqJICAgIAAIAkPC10BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCACKAIMQRhqIAIoAggQhoqAgAAgAigCCCgCDCEDIAIoAgwgAzYCDCACQRBqJICAgIAADwucBAEUfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCPCACIAE2AjggAigCOCEDAkACQAJAIANB1wBGDQACQAJAIANB3gBGDQACQCADQYMBRg0AIANBhgFGDQEgA0GRAkYNAyADQZICRg0CDAQLIAIoAjxBiAJqIQQgAigCPCgCwAEhBSACKAI8KALEASEGIAIoAjghByACIAIoAjwoArwBEPCKgIAANgIAIAQgBSAGIAcgAhDhhICAABoMBAsgAigCPEGIAmohCCACKAI8KALMASEJIAIoAjwoAtABIQogAigCOCELIAIgAigCPCgCyAEQ8IqAgAA2AhAgCCAJIAogCyACQRBqEOGEgIAAGgwDCwJAAkAgAigCPCgCyAFBAUZBAXFFDQBBoYyEgAAhDAwBCyACKAI8KALIARDwioCAACEMCyACIAw2AjQgAigCPEGIAmohDSACKAI8KALAASEOIAIoAjwoAsQBIQ8gAigCOCEQIAIoAjQhESACIAIoAjwoAsABLQAAQf8BcTYCJCACIBE2AiAgDSAOIA8gECACQSBqEOGEgIAAGgwCCyACKAI8QYgCaiESIAIoAjwoAswBIRMgAigCPCgC0AEhFCACKAI4IRUgAiACKAI8KALIARDwioCAADYCMCASIBMgFCAVIAJBMGoQ4YSAgAAaDAELIAIoAjwgAigCOBDgh4CAAAsgAkHAAGokgICAgAAPC+sBAQZ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjoAByADKAIMIQQgAygCCCEFIAMtAAchBkEAIQcgAyAEIAUgBkEBcSAHQQFxENmIgIAANgIAAkAgAygCDEExEKKHgIAAQQFxDQACQCADKAIMQRsQ/oaAgABBAXFFDQAgAygCDEEKEKKHgIAAQQFxDQELAkAgAygCDEEpEP6GgIAAQQFxRQ0AIAMoAgxBDxCih4CAAEEBcQ0BCyADKAIMIAMoAgBBogIQ8oeAgAALIAMoAgAhCCADQRBqJICAgIAAIAgPC7gCAQd/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiwgBCABNgIoIAQgAjYCJCAEIAM2AiAgBCgCLCAEKAIkELOJgIAAIAQgBCgCLCAEKAIkEIWKgIAAQf//A3EQwYmAgAA2AhwgBCgCKCgCBCEFIAQoAhwgBTYCCCAEKAIkKAIMIQYgBCgCHCAGNgIMIAQoAiQhByAEKAIcIAc2AhAgBCgCHEEgaiEIAkACQCAEKAIoKAIAQaQBRkEBcUUNACAEQQA2AhQgBEEANgIYIAggBCkCFDcCAAwBCyAEIAQoAigoAgQ2AgwgBCAEKAIoKAIINgIQIAggBCkCDDcCAAsgBCgCLCAEKAIgIAQoAiAQgYyAgAAQpoeAgAAhCSAEKAIcIAk2AhwgBCgCHCEKIARBMGokgICAgAAgCg8L+QgBAn8jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkIAMoAigvAQBBfGohBCAEQYsBSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAEDowBABEREREREQMREREREREREREREREREREREREREQsREREREREREREREQwREREREREREREKERERERERERERDREREQoREREREREREREREREOBxEGCAkREREREREREREREQ8REREREREREBEREREREREBEQIREREREQQKEQURERERERERERERCggKEREIEQkRCyADIAMoAig2AiAgAygCLCADKAIgKAIQQQAQ94iAgAAgAygCLCADKAIgKAIUQQAQ94iAgAAMEQsgAyADKAIoNgIcIAMoAiwgAygCHCgCEEEAEPeIgIAAIAMoAiwgAygCHCgCFEEAEPeIgIAADBALIAMgAygCKDYCGAJAIAMoAhgoAhBBAEdBAXFFDQAgAygCGCgCEC8BAEH//wNxQYwBRkEBcUUNACADIAMoAhgoAhA2AhQCQCADKAIUKAIQQQFGQQFxRQ0AIAMoAiwgAygCFCgCGCgCACADKAIkEPeIgIAACwsMDwsgAyADKAIoNgIQAkAgAygCECgCGEEAR0EBcUUNACADIAMoAhAoAhg2AgwCQCADKAIMKAIQQQFGQQFxRQ0AIAMoAiwgAygCDCgCGCgCACADKAIkEPeIgIAACwsMDgsgAyADKAIoNgIIAkAgAygCCCgCEEEAR0EBcUUNACADKAIsIAMoAggoAhBBARD3iICAAAsCQCADKAIIKAIUQQBHQQFxRQ0AIAMoAiwgAygCCCgCFEEBEPeIgIAACyADKAIoQTU7AQAMDQsgAygCKEHjADsBAAJAIAMoAiwtAPwCQf8BcUECcQ0AIAMoAiwgAygCKCADKAIkQboCQYK/hoAAEIqKgIAACwwMCyADKAIoQdMAOwEAAkAgAygCLC0A/AJB/wFxQQJxDQAgAygCLCADKAIoIAMoAiRBuwJBgr+GgAAQioqAgAALDAsLAkACQCADKAIkQQFGQQFxRQ0AAkAgAygCLC0A/AJB/wFxQQJxDQAgAygCLCADKAIoQbUCEN2HgIAACwwBCyADKAIsIAMoAiggAygCJEG7AkGHwoaAABCKioCAAAsMCgsgAygCLCADKAIoIAMoAiRBugJBkb+GgAAQioqAgAAMCQsg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KAIAIQMCQAJAAkACQCADQe4ARg0AIANBowFGDQEMAgsgAigCXCEEIAJByABqIAQQ6IeAgAAgAkHvADYCPCACIAIoAlgoAghBf2o2AkAgAiACKAJYKAIINgJEIAJB7gA2AjAgAiACKAJYKAIENgI0IAIgAigCWCgCCEF/ajYCOCACIAIoAlwgAkHIAGogAkEwaiACQTxqEL6JgIAANgJUAkAgAigCOCACKAI0a0EATkEBcQ0AQcekhoAAQfjShYAAQfM5QemVhYAAEIGAgIAAAAsgAigCVEEoaiACKAI0IAIoAjgQu4uAgAAgAigCVCEFIAIoAlwhBiACKAJUQShqIQcgBSAGIAJBMGogB0EAQQFxEL+JgIAAQf//A3EQsoeAgAAMAgsgAigCXCEIIAJBJGogCBDoh4CAACACKAJcIQkgAkEYaiAJEOiHgIAAIAJB7gA2AgwgAiACKAJYKAIENgIQIAIgAigCWCgCCDYCFCACIAIoAlwgAkEkaiACQQxqIAJBGGoQvomAgAA2AlQMAQtB5r6GgABB+NKFgABBgjpB6ZWFgAAQgYCAgAAACyACKAJUIQogAkHgAGokgICAgAAgCg8L+wEBBX8jgICAgABBMGshAiACJICAgIAAIAIgADYCLCACIAE2AiggAiACKAIsQSBB//8DcRDBiYCAADYCJCACKAIkQQhqIQMgAiACKAIoKAIENgIcIAIgAigCKCgCCDYCICADIAIpAhw3AgAgAigCJEEgaiEEAkACQCACKAIoKAIAQaQBRkEBcUUNACACQQA2AhQgAkEANgIYIAQgAikCFDcCAAwBCyACIAIoAigoAgQ2AgwgAiACKAIoKAIINgIQIAQgAikCDDcCAAsgAigCLCACKAIoEL+HgIAAIQUgAigCJCAFNgIcIAIoAiQhBiACQTBqJICAgIAAIAYPC3ABAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMgAygCDCADKAIIEL+HgIAANgIAIAMoAgwgAygCCCADKAIAIAMoAgRBAEEBcRCVioCAACEEIANBEGokgICAgAAgBA8L1AEBCH8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAiACKAIcQRQQtIeAgAA2AhQgAigCFCEDIAIhBCACQcUAOwEAIAJBADsB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AigCVBCwjICAACACIAIrAzg5A2gLIAIrA2ghHCACQfAAaiSAgICAACAcDwveAwELfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIsIAIgATYCKCACIAIoAigoAgRBAWo2AiQgAiACKAIoKAIINgIgIAIgAigCICACKAIkazYCHAJAIAIoAhxBAEpBAXENAEHso4aAAEH40oWAAEGpMEGW14SAABCBgICAAAALIAIgAigCHDYCGCACIAIoAhhBAWpBARC3jICAADYCFCACKAIUIQMgAigCJCEEIAIoAhghBQJAIAVFDQAgAyAEIAX8CgAACyACKAIUIAIoAhhqQQA6AAAQ0IuAgABBADYCACACIAIoAhQgAkEQakEKEJeMgIAANgIMAkACQCACKAIUIAIoAhBGQQFxDQAgAigCEC0AACEGQRghByAGIAd0IAd1RQ0BCyACKAIsIAIoAiQgAigCIEGbARDEhoCAACACQQA2AgwLIAIoAhQQsIyAgAACQAJAENCLgIAAKAIAQcQARkEBcQ0AIAIoAgxB/////wNLQQFxRQ0BCyACKAIsQfwBaiEIIAIoAiQhCSACKAIgIQogAigCGEEBaiELIAIgAigCKCgCBDYCBCACIAs2AgAgCCAJIApBuAIgAhDhhICAABogAkEANgIMCyACKAIMIQwgAkEwaiSAgICAACAMDwvrBAEGfyOAgICAAEEwayEBIAEkgICAgAAgASAANgIoIAEgASgCKCABKAIoQbwBahC/h4CAADYCJCABIAEoAigoAsABIAEoAigoAsQBEI+HgIAAQQFxOgAfAkACQCABLQAfQQFxDQAgASgCKCABKAIkEMCHgIAAIQIgASACNgIgIAJBf0dBAXFFDQAgASABKAIoIAEoAihBvAFqIAEoAiQgASgCIEEAQQFxEJWKgIAANgIsDAELIAEgASgCKCgClAI2AhgCQCABKAIYLQAeQQFxDQAgASgCGC0AHEH/AXFBEHENAAJAIAEtAB9BAXFFDQAgASABKAIoKALAAS0AAUH/AXFBMGs6ABcgAUEBOgAWAkADQCABLQAWQf8BcSABLQAXQf8BcUxBAXFFDQEgASgCKCEDIAEtABZB/wFxQQFrIQQgA0HQ7IiAACAEQQJ0aigCAEECEI6JgIAAGiABIAEtABZBAWo6ABYMAAsLAkAgASgCKEExEKKH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ICQgIkH//wNxEK+IgIAANgIcCyAEKALMASElIARBEGogJRDoh4CAACAEKALMASEmIAQoAiAhJyAEKAIcISggBCAmICcgBEEQaiAoELCHgIAANgIMAkAgBCgCVEEAR0EBcUUNACAEKALMASAEKAIMQeUBEPKHgIAACyAEKAIMISkgBEGwAWogKRCvhoCAAAsMAAsLIAQoAswBISogBCgCVCErIAQgKiAEQbABaiArEKGKgIAANgIIIAQoArgBELCMgIAAIARB2ABqEOaKgIAAIAQoAgghLCAEQdABaiSAgICAACAsDwuuBAEPfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCOCACIAE2AjQCQCACKAI4KALIAUGgAUZBAXENAEGG+IWAAEH40oWAAEH2hQFBvY6EgAAQgYCAgAAACyACKAI4ENKGgIAAIAIoAjhBvAFqIQNBCCEEIAMgBGooAgAhBSAEIAJBKGpqIAU2AgAgAiADKQIANwMoIAJBADYCJAJAAkAgAigCOEHZABDfh4CAAEEBcUUNACACKAI4IQYgAigCOEG8AWohByACIAYgAkEoaiAHEPiJgIAANgI8DAELAkAgAigCOEHBABDfh4CAAEEBcUUNACACIAIoAjggAigCOEG8AWoQv4eAgAA2AiAgAigCOCACKAIgEMCHgIAAIQggAiAINgIcAkAgCEF/RkEBcUUNACACKAI4IAIoAiAgAigCOCgCwAEgAigCOCgCxAFBABDGhoCAAAsgAigCOCEJIAIoAjQhCiACKAIgIQsgAiACKAI4KALAATYCFCACIAIoAjgoAsQBNgIYIAkgCiALIAJBFGoQooqAgAAgAigCOCEMIAIgAigCOCgCwAE2AgwgAiACKAI4KALEATYCECACKAIgIQ0CQAJAIAIoAhxBf0ZBAXFFDQBBACEODAELIAIoAhwhDgsgDiEPIAIgDCACQQxqIA0gDxD8iYCAADYCJAsgAiACKAI4IAIoAiQgAkEoahC1iYCAADYCPAsgAigCPCEQIAJBwABqJICAgIAAIBAPC6wkAX9/I4CAgIAAQeACayEEIAQkgICAgAAgBCAANgLYAiAEIAE2AtQCIAQgAjYC0AIgBCADOwHOAiAEKALYAigCyAFBamohBSAFQYcBSxoCQAJAAkACQAJAAkACQAJAAkACQCAFDogBBAgICAgC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IAggAkEMamopAgA3AgBBGCEJIAMgCWogCSACQQxqaikCADcCAEEQIQogAyAKaiAKIAJBDGpqKQIANwIAQQghCyADIAtqIAsgAkEMamopAgA3AgAgAkEBNgIIAkADQCACKAIIIAIoAlgoAgBBAWtJQQFxRQ0BIAIoAlRBGGogAigCWCgCCCACKAIIQQJ0aigCABCvhoCAACACIAIoAghBAWo2AggMAAsLIAIoAlQhDCACQeAAaiSAgICAACAMDwvABQESfyOAgICAAEHgAGshAiACJICAgIAAIAIgADYCXCACIAE2AlggAiACKAJcQcAAELSHgIAANgJUIAIoAlQhAyACQQc7ARQgAkEAOwEWIAIoAlwhBCAEKAIAQQFqIQUgBCAFNgIAIAIgBTYCGCACIAIoAlgoAggoAgAoAgg2AhwgAiACKAJYKAIIIAIoAlgoAgBBAWtBAnRqKAIAKAIMNgIgIAJBADYCJCACQQA2AiggAkEANgIsIAJBADYCMCACQQA2AjQgAkEANgI4IAJBADYCPCACQQA2AkAgAkEANgJEIAJBADYCSCACQQA2AkwgAkEANgJQIAMgAikCFDcCAEE4IQYgAyAGaiAGIAJBFGpqKQIANwIAQTAhByADIAdqIAcgAkEUamopAgA3AgBBKCEIIAMgCGogCCACQRRqaikCADcCAEEgIQkgAyAJaiAJIAJBFGpqKQIANwIAQRghCiADIApqIAogAkEUamopAgA3AgBBECELIAMgC2ogCyACQRRqaikCADcCAEEIIQwgAyAMaiAMIAJBFGpqKQIANwIAIAJBADoAEyACQQA2AggDQCACKAIIIAIoAlgoAgBJIQ1BACEOIA1BAXEhDyAOIRACQCAPRQ0AIAIoAlgoAgggAigCCEECdGooAgAhESACIBE2AgwgEUEARyEQCwJAIBBBAXFFDQACQAJAIAItABNBAXENAAJAIAIoAgwvAQBB//8DcUGLAUZBAXENACACKAIMLwEAQf//A3FBxgBGQQFxRQ0BCyACKAIMIRIgAigCVCASNgIgIAJBAToAEwwBCwJAAkAgAi0AE0EBcUUNACACKAJUQSRqIAIoAgwQr4aAgAAMAQsgAigCVEEUaiACKAIMEK+GgIAACwsgAiACKAIIQQFqNgIIDAELCyACKAJUIRMgAkHgAGokgICAgAAgEw8LnwMBDX8jgICAgABB0ABrIQIgAiSAgICAACACIAA2AkwgAiABNgJIIAIgAigCTEHAABC0h4CAADYCRCACKAJEIQMgAkEEaiEEIAJBBzsBBCACQQA7AQYgAigCTCEFIAUoAgBBAWohBiAFIAY2AgAgAiAGNgIIIARBCGogAigCSEEIaikCADcCACACQQA2AhQgAkEANgIYIAJBADYCHCACQQA2AiAgAiACKAJINgIkIAJBADYCKCACQQA2AiwgAkEANgIwIAJBADYCNCACQQA2AjggAkEANgI8IAJBADYCQCADIAIpAgQ3AgBBOCEHIAMgB2ogByACQQRqaikCADcCAEEwIQggAyAIaiAIIAJBBGpqKQIANwIAQSghCSADIAlqIAkgAkEEamopAgA3AgBBICEKIAMgCmogCiACQQRqaikCADcCAEEYIQsgAyALaiALIAJBBGpqKQIANwIAQRAhDCADIAxqIAwgAkEEamopAgA3AgBBCCENIAMgDWogDSACQQRqaikCADcCACACKAJEIQ4gAkHQAGokgICAgAAgDg8LqQMBDH8jgICAgABB0ABrIQIgAiSAgICAACACIAA2AkwgAiABNgJIIAIgAigCTEHAABC0h4CAADYCRCACKAJEIQMgAkGBATsBBCACQQA7AQYgAigCTCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIIIAIgAigCSCgCBDYCDCACIAIoAkgoAgg2AhAgAiACKAJIKAIENgIUIAIgAigCSCgCCDYCGCACQQA2AhwgAkEANgIgIAJBADYCJCACQQA2AiggAkEANgIsIAJBADYCMCACQQA2AjQgAkEANgI4IAJBADYCPCACQQA2AkAgAyACKQIENwIAQTghBiADIAZqIAYgAkEEamopAgA3AgBBMCEHIAMgB2ogByACQQRqaikCADcCAEEoIQggAyAIaiAIIAJBBGpqKQIANwIAQSAhCSADIAlqIAkgAkEEamopAgA3AgBBGCEKIAMgCmogCiACQQRqaikCADcCAEEQIQsgAyALaiALIAJBBGpqKQIANwIAQQghDCADIAxqIAwgAkEEamopAgA3AgAgAigCRCENIAJB0ABqJICAgIAAIA0PC34BAn8jgICAgABBIGshAiACIAA2AhwgAiABNgIYIAIoAhxBJGohAwJAAkAgAigCGCgCAEGkAUZBAXFF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KAI0EOuJgIAACyABKAI8IAFBCGpBARDoiYCAABoLCyABKAI8IAEoAjggASgCNBDwh4CAACABKAI8QQMQ34eAgABBAXENAAsLIAEoAjxBDhDfh4CAABogASgCPEEPQe4AEOyHgIAAIAEoAjggASgCPEG8AWoQsIqAgAAgASgCOCENIAFBwABqJICAgIAAIA0PC1QBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCACKAIIELGKgIAAIAIoAgxBEGogAigCCBCvhoCAACACQRBqJICAgIAADwtUAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwgAigCCBCxioCAACACKAIMQSxqIAIoAggQr4aAgAAgAkEQaiSAgICAAA8L7wEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAigCCCACKAIEKAIEIAIoAgQoAggQzYiAgAAgAiACKAIIIAIoAgQQv4eAgAA2AgACQAJAIAIoAggoApQCQQRqIAIoAgAQ04eAgABBf0dBAXFFDQACQCACKAIEKAIEIAIoAgQoAghJQQFxRQ0AIAIoAgQoAgQtAABB/wFxQd8AR0EBcUUNACACKAIIIAIoAgRB0AEQvIeAgAALIAJBAUEBcToADwwBCyACQQBBAXE6AA8LIAItAA9BAXEhAyACQRBqJICAgIAAIAMPC1wBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgwgAygCCCgCBCADKAIIKAIIIAMoAgQQg4mAgAAhBCADQRBqJICAgIAAIAQPC00BAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgxBMRCih4CAAEEBcUUNACABKAIMQT0Q4IeAgAALIAFBEGokgICAgAAPC5IEAQ5/I4CAgIAAQcAAayEDIAMkgICAgAAgAyAANgI8IAMgATYCOCADIAI2AjQCQCADKAI0KAIAQaQBRkEBcQ0AIAMoAjQoAgBBmAFGQQFxDQAgAygCNCgCAEERRkEBcQ0AQZKRhoAAQfjShYAAQb4TQZ6YhYAAEIGAgIAAAAsgAyADKAI8QSQQtIeAgAA2AjAgAygCMCEEIANBDGohBSADQQ87AQwgA0EAOwEO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aiEFIAQgBTYCACACIAU2AgQgAiACKAIYKAIENgIIIAIgAigCGCgCCDYCDCACIAIoAhwgAigCGBC/h4CAADYCECADIAIpAgA3AgBBECEGIAMgBmogAiAGaigCADYCAEEIIQcgAyAHaiACIAdqKQIANwIAIAIoAhQhCCACQSBqJICAgIAAIAgPC6cCAQh/I4CAgIAAQTBrIQIgAiSAgICAACACIAA2AiwgAiABNgIoIAIgAigCLEEcELSHgIAANgIkIAIoAiQhAyACQf4AOwEIIAJBADsBCiACKAIsIQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgwgAiACKAIoKAIENgIQIAIgAigCKCgCCDYCFCACIAIoAiwgAigCKCgCBCACKAIoKAIIQX9qENSHgIAANgIYIAIgAigCKCgCBDYCHCACIAIoAigoAgg2AiAgAyACKQIINwIAQRghBiADIAZqIAYgAkEIamooAgA2AgBBECEHIAMgB2ogByACQQhqaikCADcCAEEIIQggAyAIaiAIIAJBCGpqKQIANwIAIAIoAiQhCSACQTBqJICAgIAAIAkPC1QBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCACKAIIELGKgIAAIAIoAgxBOGogAigCCBCvhoCAACACQRBqJICAgIAADwuvAgEIfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiQgAyADKAIsQSAQtIeAgAA2AiAgAygCICEEIANB8AA7AQAgA0EAOwECIAMoAiwhBSAFKAIAQQFqIQYgBSAGNgIAIAMgBjYCBCADIAMoAigoAgQ2AgggAyADKAIkKAIMNgIMIAMgAygCLCADKAIoKAIEIAMoAigoAghBf2oQ1IeAgAA2AhAgAyADKAIoKAIENgIUIAMgAygCKCgCCDYCGCADIAMoAiQ2AhwgBCADKQIANwIAQRghByAEIAdqIAMgB2opAgA3AgBBECEIIAQgCGogAyAIaikCADcCAEEIIQkgBCAJaiADIAlqKQIANwIAIAMoAiAhCiADQTBqJICAgIAAIAoPC8IDAQ5/I4CAgIAAQcAAayEDIAMkgICAgAAgAyAANgI8IAMgATYCOCADIAI2AjQgAyADKAI8QSQQtIeAgAA2AjAgAygCMCEEIANBDGoh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FGpqKAIANgIAQSghCCAEIAhqIAggA0EUamopAgA3AgBBICEJIAQgCWogCSADQRRqaikCADcCAEEYIQogBCAKaiAKIANBFGpqKQIANwIAQRAhCyAEIAtqIAsgA0EUamopAgA3AgBBCCEMIAQgDGogDCADQRRqaikCADcCACADQQA2AgwDQCADKAIMIAMoAlgoAgBJIQ1BACEOIA1BAXEhDyAOIRACQCAPRQ0AIAMoAlgoAgggAygCDEECdGooAgAhESADIBE2AhAgEUEARyEQCwJAIBBBAXFFDQAgAygCUEEUaiADKAIQEK+GgIAAIAMgAygCDEEBajYCDAwBCwsgAygCUCESIANB4ABqJICAgIAAIBIPC6oBAQF/I4CAgIAAQRBrIQQgBCSAgICAACAEIAA2AgwgBCABNgIIIAQgAjYCBCAEIAM2AgACQAJAIAQoAgAoAgAtAABB/wFxQd8ARkEBcUUNAAwBCwJAIAQoAgggBCgCBBCXi4CAAEEBcUUNACAEKAIMIAQoAgAoAgAgBCgCACgCBEHbARDEhoCAAAwBCyAEKAIIIAQoAgQQlYuAgAAaCyAEQRBqJICAgIAADwumAwEMfyOAgICAAEHQAGshAyADJICAgIAAIAMgADYCTCADIAE2AkggAyACNgJEIAMgAygCTEHAABC0h4CAADYCQCADKAJAIQQgA0EHOwEAIANBADsBAiADKAJMIQUgBSgCAEEBaiEGIAUgBjYCACADIAY2AgQgAyADKAJIKAIENgIIIAMgAygCRCgCCDYCDCADQQA2AhAgA0EANgIUIANBADYCGCADQQA2AhwgA0EANgIgIANBADYCJCADQQA2AiggA0EANgIsIAMgAygCSCgCBDYCMCADIAMoAkgoAgg2AjQgAyADKAJEKAIENgI4IAMgAygCRCgCCDYCPCAEIAMpAgA3AgBBOCEHIAQgB2ogAyAHaikCADcCAEEwIQggBCAIaiADIAhqKQIANwIAQSghCSAEIAlqIAMgCWopAgA3AgBBICEKIAQgCmogAyAKaikCADcCAEEYIQsgBCALaiADIAtqKQIANwIAQRAhDCAEIAxqIAMgDGopAgA3AgBBCCENIAQgDWogAyANaikCADcCACADKAJAIQ4gA0HQAGokgICAgAAgDg8LRAEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMQRRqIAIoAggQr4aAgAAgAkEQaiSAgICAAA8LjwMBC38jgICAgABB0ABrIQMgAySAgICAACADIAA2AkwgAyABNgJIIAMgAjYCRCADIAMoAkxBNBC0h4CAADYCQCADKAJAIQQgA0HCADsBDCADQQA7AQ4gAygCTCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIQIAMgAygCSCgCBDYCFCADIAMoAkQoAgg2AhggA0EANgIcIANBADYCICADQQA2AiQgA0EANgIoIANBADYCLCADIAMoAkgoAgQ2AjAgAyADKAJIKAIINgI0IAMgAygCRCgCBDYCOCADIAMoAkQoAgg2AjwgBCADKQIMNwIAQTAhByAEIAdqIAcgA0EMamooAgA2AgBBKCEIIAQgCGogCCADQQxqaikCADcCAEEgIQkgBCAJaiAJIANBDGpqKQIANwIAQRghCiAEIApqIAogA0EMamopAgA3AgBBECELIAQgC2ogCyADQQxqaikCADcCAEEIIQwgBCAMaiAMIANBDGpqKQIANwIAIAMoAkAhDSADQdAAaiSAgICAACANDwtwAQJ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADIAMoAgwgAygCCBC/h4CAADYCACADKAIMIAMoAgggAygCACADKAIEQQFBAXEQlYqAgAAhBCADQRBqJICAgIAAIAQPC5UCAQh/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADIAMoAixBHBC0h4CAADYCICADKAIgIQQgA0H2ADsBBCADQQA7AQYgAygCLCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIIIAMgAygCKCgCBDYCDCADIAMoAiQoAgw2AhAgAyADKAIkNgIUIAMgAygCKCgCBDYCGCADIAMoAigoAgg2AhwgBCADKQIENwIAQRghByAEIAdqIAcgA0EEamooAgA2AgBBECEIIAQgCGogCCADQQRqaikCADcCAEEIIQkgBCAJaiAJIANBBGpqKQIANwIAIAMoAiAhCiADQTBqJICAgIAAIAoPC4cDAQp/I4CAgIAAQdAAayEFIAUkgICAgAAgBSAANgJMIAUgATYCSCAFIAI2AkQgBSADNgJAIAUgBDYCPCAFIAUo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QCABKAIMLQAMQQFxRQ0AIAFBARDvioCAACABKAIIczYCCAsgASgCCCECIAFBEGokgICAgAAgAg8LqAMBAn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAkGM5Z66eTYCFCACIAIoAhhBAnY2AgwCQANAIAIoAgxFDQEgAiACKAIcKAAANgIQIAIgAigCHEEEajYCHCACIAIoAhAQ74qAgAAgAigCFHM2AhQgAiACKAIUQQ10IAIoAhRBE3ZyNgIUIAIgAigCFEEFbEHk1tGyfmo2AhQgAiACKAIMQX9qNgIMDAALCyACQQA2AhAgAiACKAIYQQNxNgIIAkADQCACKAIIRQ0BIAIgAigCEEEIdDYCECACIAIoAhwgAigCCEEBa2otAABB/wFxIAIoAhByNgIQIAIgAigCCEF/ajYCCAwACwsgAiACKAIQEO+KgIAAIAIoAhRzNgIUIAIgAigCGCACKAIUczYCFCACIAIoAhRBEHYgAigCFHM2AhQgAiACKAIUQeuUr694bDYCFCACIAIoAhRBDXYgAigCFHM2AhQgAiACKAIUQbXcypV8bDYCFCACIAIoAhRBEHYgAigCFHM2AhQgAigCFCEDIAJBIGokgICAgAAgAw8LVAEBfyOAgICAAEEQayEBIAEgADYCDCABIAEoAgxB0dr45HxsNgIMIAEgASgCDEEPdCABKAIMQRF2cjYCDCABIAEoAgxBk+uc3AFsNgIMIAEoAgwPC7wXAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASgCCEF/aiECIAJBpAFLGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg6lAQAOGiRGSElKTFFYXmV4fI0BAwQFBgcICQoLDA0PEBESExQVFhcYGRscHR4fICEiIyUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUdLTU5PUFJTVFVWV1laW1xdX2BhYmNkZmdoaWprbG1ub3BxcnN0dXZ3eXp7fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAQECpAGlAQsgAUGhjISAADYCDAylAQsgAUH274SAADYCDAykAQsgAUGV8ISAADYCDAyjAQsgAUHVvIaAADYCDAyiAQsgAUHZvIaAADYCDAyhAQsgAUH/u4aAADYCDAygAQsgAUGzvIaAADYCDAyfAQsgAUH6u4aAADYCDAyeAQsgAUGyuoaAADYCDAydAQsgAUHpvIWAADYCDAycAQsgAUHmvIaAADYCDAybAQsgAUGKvIaAADYCDAyaAQsgAUHFtoaAADYCDAyZAQsgAUHXtoaAADYCDAyYAQsgAUHKtoaAADYCDAyXAQsgAUHyuoaAADYCDAyWAQsgAUHyuoaAADYCDAyVAQsgAUHpuoaAADYCDAyUAQsgAUHBu4aAADYCDAyTAQsgAUHuuoaAADYCDAySAQsgAUHluoaAADYCDAyRAQsgAUG8u4aAADYCDAyQAQsgAUHL+oSAADYCDAyPAQsgAUG7toWAADYCDAyOAQsgAUGcvIaAADYCDAyNAQsgAUGXvIaAADYCDAyMAQsgAUG8vIaAADYCDAyLAQsgAUGomISAADYCDAyKAQsgAUGso4SAADYCDAyJAQsgAUGvvIaAADYCDAyIAQsgAUHnqYaAADYCDAyHAQsgAUHmqYaAADYCDAyGAQsgAUGfuIaAADYCDAyFAQsgAUGXuoaAADYCDAyEAQsgAUGIroWAADYCDAyDAQsgAUHbtoaAADYCDAyCAQsgAUHKtoaAADYCDAyBAQsgAUHivIaAADYCDAyAAQsgAUH2u4aAADYCDAx/CyABQdK7hoAANgIMDH4LIAFBzLuGgAA2AgwMfQsgAUGju4aAADYCDAx8CyABQby2hoAANgIMDHsLIAFB/KqEgAA2AgwMegsgAUGzgoSAADYCDAx5CyABQYH9hIAANgIMDHgLIAFBs4KEgAA2AgwMdwsgAUGBuIWAADYCDAx2CyABQa27hoAANgIMDHULIAFBx7uGgAA2AgwMdAsgAUGImoaAADYCDAxzCyABQaaahoAANgIMDHILIAFBy42FgAA2AgwMcQsgAUGqi4WAADYCDAxwCyABQe+/hYAANgIMDG8LIAFB5qyFgAA2AgwMbgsgAUHHuIWAADYCDAxtCyABQePWhIAANgIMDGwLIAFBs4KEgAA2AgwMawsgAUGB/YSAADYCDAxqCyABQbOChIAANgIMDGkLIAFBkLeGgAA2AgwMaAsgAUGkuoaAADYCDAxnCyABQai4hoAANgIMDGYLIAFB+7qGgAA2AgwMZQsgAUGouYaAADYCDAxkCyABQfa5hoAANgIMDGMLIAFBiLeGgAA2AgwMYgsgAUHRuYaAADYCDAxhCyABQY67hoAANgIMDGALIAFBkbiGgAA2AgwMXwsgAUGRuIaAADYCDAxeCyABQee5hoAANgIMDF0LIAFBvLmGgAA2AgwMXAsgAUGeuoaAADYCDAxbCyABQYi7hoAANgIMDFoLIAFB/bmGgAA2AgwMWQsgAUHuuYaAADYCDAxYCyABQfe3hoAANgIMDFcLIAFBxLmGgAA2AgwMVgsgAUHEuYaAADYCDAxVCyABQbC4hoAANgIMDFQLIAFBhrqGgAA2AgwMUwsgAUHytoaAADYCDAxSCyABQaK5hoAANgIMDFELIAFB+baGgAA2AgwMUAsgAUH9t4aAADYCDAxPCyABQYq4hoAANgIMDE4LIAFB3rmGgAA2AgwMTQsgAUGz1oSAADYCDAxMCyABQeC2hoAANgIMDEsLIAFBlriGgAA2AgwMSgsgAUG1uYaAADYCDAxJCyABQYK4hoAANgIMDEgLIAFBvLiGgAA2AgwMRwsgAUHXuYaAADYCDAxGCyABQcm5hoAANgIMDEULIAFB/7aGgAA2AgwMRAsgAUH/toaAADYCDAxDCyABQZq5hoAANgIMDEILIAFBmrmGgAA2AgwMQQsgAUG1uIaAADYCDAxACyABQY+6hoAANgIMDD8LIAFBj7qGgAA2AgwMPgsgAUGquoaAADYCDAw9CyABQba6hoAANgIMDDwLIAFB0LqGgAA2AgwMOwsgAUHFuoaAADYCDAw6CyABQdX5hIAANgIMDDkLIAFBncyEgAA2AgwMOAsgAUHXtoaAADYCDAw3CyABQY+8hoAANgIMDDYLIAFB17uGgAA2AgwMNQsgAUGdu4aAADYCDAw0CyABQZqbhoAANgIMDDMLIAFBjZuGgAA2AgwMMgsgAUHWs4WAADYCDAwxCyABQbi8hoAANgIMDDALIAFB4buGgAA2AgwMLwsgAUGou4aAADYCDAwuCyABQe6shYAANgIMDC0LIAFB+LyFgAA2AgwMLAsgAUHRvIaAADYCDAwrCyABQdG8hoAANgIMDCoLIAFBzbyGgAA2AgwMKQsgAUHevIaAADYCDAwoCyABQYW8hoAANgIMDCcLIAFBsLmGgAA2AgwMJgsgAUHttoaAADYCDAwlCyABQei2hoAANgIMDCQLIAFBg7uGgAA2AgwMIwsgAUH2uoaAADYCDAwiCyABQdO2hoAANgIMDCELIAFBt7uGgAA2AgwMIAsgAUHOtoaAADYCDAwfCyABQbG7hoAANgIMDB4LIAFBwLyGgAA2AgwMHQsgAUHmu4aAADYCDAwcCyABQZm7hoAANgIMDBsLIAFBjYuFgAA2AgwMGgsgAUGjjYWAADYCDAwZCyABQZO8hoAANgIMDBgLIAFBoLyGgAA2AgwMFwsgAUHcu4aAADYCDAwWCyABQcm8hoAANgIMDBULIAFB8buGgAA2AgwMFAsgAUHEvIaAADYCDAwTCyABQeu7hoAANgIMDBILIAFBkvyEgAA2AgwMEQsgAUGzkYSAADYCDAwQCyABQb2NhYAANgIMDA8LIAFB7PqEgAA2AgwMDgsgAUHBtoaAADYCDAwNCyABQdW8hoAANgIMDAwLIAFBl7yGgAA2AgwMCwsgAUGqvIaAADYCDAwKCyABQaS8hoAANgIMDAkLIAFBuLyGgAA2AgwMCAsgAUG4vIaAADYCDAwHCyABQcC8hoAANgIMDAYLIAFBrayGgAA2AgwMBQsgAUGsrIaAADYCDAwECyABQYzMhIAANgIMDAMLIAFB27qGgAA2AgwMAgtB5r6GgABB59eFgABBtwVB9PCEgAAQgYCAgAAAC0HmvoaAAEHn14WAAEG9BUH08ISAABCBgICAAAALIAEoAgwhAyABQRBqJICAgIAAIAMPC3UBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDEEANgIAIAIoAgghAyACKAIMIAM2AgQgAigCCBCujICAACEEIAIoAgwgBDYCCCACKAIMKAIIQQBHQQFxIQUgAkEQaiSAgICAACAFDwsfAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwoAggPCx8BAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCAA8LgwEBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAiACKAIMKAIANgIEAkAgAigCDCACKAIIEPWKgIAAQQFxRQ0AIAIoAgwoAgggAigCBGohAyACKAIIIQRBACEFAkAgBEUNACADIAUgBPwLAAsLIAJBEGokgICAgAAPC44CAQV/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEIAIgAigCCCgCACACKAIEajYCAAJAAkAgAigCACACKAIIKAIES0EBcUUNAAJAIAIoAggoAgQNACACKAIIQQE2AgQLAkADQCACKAIAIAIoAggoAgRLQQFxRQ0BIAIoAgghAyADIAMoAgRBAXQ2AgQMAAsLIAIoAggoAgggAigCCCgCBBCxjICAACEEIAIoAgggBDYCCAJAIAIoAggoAghBAEZBAXFFDQAgAkEAQQFxOgAPDAILCyACKAIAIQUgAigCCCAFNgIAIAJBAUEBcToADwsgAi0AD0EBcSEGIAJBEGokgICAgAAgBg8L4gEBBX8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhghBCADKAIUIQVBACEGIAMgBiAGIAQgBRCpjICAADYCEAJAAkAgAygCEEEASEEBcUUNAAwBCyADIAMoAhBBAWo2AgwgAyADKAIcKAIANgIIIAMoAhwgAygCDBD1ioCAAEEBcUUNACADIAI2AhQgAygCHCgCCCADKAIIaiADKAIMIAMoAhggAygCFBCpjICAABogAygCHCEHIAcgBygCAEF/ajYCAAsgA0EgaiSAgICAAA8LTQEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDCADKAIIIAMoAgQQ+IqAgAAgA0EQaiSAgICAAA8LjgEBBH8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCAD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QAJAIAIoAhRBgICAgHhPQQFxRQ0AIAJBAEEBcToAHwwBCyACIAIoAhQQmouAgAA2AhQgAkEQNgIMIAIgAigCFEEQELeMgIAANgIIAkAgAigCCEEARkEBcUUNACACQQBBAXE6AB8MAQsgAigCCCEDIAIoAhggAzYCACACKAIIIAIoAhRBA3RqIQQgAigCGCAENgIEIAIoAhhBADYCCCACKAIUIQUgAigCGCAFNgIMIAJBAUEBcToAHwsgAi0AH0EBcSEGIAJBIGokgICAgAAgBg8LtQEBAX8jgICAgABBEGshASABIAA2AggCQAJAIAEoAggNACABQQE2AgwMAQsgASABKAIIQX9qNgIIIAEgASgCCEEBdiABKAIIcjYCCCABIAEoAghBAnYgASgCCHI2AgggASABKAIIQQR2IAEoAghyNgIIIAEgASgCCEEIdiABKAIIcjYCCCABIAEoAghBEHYgASgCCHI2AgggASABKAIIQQFqNgIIIAEgASgCCDYCDAsgASgCDA8LhgEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQAJAIAIoAghFDQAgAigCCCACKAIMKAIITUEBcQ0BC0HJj4WAAEHt04WAAEHIAUGbooSAABCBgICAAAALIAIoAgwoAgQgAigCCEEBa0EDdGohAyACQRBqJICAgIAAIAMPCysBAX8jgICAgABBEGshASABIAA2AgwgASgCDCABKAIMQQFrcUEARkEBcQ8LfgEBfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAkGFKjYCBCACQQA2AgACQANAIAIoAgAgAigCCElBAXFFDQEgAiACKAIEQQV0IAIoAgRqIAIoAgwgAigCAGotAABB/wFxajYCBCACIAIoAgBBAWo2AgAMAAsLIAIoAgQPC1MBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgwgAygCCCADKAIEQQAQn4uAgAAhBCADQRBqJICAgIAAIAQPC5YGAQx/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI4IAQgATYCNCAEIAI2AjAgBCADNgIsAkACQCAEKAI4KAIIIAQoAjgoAgxBAnZBA2xPQQFxRQ0AAkAgBCgCOBCgi4CAAEEBcQ0AIARBADYCPAwCCwsC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AAwMCwsCQCANQQpJDQBBASEMDAsLA0AgBCANQQJ0aigCAA0BQQEhDCANQQFqIg1BCkYNCwwACwtBHCEXDAcLIAcgDToAJ0EBIRUgCSEOIAohFyAYIRIMAQsgCiEXCyAVIBcgDmsiASAVIAFKGyITIBFB/////wdzSg0DQT0hFyAUIBEgE2oiECAUIBBKGyINIA9LDQQgAEEgIA0gECASEKSMgIAAIAAgGSAREJ6MgIAAIABBMCANIBAgEkGAgARzEKSMgIAAIABBMCATIAFBABCkjICAACAAIA4gARCejICAACAAQSAgDSAQIBJBgMAAcxCkjICAACAHKAI8IQEMAQsLC0EAIQwMAwtBPSEXCxDQi4CAACAXNgIAC0F/IQwLIAdBwABqJICAgIAAIAwLHAACQCAALQAAQSBxDQAgASACIAAQ4YuAgAAaCwt7AQV/QQAhAQJAIAAoAgAiAiwAAEFQaiIDQQlNDQBBAA8LA0BBfyEEAkAgAUHMmbPmAEsNAEF/IAMgAUEKbCIBaiADIAFB/////wdzSxshBAsgACACQQFqIgM2AgAgAiwAASEFIAQhASADIQIgBUFQaiIDQQpJDQALIAQLvgQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUF3ag4SAAECBQMEBgcICQoLDA0ODxAREgsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIA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ACAAIAlHDQFBACABNgKAtYmAAA8LIAIgCEF+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACwJAIAFB/wFLDQAgAUH4AXFBoLWJgABqIQMCQAJAQQAoAvi0iYAAIgVBASABQQN2dCIBcQ0AQQAgBSABcjYC+LSJgAAgAyEBDAELIAMoAggiASAESQ0DCyADIAA2AgggASAANgIMIAAgAzYCDCAAIAE2AggPC0EfIQMCQCABQf///wdLDQAgAUEmIAFBCHZnIgNrdkEBcSADQQF0a0E+aiEDCyAAIAM2AhwgAEIANwIQIANBAnRBqLeJgABqIQUCQAJAAkBBACgC/LSJgAAiBkEBIAN0IgJxDQBBACAGIAJyNgL8tImAACAFIAA2AgAgACAFNgIYDAELIAFBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhBgNAIAYiBSgCBEF4cSABRg0CIANBHXYhBiADQQF0IQMgBSAGQQRxaiICKAIQIgYNAAsgAkEQaiIBIARJDQMgASAANgIAIAAgBTYCGAsgACAANgIMIAAgADYCCA8LIAUgBEkNASAFKAIIIgEgBEkNASABIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACABNgIICw8LENKLgIAAAAtrAgF/AX4CQAJAIAANAEEAIQIMAQsgAK0gAa1+IgOnIQIgASAAckGAgARJDQBBfyACIANCIIinQQBHGyECCwJAIAIQroyAgAAiAEUNACAAQXxqLQAAQQNxRQ0AIABBACACENeLgIAAGgsgAAsHAD8AQRB0C2QCAX4BfwJAAkAgAK1CB3xC+P///x+DQQAoApSqiYAAIgCtfCIBQv////8PVg0AELiMgIAAIAGnIgJPDQEgAhCegICAAA0BCxDQi4CAAEEwNgIAQX8PC0EAIAI2ApSqiYAAIAALgAsHAX8BfgF/An4BfwF+AX8jgICAgABB8ABrIgUkgICAgAAgBEL///////////8AgyEGAkACQAJAIAFQIgcgAkL///////////8AgyIIQoCAgICAgMCAgH98QoCAgICAgMCAgH9UIAhQGw0AIANCAFIgBkKAgICAgIDAgIB/fCIJQoCAgICAgMCAgH9WIAlCgICAgICAwICAf1EbDQELAkAgByAIQoCAgICAgMD//wBUIAhCgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEEIAEhAwwCCwJAIANQIAZCgICAgICAwP//AFQgBkKAgICAgIDA//8AURsNACAEQoCAgICAgCCEIQQMAgsCQCABIAhCgICAgICAwP//AIWEQgBSDQBCgICAgICA4P//ACACIAMgAYUgBCAChUKAgICAgICAgIB/hYRQIgcbIQRCACABIAcbIQMMAgsgAyAGQoCAgICAgMD//wCFhFANAQJAIAEgCIRCAFINACADIAaEQgBSDQIgAyABgyEDIAQgAoMhBAwCCyADIAaEUEUNACABIQMgAiEEDAELIAMgASADIAFWIAYgCFYgBiAIURsiChshBiAEIAIgChsiCUL///////8/gyEIIAIgBCAKGyILQjCIp0H//wFxIQwCQCAJQjCIp0H//wFxIgcNACAFQeAAaiAGIAggBiAIIAhQIgcbeULAAEIAIAcbfKciB0FxahC7jICAAEEQIAdrIQcgBSkDaCEIIAUpA2AhBgsgASADIAobIQMgC0L///////8/gyEBAkAgDA0AIAVB0ABqIAMgASADIAEgAVAiCht5QsAAQgAgCht8pyIKQXFqELuMgIAAQRAgCmshDCAFKQNYIQEgBSkDUCEDCyABQgOGIANCPYiEQoCAgICAgIAEhCEBIAhCA4YgBkI9iIQhCyADQgOGIQggBCAChSEDAkAgByAMRg0AAkAgByAMayIKQf8ATQ0AQgAhAUIBIQgMAQsgBUHAAGogCCABQYABIAprELuMgIAAIAVBMGogCCABIAoQxYyAgAAgBSkDMCAFKQNAIAUpA0iEQgBSrYQhCCAFKQM4IQELIAtCgICAgICAgASEIQsgBkIDhiEGAkACQCADQn9VDQBCACEDQgAhBCAGIAiFIAsgAYWEUA0CIAYgCH0hAiALIAF9IAYgCFStfSIEQv////////8DVg0BIAVBIGogAiAEIAIgBCAEUCIKG3lCwABCACAKG3ynQXRqIgoQu4yAgAAgByAKayEHIAUpAyghBCAFKQMgIQIMAQsgASALfCAIIAZ8IgIgCFStfCIEQoCAgICAgIAIg1ANACACQgGIIARCP4aEIAhCAYOEIQIgB0EBaiEHIARCAYghBAsgCUKAgICAgICAgIB/gyEIAkAgB0H//wFIDQAgCEKAgICAgIDA//8AhCEEQgAhAwwBC0EAIQoCQAJAIAdBAEwNACAHIQoMAQsgBUEQaiACIAQgB0H/AGoQu4yAgAAgBSACIARBASAHaxDFjICAACAFKQMAIAUpAxAgBSkDGIRCAFKthCECIAUpAwghBAsgAkIDiCAEQj2GhCEDIAqtQjCGIARCA4hC////////P4OEIAiEIQQgAqdBB3EhBwJAAkACQAJAAkAQw4yAgAAOAwABAgMLAkAgB0EERg0AIAQgAyAHQQRLrXwiCCADVK18IQQgCCEDDAMLIAQgAyADQgGDfCIIIANUrXwhBCAIIQMMAwsgBCADIAhCAFIgB0EAR3GtfCIIIANUrXwhBCAIIQMMAQsgBCADIAhQIAdBAEdxrXwiCCADVK18IQQgCCEDCyAHRQ0BCxDEjICAABoLIAAgAzcDACAAIAQ3AwggBUHwAGokgICAgAALUwEBfgJAAkAgA0HAAHFFDQAgASADQUBqrYYhAkIAIQEMAQsgA0UNACABQcAAIANrrYggAiADrSIEhoQhAiABIASGIQELIAAgATcDACAAIAI3AwgL5gECAX8CfkEBIQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQACQCACIACEIAYgBYSEUEUNAEEADwsCQCADIAGDQgBTDQACQCAAIAJUIAEgA1MgASADURtFDQBBfw8LIAAgAoUgASADhYRCAFIPCwJAIAAgAlYgASADVSABIANRG0UNAEF/DwsgACAChSABIAOFhEIAUiEECyAEC9gBAgF/An5BfyEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AAkAgAiAAhCAGIAWEhFBFDQBBAA8LAkAgAyABg0IAUw0AIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPCyAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLnxEGAX8DfgN/AX4Bfwt+I4CAgIAAQdACayIFJICAgIAAIARC////////P4MhBiACQv///////z+DIQcgBCAChUKAgICAgICAgIB/gyEIIARCMIinQf//AXEhCQJAAkACQCACQjCIp0H//wFxIgpBgYB+akGCgH5JDQBBACELIAlBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyIMQoCAgICAgMD//wBUIAxCgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEIDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEIIAMhAQwCCwJAIAEgDEKAgICAgIDA//8AhYRCAFINAAJAIAMgAkKAgICAgIDA//8AhYRQRQ0AQgAhAUKAgICAgIDg//8AIQgMAwsgCEKAgICAgIDA//8AhCEIQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINAEIAIQEMAgsCQCABIAyEQgBSDQBCgICAgICA4P//ACAIIAMgAoRQGyEIQgAhAQwCCwJAIAMgAoRCAFINACAIQoCAgICAgMD//wCEIQhCACEBDAILQQAhCwJAIAxC////////P1YNACAFQcACaiABIAcgASAHIAdQIgsbeULAAEIAIAsbfKciC0FxahC7jICAAEEQIAtrIQsgBSkDyAIhByAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyAGIAMgBiAGUCING3lCwABCACANG3ynIg1BcWoQu4yAgAAgDSALakFwaiELIAUpA7gCIQYgBSkDsAIhAwsgBUGgAmogA0IxiCAGQoCAgICAgMAAhCIOQg+GhCICQgBCgICAgLDmvIL1ACACfSIEQgAQx4yAgAAgBUGQAmpCACAFKQOoAn1CACAEQgAQx4yAgAAgBUGAAmogBSkDkAJCP4ggBSkDmAJCAYaEIgRCACACQgAQx4yAgAAgBUHwAWogBEIAQgAgBSkDiAJ9QgAQx4yAgAAgBUHgAWogBSkD8AFCP4ggBSkD+AFCAYaEIgRCACACQgAQx4yAgAAgBUHQAWogBEIAQgAgBSkD6AF9QgAQx4yAgAAgBUHAAWogBSkD0AFCP4ggBSkD2AFCAYaEIgRCACACQgAQx4yAgAAgBUGwAWogBEIAQgAgBSkDyAF9QgAQx4yAgAAgBUGgAWogAkIAIAUpA7ABQj+IIAUpA7gBQgGGhEJ/fCIEQgAQx4yAgAAgBUGQAWogA0IPhkIAIARCABDHjICAACAFQfAAaiAEQgBCACAFKQOoASAFKQOgASIGIAUpA5gBfCICIAZUrXwgAkIBVq18fUIAEMeMgIAAIAVBgAFqQgEgAn1CACAEQgAQx4yAgAAgCyAKIAlraiIKQf//AGohCQJAAkAgBSkDcCIPQgGGIhAgBSkDgAFCP4ggBSkDiAEiEUIBhoR8IgxCmZN/fCISQiCIIgIgB0KAgICAgIDAAIQiE0IBhiIUQiCIIgR+IhUgAUIBhiIWQiCIIgYgBSkDeEIBhiAPQj+IhCARQj+IfCAMIBBUrXwgEiAMVK18Qn98Ig9CIIgiDH58IhAgFVStIBAgD0L/////D4MiDyABQj+IIhcgB0IBhoRC/////w+DIgd+fCIRIBBUrXwgDCAEfnwgDyAEfiIVIAcgDH58IhAgFVStQiCGIBBCIIiEfCARIBBCIIZ8IhUgEVStfCAVIBJC/////w+DIhIgB34iECACIAZ+fCIRIBBUrSARIA8gFkL+////D4MiEH58IhggEVStfHwiESAVVK18IBEgEiAEfiIVIBAgDH58IgQgAiAHfnwiByAPIAZ+fCIMQiCIIAQgFVStIAcgBFStfCAMIAdUrXxCIIaEfCIEIBFUrXwgBCAYIAIgEH4iByASIAZ+fCICQiCIIAIgB1StQiCGhHwiByAYVK0gByAMQiCGfCIGIAdUrXx8IgcgBFStfCAHQQAgBiACQiCGIgIgEiAQfnwgAlStQn+FIgJWIAYgAlEbrXwiBCAHVK18IgJC/////////wBWDQAgFCAXhCETIAVB0ABqIAQgAkKAgICAgIDAAFQiC60iBoYiByACIAaGIARCAYggC0E/c62IhCIEIAMgDhDHjICAACAKQf7/AGogCSALG0F/aiEJIAFCMYYgBSkDWH0gBSkDUCIBQgBSrX0hBkIAIAF9IQIMAQsgBUHgAGogBEIBiCACQj+GhCIHIAJCAYgiBCADIA4Qx4yAgAAgAUIwhiAFKQNofSAFKQNgIgJCAFKtfSEGQgAgAn0hAiABIRYLAkAgCUH//wFIDQAgCEKAgICAgIDA//8AhCEIQgAhAQwBCwJAAkAgCUEBSA0AIAZCAYYgAkI/iIQhASAJrUIwhiAEQv///////z+DhCEGIAJCAYYhAgwBCwJAIAlBj39KDQBCACEBDAILIAVBwABqIAcgBEEBIAlrEMWMgIAAIAVBMGogFiATIAlB8ABqELuMgIAAIAVBIGogAyAOIAUpA0AiByAFKQNIIgYQx4yAgAAgBSkDOCAFKQMoQgGGIAUpAyAiAUI/iIR9IAUpAzAiAiABQgGGIgRUrX0hASACIAR9IQILIAVBEGogAyAOQgNCABDHjICAACAFIAMgDkIFQgAQx4yAgAAgBiAHIAdCAYMiBCACfCICIANWIAEgAiAEVK18IgEgDlYgASAOURutfCIEIAdUrXwiAyAEIANCgICAgICAwP//AFQgAiAFKQMQViABIAUpAxgiA1YgASADURtxrXwiAyAEVK18IgQgAyAEQoCAgICAgMD//wBUIAIgBSkDAFYgASAFKQMIIgJWIAEgAlEbca18IgEgA1StfCAIhCEICyAAIAE3AwAgACAINwMIIAVB0AJqJICAgIAAC/QBAwF/BH4BfyOAgICAAEEQayICJICAgIAAIAG9IgNC/////////weDIQQCQAJAIANCNIhC/w+DIgVQDQACQCAFQv8PUQ0AIARCBIghBiAEQjyGIQQgBUKA+AB8IQUMAgsgBEIEiCEGIARCPIYhBEL//wEhBQwBCwJAIARQRQ0AQgAhBEIAIQZCACEFDAELIAIgBEIAIAR5pyIHQTFqELuMgIAAIAIpAwhCgICAgICAwACFIQZBjPgAIAdrrSEFIAIpAwAhBAsgACAENwMAIAAgBUIwhiADQoCAgICAgICAgH+DhCAGhDcDCCACQRBqJICAgIAAC+oBAgV/An4jgICAgABBEGsiAiSAgICAACABvCIDQf///wNxIQQCQAJAIANBF3YiBUH/AXEiBkUNAAJAIAZB/wFGDQAgBK1CGYYhByAFQf8BcUGA/wBqIQRCACEIDAILIAStQhmGIQdCACEIQf//ASEEDAELAkAgBA0AQgAhCEEAIQRCACEHDAELIAIgBK1CACAEZyIEQdEAahC7jICAAEGJ/wAgBGshBCACKQMIQoCAgICAgMAAhSEHIAIpAwAhCAsgACAINwMAIAAgBK1CMIYgA0Efdq1CP4aEIAeENwMIIAJBEGokgICAgAALoQEDAX8CfgF/I4CAgIAAQRBrIgIkgICAgAACQAJAIAENAEIAIQNCACEEDAELIAIgASABQR91IgVzIAVrIgWtQgAgBWciBUHRAGoQu4yAgAAgAikDCEKAgICAgIDAAIVBnoABIAVrrUIwhnxCgICAgICAgICAf0IAIAFBAEgbhCEEIAIpAwAhAwsgACADNwMAIAAgBDcDCCACQRBqJICAgIAAC4EBAgF/An4jgICAgABBEGsiAiSAgICAAAJAAkAgAQ0AQgAhA0IAIQQMAQsgAiABrUIAQfAAIAFnIgFBH3NrELuMgIAAIAIpAwhCgICAgICAwACFQZ6AASABa61CMIZ8IQQgAikDACEDCyAAIAM3AwAgACAENwMIIAJBEGokgICAgAALBABBAAsEAEEAC1MBAX4CQAJAIANBwABxRQ0AIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC7ULBgF/BH4DfwF+AX8EfiOAgICAAEHgAGsiBSSAgICAACAEQv///////z+DIQYgBCAChUKAgICAgICAgIB/gyEHIAJC////////P4MiCEIgiCEJIARCMIinQf//AXEhCgJAAkACQCACQjCIp0H//wFxIgtBgYB+akGCgH5JDQBBACEMIApBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEHDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEHIAMhAQwCCwJAIAEgDUKAgICAgIDA//8AhYRCAFINAAJAIAMgAoRQRQ0AQoCAgICAgOD//wAhB0IAIQEMAwsgB0KAgICAgIDA//8AhCEHQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINACABIA2EIQJCACEBAkAgAlBFDQBCgICAgICA4P//ACEHDAMLIAdCgICAgICAwP//AIQhBwwCCwJAIAEgDYRCAFINAEIAIQEMAgsCQCADIAKEQgBSDQBCACEBDAILQQAhDAJAIA1C////////P1YNACAFQdAAaiABIAggASAIIAhQIgwbeULAAEIAIAwbfKciDEFxahC7jICAAEEQIAxrIQwgBSkDWCIIQiCIIQkgBSkDUCEBCyACQv///////z9WDQAgBUHAAGogAyAGIAMgBiAGUCIOG3lCwABCACAOG3ynIg5BcWoQu4yAgAAgDCAOa0EQaiEMIAUpA0ghBiAFKQNAIQMLIAsgCmogDGpBgYB/aiEKAkACQCAGQg+GIg9CIIhCgICAgAiEIgIgAUIgiCIEfiIQIANCD4YiEUIgiCIGIAlCgIAEhCIJfnwiDSAQVK0gDSADQjGIIA+EQv////8PgyIDIAhC/////w+DIgh+fCIPIA1UrXwgAiAJfnwgDyARQoCA/v8PgyINIAh+IhEgBiAEfnwiECARVK0gECADIAFC/////w+DIgF+fCIRIBBUrXx8IhAgD1StfCADIAl+IhIgAiAIfnwiDyASVK1CIIYgD0IgiIR8IBAgD0IghnwiDyAQVK18IA8gDSAJfiIQIAYgCH58IgkgAiABfnwiAiADIAR+fCIDQiCIIAkgEFStIAIgCVStfCADIAJUrXxCIIaEfCICIA9UrXwgAiARIA0gBH4iCSAGIAF+fCIEQiCIIAQgCVStQiCGhHwiBiARVK0gBiADQiCGfCIDIAZUrXx8IgYgAlStfCAGIAMgBEIghiICIA0gAX58IgEgAlStfCICIANUrXwiBCAGVK18IgNCgICAgICAwACDUA0AIApBAWohCgwBCyABQj+IIQYgA0IBhiAEQj+IhCEDIARCAYYgAkI/iIQhBCABQgGGIQEgBiACQgGGhCECCwJAIApB//8BSA0AIAdCgICAgICAwP//AIQhB0IAIQEMAQsCQAJAIApBAEoNAAJAQQEgCmsiC0H/AEsNACAFQTBqIAEgAiAKQf8AaiIKELuMgIAAIAVBIGogBCADIAoQu4yAgAAgBUEQaiABIAIgCxDFjICAACAFIAQgAyALEMWMgIAAIAUpAyAgBSkDEIQgBSkDMCAFKQM4hEIAUq2EIQEgBSkDKCAFKQMYhCECIAUpAwghAyAFKQMAIQQMAgtCACEBDAILIAqtQjCGIANC////////P4OEIQMLIAMgB4QhBwJAIAFQIAJCf1UgAkKAgICAgICAgIB/URsNACAHIARCAXwiAVCtfCEHDAELAkAgASACQoCAgICAgICAgH+FhEIAUQ0AIAQhAQwBCyAHIAQgBEIBg3wiASAEVK18IQcLIAAgATcDACAAIAc3AwggBUHgAGokgICAgAALdQEBfiAAIAQgAX4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCADQv////8PgyACIAF+fCIBQiCIfDcDCCAAIAFCIIYgBUL/////D4OENwMACyAAQYCAhIAAJIKAgIAAQYCAgIAAQQ9qQXBxJIGAgIAACw8AI4CAgIAAI4GAgIAAawsIACOCgICAAAsIACOBgICAAAtUAQF/I4CAgIAAQRBrIgUkgICAgAAgBSABIAIgAyAEQoCAgICAgICAgH+FELqMgIAAIAUpAwAhBCAAIAUpAwg3AwggACAENwMAIAVBEGokgICAgAALqQQDAX8CfgR/I4CAgIAAQSBrIgIkgICAgAAgAUL///////8/gyEDAkACQCABQjCIQv//AYMiBKciBUH/h39qQf0PSw0AIABCPIggA0IEhoQhAyAFQYCIf2qtIQQCQAJAIABC//////////8PgyIAQoGAgICAgICACFQNACADQgF8IQMMAQsgAEKAgICAgICAgAhSDQAgA0IBgyADfCEDC0IAIAMgA0L/////////B1YiBRshACAFrSAEfCEDDAELAkAgACADhFANACAEQv//AVINACAAQjyIIANCBIaEQoCAgICAgIAEhCEAQv8PIQMMAQsCQCAFQf6HAU0NAEL/DyEDQgAhAAwBCwJAQYD4AEGB+AAgBFAiBhsiByAFayIIQfAATA0AQgAhAEIAIQMMAQsgAyADQoCAgICAgMAAhCAGGyEDQQAhBgJAIAcgBUYNACACQRBqIAAgA0GAASAIaxC7jICAACACKQMQIAIpAxiEQgBSIQYLIAIgACADIAgQxYyAgAAgAikDACIDQjyIIAIpAwhCBIaEIQACQAJAIANC//////////8PgyAGrYQiA0KBgICAgICAgAhUDQAgAEIBfCEADAELIANCgICAgICAgIAIUg0AIABCAYMgAHwhAAsgAEKAgICAgICACIUgACAAQv////////8HViIFGyEAIAWtIQMLIAJBIGokgICAgAAgA0I0hiABQoCAgICAgICAgH+DhCAAhL8LHgBBACAAIABBmQFLG0EBdC8B0IyJgABB4P2IgABqCwwAIAAgABDOjICAAAsRAEGPu4WAAEEAEKyNgIAAAAtUAQJ/I4CAgIAAQRBrIgIkgICAgABBACEDAkAgAEEDcQ0AIAEgAHANACACQQxqIAAgARC1jICAACEAQQAgAigCDCAAGyEDCyACQRBqJICAgIAAIAMLGQACQCAAENOMgIAAIgANABDUjICAAAsgAAs+AQJ/IABBASAAQQFLGyEBAkADQCABEK6MgIAAIgINARCvjYCAACIARQ0BIAARgYCAgACAgICAAAwACwsgAgsJABDQjICAAAALCgAgABCwjICAAAsKACAAENWMgIAACxsAAkAgACABENiMgIAAIgENABDUjICAAAsgAQtMAQJ/IAFBBCABQQRLGyECIABBASAAQQFLGyEAAkADQCACIAAQ2YyAgAAiAw0BEK+NgIAAIgFFDQEgARGBgICAAICAgIAADAALCyADCyQBAX8gACABIAAgAWpBf2pBACAAa3EiAiABIAJLGxDRjICAAAsKACAAENuMgIAACwoAIAAQsIyAgAALDAAgACACENqMgIAACyEAAkAgABDljICAAEUNACAAEOaMgIAADwsgABDnjICAAAsMACAAIAEQ6YyAgAALJQEBf0EKIQECQCAAEOWMgIAARQ0AIAAQ6oyAgABBf2ohAQsgAQshAAJAIAAQ5YyAgABFDQAgABDrjICAAA8LIAAQ7IyAgAALBAAgAAsCAAuxAwEDfyOAgICAAEEgayIIJICAgIAAAkAgAiAAEPCMgIAAIgkgAUF/c2pLDQAgABDgjICAACEKAkAgASAJQQF2QXhqTw0AIAggAUEBdDYCHCAIIAIgAWo2AhAgCEEQaiAIQRxqEPGMgIAAKAIAEPKMgIAAQQFqIQkLIAAQ84yAgAAgCEEcaiAIQRhqIAAQ9IyAgAAoAgAQ9YyAgAAgCEEQaiAAIAkQ9oyAgAAgCCgCECIJIAgoAhQQ94yAgAACQCAERQ0AIAkQ4YyAgAAgChDhjICAACAEEPiMgIAAGgsCQCAGRQ0AIAkQ4YyAgAAgBGogByAGEPiMgIAAGgsgAyAFIARqIgdrIQICQCADIAdGDQAgCRDhjICAACAEaiAGaiAKEOGMgIAAIARqIAVqIAIQ+IyAgAAaCwJAIAFBAWoiAUELRg0AIAAgCiABEPmMgIAACyAAIAkQ+oyAgAAgACAIKAIUEPuMgIAAIAAgBiAEaiACaiIEEPyMgIAAIAhBADoADyAJIARqIAhBD2oQ74yAgAAgCEEcahD9jICAABogCEEgaiSAgICAAA8LEP6MgIAAAAsPAEGziYWAABDojICAAAALCgAgAC0AC0EHdgsHACAAKAIECwsAIAAtAAtB/wBxCysBAX8jgICAgABBEGsiASSAgICAACABIAA2AgBBhL6GgAAgARCsjYCAAAALOAECfyOAgICAAEEQayICJICAgIAAIAJBD2ogASAAEJeNgIAAIQMgAkEQaiSAgICAACABIAAgAxsLDgAgACgCCEH/////B3ELBwAgACgCAAsKACAAEIiNgIAACxsAAkAgAkUNACACRQ0AIAAgASAC/AoAAAsgAAslAAJAIAAQ5YyAgABFDQAgACABEPyMgIAADwsgACABEIONgIAACwwAIAAgAS0AADoAAAscACAAEIWNgIAAIgAgABCGjYCAAEEBdkt2QXhqCwwAIAAgARCRjYCAAAswAQF/QQohAQJAIABBC0kNACAAQQFqEIqNgIAAIgAgAEF/aiIAIABBC0YbIQELIAELAgALCwAgACABNgIAIAALDQAgACABEJKNgIAAGgsOACAAIAEgAhCJjYCAAAsCAAsRACAAIAEgAhDtjICAABogAAsOACAAIAEgAhCOjYCAAAsJACAAIAE2AgALEAAgACABQYCAgIB4cjYCCAsJACAAIAE2AgQLDAAgABCTjYCAACAACw8AQbOJhYAAEIeNgIAAAAsQACAAEICNgIAAEIGNgIAACyEAAkAgABDljICAAEUNACAAEJiNgIAADwsgABCZjYCAAAsEACAACwcAIABBC0kLDQAgACABQf8AcToACwsCAAsIABCGjYCAAAsIABCbjYCAAAsrAQF/I4CAgIAAQRBrIgEkgICAgAAgASAANgIAQcK9hoAAIAEQrI2AgAAACwQAIAALDgAgACABIAIQnI2AgAALCgAgAEEHakF4cQsKACAAEIyNgIAACwoAIAAQgYyAgAALMgAgABDzjICAAAJAIAAQ5YyAgABFDQAgACAAEOuMgIAAIAAQ6oyAgAAQ+YyAgAALIAALDgAgASACQQEQo42AgAAL3gEBAn8jgICAgABBEGsiAySAgICAAAJAIAIgABDwjICAAEsNAAJAAkAgAhCCjYCAAEUNACAAIAIQg42AgAAgABDsjICAACEEDAELIANBCGogACACEPKMgIAAQQFqEPaMgIAAIAMoAggiBCADKAIMEPeMgIAAIAAgBBD6jICAACAAIAMoAgwQ+4yAgAAgACACEPyMgIAACyAEEOGMgIAAIAEgAhD4jICAABogA0EAOgAHIAQgAmogA0EHahDvjICAACAAIAIQhI2AgAAgA0EQaiSAgICAAA8LEP6MgIAAAAuzAQEDfyOAgICAAEEQayIDJICAgIAAAkACQCAAEN+MgIAAIgQgABDdjICAACIFayACSQ0AIAJFDQEgACACEOKMgIAAIAAQ4IyAgAAQ4YyAgAAiBCAFaiABIAIQ+IyAgAAaIAAgBSACaiICEO6MgIAAIANBADoADyAEIAJqIANBD2oQ74yAgAAMAQsgACAEIAIgBGsgBWogBSAFQQAgAiABEOOMgIAACyADQRBqJICAgIAAIAALOAECfyOAgICAAEEQayICJICAgIAAIAJBD2ogACABEJeNgIAAIQMgAkEQaiSAgICAACABIAAgAxsLCwAgACABNgIAIAALGQAgACgCACEAIAAgABDdjICAABCEjYCAAAu5AQEBfyOAgICAAEEQayIFJICAgIAAIAUgBDYCCCAFIAI2AgwCQCAAEN2MgIAAIgIgAUkNACAEQX9GDQAgBSACIAFrNgIAIAUgBUEMaiAFEN6MgIAAKAIANgIEAkAgABD/jICAACABaiADIAVBBGogBUEIahDejICAACgCABCVjYCAACIBDQBBfyEBIAUoAgQiBCAFKAIIIgBJDQAgBCAASyEBCyAFQRBqJICAgIAAIAEPCxDkjICAAAALDgAgACABIAIQ6IuAgAALFAAgACABIAEQi42AgAAQkI2AgAALDQAgASgCACACKAIASQsHACAAKAIACwoAIAAQmo2AgAALBAAgAAsEAEF/CxwAIAEgAhCdjYCAACEBIAAgAjYCBCAAIAE2AgALIwACQCABIAAQhY2AgABNDQAQno2AgAAACyABQQEQn42AgAALEQBB17qFgABBABCsjYCAAAALIwACQCABEKCNgIAARQ0AIAAgARChjYCAAA8LIAAQoo2AgAALBwAgAEEISwsMACAAIAEQ14yAgAALCgAgABDSjICAAAsnAAJAIAIQoI2AgABFDQAgACABIAIQpI2AgAAPCyAAIAEQpY2AgAALDgAgACABIAIQ3IyAgAALDAAgACABENaMgIAACwwAIAAgARCnjYCAAAt7AQJ/AkACQCABKAJMIgJBAEgNACAC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ASgCJCIEDQAgASADNgIYIAEgAjYCECABQQE2AiQgASABKAI4NgIUDwsCQAJAIAEoAhQgASgCOEcNACABKAIQIAJHDQAgASgCGEECRw0BIAEgAzYCGA8LIAFBAToANiABQQI2AhggASAEQQFqNgIkCwslAAJAIAAgASgCCEEAELeNgIAARQ0AIAEgASACIAMQv42AgAALC0YAAkAgACABKAIIQQAQt42AgABFDQAgASABIAIgAxC/jYCAAA8LIAAoAggiACABIAIgAyAAKAIAKAIcEYWAgIAAgICAgAALnwEAIAFBAToANQJAIAMgASgCBEcNACABQQE6ADQCQAJAIAEoAhAiAw0AIAFBATYCJCABIAQ2AhggASACNgIQIARBAUcNAiABKAIwQQFGDQEMAgsCQCADIAJHDQACQCABKAIYIgNBAkcNACABIAQ2AhggBCEDCyABKAIwQQFHDQIgA0EBRg0BDAILIAEgASgCJEEBajYCJAsgAUEBOgA2CwsgAAJAIAIgASgCBEcNACABKAIcQQFGDQAgASADNgIcCwudAgACQCAAIAEoAgggBBC3jYCAAEUNACABIAEgAiADEMONgIAADwsCQAJAIAAgASgCACAEELeNgIAARQ0AAkACQCACIAEoAhBGDQAgAiABKAIURw0BCyADQQFHDQIgAUEBNgIgDwsgASADNgIgAkAgASgCLEEERg0AIAFBADsBNCAAKAIIIgAgASACIAJBASAEIAAoAgAoAhQRiYCAgACAgICAAAJAIAEtADVBAUcNACABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEYqAgIAAgICAgAALC6QBAAJAIAAgASgCCCAEELeNgIAARQ0AIAEgASACIAMQw42AgAAPCwJAIAAgASgCACAEELeNgIAARQ0AAkACQCACIAEoAhBGDQAgAiABKAIURw0BCyADQQFHDQEgAUEBNgIgDwsgASACNgIUIAEgAzYCICABIAEoAihBAWo2AigCQCABKAIkQQFHDQAgASgCGEECRw0AIAFBAToANgsgAUEENgIsCwtMAAJAIAAgASgCCCAFELeNgIAARQ0AIAEgASACIAMgBBDCjYCAAA8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBGJgICAAICAgIAACycAAkAgACABKAIIIAUQt42AgABFDQAgASABIAIgAyAEEMKNgIAACwsEACAACwoAIAAkgICAgAALGgECfyOAgICAACAAa0FwcSIBJICAgIAAIAELCAAjgICAgAALC5uqBQIAQYCABAuBkwV+AGhhc093blByb3BlcnR5AGdyb3VwIG5hbWUgaXMgZW1wdHkAaW5maW5pdHkASW5maW5pdHkAaGJfYXJlbmFfcGFnZV9oYXNfY2FwYWNpdHkAaW5kZXggPCBsaXN0LT5jYXBhY2l0eQBuZXh0X2NhcGFjaXR5ID4gbG9jYWxzLT5jYXBhY2l0eQBwYWdlLT5wb3NpdGlvbiA8PSBwYWdlLT5jYXBhY2l0eQBwYWdlLT5wb3NpdGlvbiArIHNpemUgPD0gcGFnZS0+Y2FwYWNpdHkAcGFyc2VfcmV0cnkAZmFpbGVkIHRvIGFsbG9jYXRlIG1lbW9yeQBbcG1fZmxvYXRfbm9kZV9yYXRpb25hbF9jcmVhdGVdIEZhaWxlZCB0byBhbGxvY2F0ZSBtZW1vcnkAaW1hZ2luYXJ5AG51bWJlcmVkX3BhcmFtZXRlcl9vcmRpbmFyeQBpdF9ub3RfYWxsb3dlZF9vcmRpbmFyeQBpbnZhbGlkX251bWJlcl9iaW5hcnkAZXhwZXJpbWVudGFsX2NvcHkAcG1fbm9kZV9kZXN0cm95AGthcmF0c3ViYV9tdWx0aXBseQB3cml0ZV90YXJnZXRfcmVhZG9ubHkAcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX2tleQBwYXR0ZXJuX2hhc2hfa2V5AGR1cGxpY2F0ZWRfaGFzaF9rZXkAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIGtleQBJbnZhbGlkIHJldHVybiBpbiBjbGFzcy9tb2R1bGUgYm9keQBjb3VsZCBub3QgcGFyc2UgdGhlIGVuZGxlc3MgbWV0aG9kIGJvZHkAdW5leHBlY3RlZCBjbGFzcyBkZWZpbml0aW9uIGluIG1ldGhvZCBib2R5AHVuZXhwZWN0ZWQgbW9kdWxlIGRlZmluaXRpb24gaW4gbWV0aG9kIGJvZHkAYW5hbHl6ZWRfcnVieQBleHRyYWN0UnVieQBleHBlY3RlZCBhbiBlbGVtZW50IGZvciB0aGUgYXJyYXkAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgKmAgaW4gdGhlIGFycmF5AHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEgYF1gIHRvIGNsb3NlIHRoZSBhcnJheQBBcnJheQBwYXJzZV9leHByZXNzaW9uX2luZml4AHBhcnNlX2V4cHJlc3Npb25fcHJlZml4AGFtYmlndW91cyBgKmAgaGFzIGJlZW4gaW50ZXJwcmV0ZWQgYXMgYW4gYXJndW1lbnQgcHJlZml4AGFtYmlndW91cyBgKipgIGhhcyBiZWVuIGludGVycHJldGVkIGFzIGFuIGFyZ3VtZW50IHByZWZpeABhbWJpZ3VvdXMgYCZgIGhhcyBiZWVuIGludGVycHJldGVkIGFzIGFuIGFyZ3VtZW50IHByZWZpeABwYXJzZXJfbGV4AGZvcl9pbmRleABmb3IgbG9vcCBpbmRleABJbnZhbGlkIGVzY2FwZSBjaGFyYWN0ZXIgc3ludGF4AFx4AC0rICAgMFgweAAtMFgrMFggMFgtMHgrMHggMHgAcGFyYW1ldGVyX25vX2RlZmF1bHRfa3cAcGFyYW1ldGVyX3VuZXhwZWN0ZWRfbm9fa3cAQWN0aW9uVmlldwBcdgAlbGx1AFx1ACV1AHVuZXhwZWN0ZWRfdG9rZW5fY2xvc2VfY29udGV4dAB1bmV4cGVjdGVkIG11bHRpcGxlIGFzc2lnbm1lbnQ7IG11bHRpcGxlIGFzc2lnbm1lbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBjb250ZXh0AHVuZXhwZWN0ZWQgJXM7IHVuYXJ5IGNhbGxzIGFyZSBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAdG9wIGxldmVsIGNvbnRleHQAcG9zc2libHkgdXNlbGVzcyB1c2Ugb2YgJS4qcyBpbiB2b2lkIGNvbnRleHQASW52YWxpZCBuZXh0AHVuZXhwZWN0ZWQgJXMsIGV4cGVjdGluZyBlbmQtb2YtaW5wdXQAbm8gUnVieSBzY3JpcHQgZm91bmQgaW4gaW5wdXQAZXNjYXBlX2ludmFsaWRfdW5pY29kZV9saXN0AGV4cGVjdGVkIGEgc3RyaW5nIGluIGEgYCV3YCBsaXN0AGV4cGVjdGVkIGEgc3ltYm9sIGluIGEgYCVpYCBsaXN0AGV4cGVjdGVkIGEgc3RyaW5nIGluIGEgYCVXYCBsaXN0AGV4cGVjdGVkIGEgc3ltYm9sIGluIGEgYCVJYCBsaXN0AHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9yZXN0AHBhcmFtZXRlcl9mb3J3YXJkaW5nX2FmdGVyX3Jlc3QAcGFyc2VfcGF0dGVybl9yZXN0AHBhcnNlX3BhdHRlcm5fa2V5d29yZF9yZXN0AG11bHRpX2Fzc2lnbl91bmV4cGVjdGVkX3Jlc3QAZXNjYXBlX2ludmFsaWRfdW5pY29kZV9zaG9ydAB1bnNpZ25lZCBzaG9ydABwbV9jb25zdGFudF9pZF9saXN0X2luc2VydABwbV9idWZmZXJfaW5zZXJ0AHBtX2NvbnN0YW50X3Bvb2xfaW5zZXJ0AGNvbW1lbnRfc3RhcnQAY3Vyc29yID49IGxpc3QtPnN0YXJ0AFVuZXhwZWN0ZWQgRVJCIHN0YXJ0AGVuZCA+PSBzdGFydABjYW5ub3RfcGFyc2Vfc3RyaW5nX3BhcnQAY2Fubm90IHBhcnNlIHRoZSBzdHJpbmcgcGFydABzY3JpcHQAbm90AHByaW50AHBtX3V0Zl84X2NvZGVwb2ludAB1bnNpZ25lZCBpbnQAc3Vic2VxdWVudABleHBlY3Rfc3RyaW5nX2NvbnRlbnQAc3RyaW5nIGNvbnRlbnQAaW52YWxpZF9mbG9hdF9leHBvbmVudABpbnZhbGlkIGV4cG9uZW50AGV4cGVjdF9hcmd1bWVudABhbGlhc19hcmd1bWVudAB1bmV4cGVjdGVkX2Jsb2NrX2FyZ3VtZW50AHVuZGVmX2FyZ3VtZW50AC4uLiBhZnRlciByZXN0IGFyZ3VtZW50AHVuZXhwZWN0ZWQgYCpgIHNwbGF0IGFyZ3VtZW50IGFmdGVyIGEgYCoqYCBrZXl3b3JkIHNwbGF0IGFyZ3VtZW50AHVuZXhwZWN0ZWQgYCpgIHNwbGF0IGFyZ3VtZW50IGFmdGVyIGEgYCpgIHNwbGF0IGFyZ3VtZW50AGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYCpgIHNwbGF0IGluIGFuIGFyZ3VtZW50AHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGFuIGFyZ3VtZW50AGludmFsaWQgYXJndW1lbnQgYmVpbmcgcGFzc2VkIHRvIGB1bmRlZmA7IGV4cGVjdGVkIGEgYmFyZSB3b3JkLCBjb25zdGFudCwgb3Igc3ltYm9sIGFyZ3VtZW50AHVuZXhwZWN0ZWQgYXJndW1lbnQgYWZ0ZXIgYSBibG9jayBhcmd1bWVudAB1bmV4cGVjdGVkIGJhcmUgaGFzaCBhcmd1bWVudABoZXJlIGRvY3VtZW50AGR5bmFtaWMgY29uc3RhbnQgYXNzaWdubWVudABleHBlY3RlZCBhIGApYCBhZnRlciBtdWx0aXBsZSBhc3NpZ25tZW50AHVuZXhwZWN0ZWQgJyUuKnMnIHJlc3VsdGluZyBpbiBtdWx0aXBsZSBzcGxhdHMgaW4gbXVsdGlwbGUgYXNzaWdubWVudAB1bmV4cGVjdGVkIG9wZXJhdG9yIGZvciBhIG11bHRpcGxlIGFzc2lnbm1lbnQAdW5leHBlY3RlZCBgfHw9YCBpbiBhIG11bHRpcGxlIGFzc2lnbm1lbnQAdW5leHBlY3RlZCBgJiY9YCBpbiBhIG11bHRpcGxlIGFzc2lnbm1lbnQAaW52YWxpZF9lbmNvZGluZ19tYWdpY19jb21tZW50AHVua25vd24gb3IgaW52YWxpZCBlbmNvZGluZyBpbiB0aGUgbWFnaWMgY29tbWVudABleHBlY3RfZW9sX2FmdGVyX3N0YXRlbWVudAB1bnJlYWNoYWJsZV9zdGF0ZW1lbnQAdm9pZF9zdGF0ZW1lbnQAdW5sZXNzIHN0YXRlbWVudABiZWdpbiBzdGF0ZW1lbnQAdW50aWwgc3RhdGVtZW50AGV4cGVjdGVkIGEgcHJlZGljYXRlIGZvciBhIGNhc2UgbWF0Y2hpbmcgc3RhdGVtZW50AGlmIHN0YXRlbWVudABleHBlY3RlZCBhbiBleGNlcHRpb24gdmFyaWFibGUgYWZ0ZXIgYD0+YCBpbiBhIHJlc2N1ZSBzdGF0ZW1lbnQAd2hpbGUgc3RhdGVtZW50AGV4cGVjdGVkIGEgcHJlZGljYXRlIGV4cHJlc3Npb24gZm9yIHRoZSBgdW5sZXNzYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGBjbGFzc2Agc3RhdGVtZW50AGV4cGVjdGVkIGFuIGBpbmAgYWZ0ZXIgdGhlIGluZGV4IGluIGEgYGZvcmAgc3RhdGVtZW50AGV4cGVjdGVkIGEgY29sbGVjdGlvbiBhZnRlciB0aGUgYGluYCBpbiBhIGBmb3JgIHN0YXRlbWVudABleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYGJlZ2luYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBwcmVkaWNhdGUgZXhwcmVzc2lvbiBmb3IgdGhlIGB1bnRpbGAgc3RhdGVtZW50AGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgdW50aWxgIHN0YXRlbWVudABleHBlY3RlZCBhIHByZWRpY2F0ZSBleHByZXNzaW9uIGZvciB0aGUgYGVsc2lmYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBwcmVkaWNhdGUgZXhwcmVzc2lvbiBmb3IgdGhlIGBpZmAgc3RhdGVtZW50AGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgZGVmYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGBjYXNlYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGBtb2R1bGVgIHN0YXRlbWVudABleHBlY3RlZCBhIHByZWRpY2F0ZSBleHByZXNzaW9uIGZvciB0aGUgYHdoaWxlYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGB3aGlsZWAgc3RhdGVtZW50AGV4cGVjdGVkIGEgYH1gIHRvIGNsb3NlIHRoZSBgQkVHSU5gIHN0YXRlbWVudABleHBlY3RlZCBhIGB9YCB0byBjbG9zZSB0aGUgYEVORGAgc3RhdGVtZW50AGFycmF5X2VsZW1lbnQAbGlzdF93X2xvd2VyX2VsZW1lbnQAbGlzdF9pX2xvd2VyX2VsZW1lbnQAbGlzdF93X3VwcGVyX2VsZW1lbnQAbGlzdF9pX3VwcGVyX2VsZW1lbnQAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBmb3IgdGhlIGFycmF5IGVsZW1lbnQAd2Fybl9pbmRlbnQAaW52YWxpZF9wZXJjZW50AHBtX2NvbnN0YW50X3Bvb2xfaWRfdG9fY29uc3RhbnQAY29uc3RhbnRfcGF0aF9jb2xvbl9jb2xvbl9jb25zdGFudABhcmd1bWVudF9mb3JtYWxfY29uc3RhbnQAaW52YWxpZCBmb3JtYWwgYXJndW1lbnQ7IGZvcm1hbCBhcmd1bWVudCBjYW5ub3QgYmUgYSBjb25zdGFudABwYXJhbWV0ZXJfbm9fZGVmYXVsdABsaXRlcmFsX2luX2NvbmRpdGlvbl9kZWZhdWx0AEVORCBpbiBtZXRob2Q7IHVzZSBhdF9leGl0AHBhcnNlX2Jsb2NrX2V4aXQAaW52YWxpZF9ibG9ja19leGl0AHBtX3BhcnNlcl9pbml0AHBtX3N0cmluZ19zaGFyZWRfaW5pdABzcGxpdABwbV9pbnRlZ2VyX3BhcnNlX2RpZ2l0AHBhdHRlcm5faGFzaF9pbXBsaWNpdABudW1iZXJlZF9wYXJhbWV0ZXJfaXQAdW5leHBlY3RlZCAlcywgaWdub3JpbmcgaXQAdW5leHBlY3RlZCAnfScsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJ2luJywgaWdub3JpbmcgaXQAdW5leHBlY3RlZCAnd2hlbicsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJ2Vsc2lmJywgaWdub3JpbmcgaXQAdW5leHBlY3RlZCAncmVzY3VlJywgaWdub3JpbmcgaXQAdW5leHBlY3RlZCAnZWxzZScsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJ2Vuc3VyZScsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJ2VuZCcsIGlnbm9yaW5nIGl0AHVuZXhwZWN0ZWQgJz0nLCBpZ25vcmluZyBpdABwbV9wYXJhbWV0ZXJzX25vZGVfa2V5d29yZF9yZXN0X3NldABwbV9wYXJhbWV0ZXJzX25vZGVfYmxvY2tfc2V0AHBtX2Jsb2NrX3BhcmFtZXRlcnNfbm9kZV9jbG9zaW5nX3NldABwbV9zdHJwYnJrX2V4cGxpY2l0X2VuY29kaW5nX3NldABwbV9hcnJheV9ub2RlX2Nsb3NlX3NldABwbV9iZWdpbl9ub2RlX2VuZF9rZXl3b3JkX3NldABpZGVudGlmaWVyICUuKnMgaXMgbm90IHZhbGlkIHRvIHNldABwYXR0ZXJuX2lkZW50X2FmdGVyX2hyb2NrZXQAcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX2hyb2NrZXQAaGFzaF9yb2NrZXQAZXhwZWN0X3JicmFja2V0AHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9icmFja2V0AHBhdHRlcm5fdGVybV9icmFja2V0AHVuZXhwZWN0ZWQgd3JpdGUgdGFyZ2V0AGlkZW50aWZpZXIgJS4qcyBpcyBub3QgdmFsaWQgdG8gZ2V0AG9iamVjdABPYmplY3QAZmxvYXQAYXJndW1lbnRfc3BsYXRfYWZ0ZXJfc3BsYXQAZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfc3BsYXQAYXJndW1lbnRfc3BsYXRfYWZ0ZXJfYXNzb2Nfc3BsYXQAZXNjYXBlX2ludmFsaWRfY29udHJvbF9yZXBlYXQAZXNjYXBlX2ludmFsaWRfbWV0YV9yZXBlYXQAVW5rbm93biBwbV9lcnJvcl9sZXZlbF90AFx0AGFtYmlndW91c19maXJzdF9hcmd1bWVudF9taW51cwBhbWJpZ3VvdXNfZmlyc3RfYXJndW1lbnRfcGx1cwBwYXR0ZXJuX2FycmF5X211bHRpcGxlX3Jlc3RzAG9wZXJhdG9yX3dyaXRlX2FyZ3VtZW50cwB1bmV4cGVjdGVkIG9wZXJhdG9yIGFmdGVyIGEgY2FsbCB3aXRoIGFyZ3VtZW50cwB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhIGApYCB0byBjbG9zZSB0aGUgYXJndW1lbnRzAHN0YXRlbWVudHMAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSBgLGAgc2VwYXJhdG9yIGZvciB0aGUgYXJyYXkgZWxlbWVudHMAcG1fbG9vcF9tb2RpZmllcl9ibG9ja19leGl0cwBmbHVzaF9ibG9ja19leGl0cwBpbnZhbGlkIGJpbmFyeSBudW1iZXI7IG51bWVyaWMgbGl0ZXJhbCB3aXRob3V0IGRpZ2l0cwBpbnZhbGlkIG9jdGFsIG51bWJlcjsgbnVtZXJpYyBsaXRlcmFsIHdpdGhvdXQgZGlnaXRzAGludmFsaWQgaGV4YWRlY2ltYWwgbnVtYmVyOyBudW1lcmljIGxpdGVyYWwgd2l0aG91dCBkaWdpdHMAaW52YWxpZCBkZWNpbWFsIG51bWJlcjsgbnVtZXJpYyBsaXRlcmFsIHdpdGhvdXQgZGlnaXRzAGludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2U7IG1heGltdW0gbGVuZ3RoIGlzIDYgZGlnaXRzAG11bHRpcGxlIHRhcmdldHMAbXVsdGlfYXNzaWduX211bHRpX3NwbGF0cwB1bmxlc3MAdW5leHBlY3RlZCBgZWxzZWAgaW4gYGJlZ2luYCBibG9jazsgZWxzZSB3aXRob3V0IHJlc2N1ZSBpcyB1c2VsZXNzAGRlZl9lbmRsZXNzAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX2xlc3NfbGVzcwBjbGFzc19zdXBlcmNsYXNzAGFyZ3VtZW50X2Zvcm1hbF9jbGFzcwBpbmNvbXBsZXRlX3ZhcmlhYmxlX2NsYXNzAGVtcHR5IGNoYXItY2xhc3MAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSBuZXdsaW5lIG9yIGEgJzsnIGFmdGVyIHRoZSBzaW5nbGV0b24gY2xhc3MAZXJyb3JzAGRlZl9lbmRsZXNzX3BhcmFtZXRlcnMAcGFyc2VfYmxvY2tsaWtlX3BhcmFtZXRlcnMAdW5leHBlY3RlZCBtdWx0aXBsZSBgKmAgc3BsYXQgcGFyYW1ldGVycwB1bmV4cGVjdGVkIG11bHRpcGxlIGAqKmAgc3BsYXQgcGFyYW1ldGVycwB1bmV4cGVjdGVkIGAuLi5gIGluIHBhcmFtZXRlcnMAdW5leHBlY3RlZCBgLGAgaW4gcGFyYW1ldGVycwBleHBlY3RlZCBhIGxvY2FsIHZhcmlhYmxlIG5hbWUgaW4gdGhlIGJsb2NrIHBhcmFtZXRlcnMAZXhwZWN0ZWQgYSBkZWxpbWl0ZXIgdG8gY2xvc2UgdGhlIHBhcmFtZXRlcnMAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSBgKWAgdG8gY2xvc2UgdGhlIHBhcmFtZXRlcnMAY291bGQgbm90IHBhcnNlIHRoZSBlbmRsZXNzIG1ldGhvZCBwYXJhbWV0ZXJzACUuMnMgaXMgcmVzZXJ2ZWQgZm9yIG51bWJlcmVkIHBhcmFtZXRlcnMAcmVnZXhwX3Vua25vd25fb3B0aW9ucwBjYXNlX21pc3NpbmdfY29uZGl0aW9ucwBMZXhlciBzdGFsbGVkIGFmdGVyIDUgaXRlcmF0aW9ucwB1bmV4cGVjdGVkIGJsb2NrIGFyZyBnaXZlbiBpbiBpbmRleCBhc3NpZ25tZW50OyBibG9ja3MgYXJlIG5vdCBhbGxvd2VkIGluIGluZGV4IGFzc2lnbm1lbnQgZXhwcmVzc2lvbnMAdW5leHBlY3RlZCBrZXl3b3JkIGFyZyBnaXZlbiBpbiBpbmRleCBhc3NpZ25tZW50OyBrZXl3b3JkcyBhcmUgbm90IGFsbG93ZWQgaW4gaW5kZXggYXNzaWdubWVudCBleHByZXNzaW9ucwAnZnJvemVuX3N0cmluZ19saXRlcmFsJyBpcyBpZ25vcmVkIGFmdGVyIGFueSB0b2tlbnMAc2hlYmFuZyBsaW5lIGVuZGluZyB3aXRoIFxyIG1heSBjYXVzZSBwcm9ibGVtcwBldWMtanAtbXMAZXVjSlAtbXMAZXF1YWxzAHNpbmdsZXRvbl9mb3JfbGl0ZXJhbHMAY2Fubm90IGRlZmluZSBzaW5nbGV0b24gbWV0aG9kIGZvciBsaXRlcmFscwBwYXR0ZXJuX2hhc2hfa2V5X2xvY2FscwB1bmV4cGVjdGVkICd7JyBhZnRlciBhIG1ldGhvZCBjYWxsIHdpdGhvdXQgcGFyZW50aGVzaXMAdW5tYXRjaGVkIGNsb3NlIHBhcmVudGhlc2lzAGVuZCBwYXR0ZXJuIHdpdGggdW5tYXRjaGVkIHBhcmVudGhlc2lzAHBhcnNlX3N0cmluZ3MAd2FybmluZ3MAZXNjYXBlX2ludmFsaWRfdW5pY29kZV9jbV9mbGFncwBpbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOyBVbmljb2RlIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGNvbnRyb2wgb3IgbWV0YSBmbGFncwBwYXJzZV9yZXNjdWVzAGFyZ3VtZW50X2FmdGVyX2ZvcndhcmRpbmdfZWxsaXBzZXMAYXJndW1lbnRfbm9fZm9yd2FyZGluZ19lbGxpcHNlcwBwYXJlbnRoZXNlcwBpbnZhbGlkIGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBgYWxpYXNgOyBjYW4ndCBtYWtlIGFsaWFzIGZvciB0aGUgbnVtYmVyIHZhcmlhYmxlcwBrZXkgbXVzdCBiZSB2YWxpZCBhcyBsb2NhbCB2YXJpYWJsZXMAcG1fY29tcGFyZV9udW1iZXJfbm9kZXMAdW5leHBlY3RlZF9pbmRleF9rZXl3b3JkcwB1bmV4cGVjdGVkICoqbmlsOyBubyBrZXl3b3JkcyBtYXJrZXIgZGlzYWxsb3dlZCBhZnRlciBrZXl3b3JkcwBwbV9sb2NhbHNfcmVhZHMAcGFyc2VfYXNzb2NzAHN0YXRlbWVudF9hbGlhcwBccwBDYW4ndCBhc3NpZ24gdG8gbnVtYmVyZWQgcGFyYW1ldGVyICUuMnMAQ2FuJ3Qgc2V0IHZhcmlhYmxlICUuKnMAaW52YWxpZCBVbmljb2RlIGxpc3Q6ICUuKnMAaW52YWxpZCB2YWx1ZSBmb3IgJS4qczogJS4qcwB0b28gc2hvcnQgZXNjYXBlIHNlcXVlbmNlOiAlLipzAHVua25vd24gcmVnZXhwICVzIC0gJS4qcwBhc3NpZ25lZCBidXQgdW51c2VkIHZhcmlhYmxlIC0gJS4qcwBjaXJjdWxhciBhcmd1bWVudCByZWZlcmVuY2UgLSAlLipzAGludmFsaWQgY2hhcmFjdGVyIHN5bnRheDsgdXNlICVzJXMlcwB1bmV4cGVjdGVkICVzLCBhc3N1bWluZyBpdCBpcyBjbG9zaW5nIHRoZSBwYXJlbnQgJXMAJXNsaXRlcmFsIGluICVzACclcycgYWZ0ZXIgbG9jYWwgdmFyaWFibGUgb3IgbGl0ZXJhbCBpcyBpbnRlcnByZXRlZCBhcyBiaW5hcnkgb3BlcmF0b3IgZXZlbiB0aG91Z2ggaXQgc2VlbXMgbGlrZSAlcwBJbnZhbGlkICVzACVzOiAlcwAlczolZDogJXMAKmJyZWFrcG9pbnQgPT0gbGV4X21vZGUtPmFzLmxpc3QuaW5jcmVtZW50b3IAYW1iaWd1b3VzX2JpbmFyeV9vcGVyYXRvcgBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9vcGVyYXRvcgBub25fYXNzb2NpYXRpdmVfb3BlcmF0b3IAdW5leHBlY3RlZF9yYW5nZV9vcGVyYXRvcgB1bmFyeSBvcGVyYXRvcgBleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGA/YCBpbiB0aGUgdGVybmFyeSBvcGVyYXRvcgBleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGA6YCBpbiB0aGUgdGVybmFyeSBvcGVyYXRvcgBleHBlY3RlZCBhIGA6YCBhZnRlciB0aGUgdHJ1ZSBleHByZXNzaW9uIG9mIGEgdGVybmFyeSBvcGVyYXRvcgBleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgYF5gIHBpbiBvcGVyYXRvcgB1bmV4cGVjdGVkICVzOyAlcyBpcyBhIG5vbi1hc3NvY2lhdGl2ZSBvcGVyYXRvcgB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIHRoZSBvcGVyYXRvcgBleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgcmFuZ2Ugb3BlcmF0b3IAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIGB8YCBvcGVyYXRvcgBleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgYFtgIG9wZXJhdG9yAGV4cGVjdGVkIGFuIGlkZW50aWZpZXIgYWZ0ZXIgdGhlIGA9PmAgb3BlcmF0b3IAZXhwZWN0ZWQgYSBjb25zdGFudCBhZnRlciB0aGUgYDo6YCBvcGVyYXRvcgBhbWJpZ3VvdXMgYC9gOyB3cmFwIHJlZ2V4cCBpbiBwYXJlbnRoZXNlcyBvciBhZGQgYSBzcGFjZSBhZnRlciBgL2Agb3BlcmF0b3IAYW1iaWd1b3VzIGZpcnN0IGFyZ3VtZW50OyBwdXQgcGFyZW50aGVzZXMgb3IgYSBzcGFjZSBldmVuIGFmdGVyIGAtYCBvcGVyYXRvcgBhbWJpZ3VvdXMgZmlyc3QgYXJndW1lbnQ7IHB1dCBwYXJlbnRoZXNlcyBvciBhIHNwYWNlIGV2ZW4gYWZ0ZXIgYCtgIG9wZXJhdG9yAGV4cGVjdGVkIGEgcGF0dGVybiBleHByZXNzaW9uIGFmdGVyIHRoZSBgKGAgb3BlcmF0b3IAYXJyYXlfc2VwYXJhdG9yAHN0cmluZyBzZXBhcmF0b3IAbGFiZWwgdGVybWluYXRvcgB1bmV4cGVjdGVkICVzLCBleHBlY3RlZCBhIHN0cmluZyBsaXRlcmFsIHRlcm1pbmF0b3IAcmVnZXhwX3BhcnNlX2Vycm9yAFRva2VuIEVycm9yAGZvcgBocgBwYXJzZSBkZXB0aCBsaW1pdCBvdmVyAHVuYXJ5X3JlY2VpdmVyAGRlZl9yZWNlaXZlcgB1bmV4cGVjdGVkICVzOyBleHBlY3RpbmcgYSBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIHJlY2VpdmVyAGRlZl9lbmRsZXNzX3NldHRlcgBleHBlY3Rfc2luZ2xldG9uX2NsYXNzX2RlbGltaXRlcgBleHBlY3RfZm9yX2RlbGltaXRlcgBleHBlY3RfaW5fZGVsaW1pdGVyAGV4cGVjdF93aGVuX2RlbGltaXRlcgB1bnRlcm1pbmF0ZWQgcmVnZXhwIG1lZXRzIGVuZCBvZiBmaWxlOyBleHBlY3RlZCBhIGNsb3NpbmcgZGVsaW1pdGVyAGV4cGVjdGVkIHN0cmluZyBjb250ZW50IGFmdGVyIG9wZW5pbmcgc3RyaW5nIGRlbGltaXRlcgBleHBlY3RfaWRlbnRfcmVxX3BhcmFtZXRlcgBleHBlY3RfcnBhcmVuX3JlcV9wYXJhbWV0ZXIAZXhwZWN0X2xwYXJlbl9yZXFfcGFyYW1ldGVyAHBtX25vZGVfZmxhZ19zZXRfcmVwZWF0ZWRfcGFyYW1ldGVyAHVuZXhwZWN0ZWQgYCpgOyBubyBhbm9ueW1vdXMgcmVzdCBwYXJhbWV0ZXIAdW5leHBlY3RlZCBgKipgOyBubyBhbm9ueW1vdXMga2V5d29yZCByZXN0IHBhcmFtZXRlcgB1bmV4cGVjdGVkIGAmYDsgbm8gYW5vbnltb3VzIGJsb2NrIHBhcmFtZXRlcgBleHBlY3RlZCBhIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwYXJhbWV0ZXIAZXhwZWN0ZWQgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGUga2V5d29yZCBwYXJhbWV0ZXIAZXhwZWN0ZWQgYW4gaWRlbnRpZmllciBmb3IgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcgBleHBlY3RlZCBhIGAoYCB0byBzdGFydCBhIHJlcXVpcmVkIHBhcmFtZXRlcgBleHBlY3RlZCBhIGApYCB0byBlbmQgYSByZXF1aXJlZCBwYXJhbWV0ZXIAdW5leHBlY3RlZCBuYW1lIGZvciBhIHBhcmFtZXRlcgBpbnZhbGlkX211bHRpYnl0ZV9jaGFyYWN0ZXIAaW52YWxpZF9lc2NhcGVfY2hhcmFjdGVyAGludmFsaWRfcHJpbnRhYmxlX2NoYXJhY3RlcgBpbnZhbGlkX2NoYXJhY3RlcgBzdXBlcgBwYXR0ZXJuX2ZpbmRfbWlzc2luZ19pbm5lcgBpbnZhbGlkX251bWJlcl91bmRlcnNjb3JlX2lubmVyAGhlcmVkb2NfaWRlbnRpZmllcgB1bnRlcm1pbmF0ZWQgaGVyZSBkb2N1bWVudCBpZGVudGlmaWVyAHBhcnNlX2FuZF92YWxpZGF0ZV9yZWd1bGFyX2V4cHJlc3Npb25fZW5jb2RpbmdfbW9kaWZpZXIAZXhwZWN0ZWQgYSB2YWx1ZSBhZnRlciB0aGUgYHJlc2N1ZWAgbW9kaWZpZXIAJ3Jlc2N1ZScgbW9kaWZpZXIAZXhwZWN0X2xwYXJlbl9hZnRlcl9ub3Rfb3RoZXIAaW50ZWdlcgBwYXJhbWV0ZXJfb3JkZXIAdW5leHBlY3RlZCBwYXJhbWV0ZXIgb3JkZXIAcG1fbnVtYmVyZWRfcmVmZXJlbmNlX3JlYWRfbm9kZV9udW1iZXIAaW52YWxpZCB1bmRlcnNjb3JlIHBsYWNlbWVudCBpbiBudW1iZXIAdHJhaWxpbmcgJ18nIGluIG51bWJlcgB3YnIAYXJndW1lbnRfZm9ybWFsX2l2YXIAYW1iaWd1b3VzX3ByZWZpeF9zdGFyAGFyZ3VtZW50X2NvbmZsaWN0X3N0YXIAYXJyYXlfZXhwcmVzc2lvbl9hZnRlcl9zdGFyAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX3N0YXIAcGFyYW1ldGVyX3N0YXIAYW1iaWd1b3VzX3ByZWZpeF9zdGFyX3N0YXIAYXJndW1lbnRfY29uZmxpY3Rfc3Rhcl9zdGFyAGFyZ3VtZW50X25vX2ZvcndhcmRpbmdfc3Rhcl9zdGFyAGFyZ3VtZW50X25vX2ZvcndhcmRpbmdfc3RhcgBwYXJhbWV0ZXJfY2lyY3VsYXIAaW52YWxpZF9tdWx0aWJ5dGVfY2hhcgB1bnNpZ25lZCBjaGFyAFxyAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX2FtcGFtcGVxAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX3BpcGVwaXBlZXEAcmVnZXhwX3V0ZjhfY2hhcl9ub25fdXRmOF9yZWdleHAAZW5kIHBhdHRlcm4gaW4gZ3JvdXAAL2Vtc2RrL2Vtc2NyaXB0ZW4vc3lzdGVtL2xpYi9saWJjeHhhYmkvc3JjL3ByaXZhdGVfdHlwZWluZm8uY3BwAGZvciBsb29wAGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgZm9yYCBsb29wAGludGVnZXJfaW5fZmxpcF9mbG9wAGludGVnZXIgbGl0ZXJhbCBpbiBmbGlwLWZsb3AAY2hvbXAAbmVzdGluZ190b29fZGVlcABuZXN0aW5nIHRvbyBkZWVwAHRva2VuX2JlZ2luc19leHByZXNzaW9uX3AAcG1fcGFyc2VyX3Njb3BlX3RvcGxldmVsX3AAcG1fc3RhdGljX2xpdGVyYWxfcG9zaXRpdmVfcABtYWNDZW50RXVybwBJbnZhbGlkIHJlZG8AU0pJUy1Eb0NvTW8AVVRGOC1Eb0NvTW8AVW5rbm93bgBwYXJzZV9yZXR1cm4Ac2hlYmFuZ19jYXJyaWFnZV9yZXR1cm4AdW5leHBlY3RlZF9jYXJyaWFnZV9yZXR1cm4AZXNjYXBlZCBjYXJyaWFnZSByZXR1cm4AdW5leHBlY3RlZCBtdWx0aXBsZSAnKicgcmVzdCBwYXR0ZXJucyBpbiBhbiBhcnJheSBwYXR0ZXJuAHVuZXhwZWN0ZWQgcmVzdCBwYXR0ZXJuAGZpbmQgcGF0dGVybnMgbmVlZCBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgaW5uZXIgcGF0dGVybgBleHBlY3RlZCBhIGxhYmVsIGFzIHRoZSBrZXkgaW4gdGhlIGhhc2ggcGF0dGVybgB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhIGtleSBpbiB0aGUgaGFzaCBwYXR0ZXJuAGV4cGVjdGVkIGEgbGFiZWwgYWZ0ZXIgdGhlIGAsYCBpbiB0aGUgaGFzaCBwYXR0ZXJuAGNvbXBhcmlzb25fYWZ0ZXJfY29tcGFyaXNvbgBjb21wYXJpc29uICclLipzJyBhZnRlciBjb21wYXJpc29uAHRlcm5hcnlfY29sb24AZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfcXVlc3Rpb24AdW5kZWZpbmVkIGdyb3VwIG9wdGlvbgBkZXNjcmlwdGlvbgB1bmV4cGVjdGVkIGFuIGBhbGlhc2AgYXQgYSBub24tc3RhdGVtZW50IHBvc2l0aW9uAHVuZXhwZWN0ZWQgYW4gYHVuZGVmYCBhdCBhIG5vbi1zdGF0ZW1lbnQgcG9zaXRpb24AdW5leHBlY3RlZCBhIGBCRUdJTmAgYXQgYSBub24tc3RhdGVtZW50IHBvc2l0aW9uAHVuZXhwZWN0ZWQgYW4gYEVORGAgYXQgYSBub24tc3RhdGVtZW50IHBvc2l0aW9uAHNpbmdsZXRvbiBjbGFzcyBkZWZpbml0aW9uAG1vZHVsZSBkZWZpbml0aW9uAGludmFsaWQgbWV0aG9kIG5hbWU7IGEgc2V0dGVyIG1ldGhvZCBjYW5ub3QgYmUgZGVmaW5lZCBpbiBhbiBlbmRsZXNzIG1ldGhvZCBkZWZpbml0aW9uAGV4cGVjdGVkIGEgcmVjZWl2ZXIgZm9yIHRoZSBtZXRob2QgZGVmaW5pdGlvbgBleHBlY3RlZCBhIGAuYCBvciBgOjpgIGFmdGVyIHRoZSByZWNlaXZlciBpbiBhIG1ldGhvZCBkZWZpbml0aW9uAGNvbmRpdGlvbgBmb3JfY29sbGVjdGlvbgB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhICdkbycsIG5ld2xpbmUsIG9yICc7JyBhZnRlciB0aGUgJ2ZvcicgbG9vcCBjb2xsZWN0aW9uAGludmFsaWRfbnVtYmVyX2ZyYWN0aW9uACYuIGluc2lkZSBtdWx0aXBsZSBhc3NpZ25tZW50IGRlc3RpbmF0aW9uAHN0cmluZ19jb25jYXRlbmF0aW9uAGV4cGVjdGVkIGEgc3RyaW5nIGZvciBjb25jYXRlbmF0aW9uAHVuZXhwZWN0ZWRfc2FmZV9uYXZpZ2F0aW9uAGxvY2F0aW9uAGFycmF5X2V4cHJlc3Npb24Abm90X2V4cHJlc3Npb24AcmVzY3VlX2V4cHJlc3Npb24AY2Fubm90X3BhcnNlX2V4cHJlc3Npb24Adm9pZF9leHByZXNzaW9uAGRlZmluZWRfZXhwcmVzc2lvbgB0ZXJuYXJ5IGV4cHJlc3Npb24AZXhwZWN0ZWQgYSBgfWAgdG8gY2xvc2UgdGhlIHBhdHRlcm4gZXhwcmVzc2lvbgBleHBlY3RlZCBhIGBdYCB0byBjbG9zZSB0aGUgcGF0dGVybiBleHByZXNzaW9uAGV4cGVjdGVkIGEgYClgIHRvIGNsb3NlIHRoZSBwYXR0ZXJuIGV4cHJlc3Npb24AdW5leHBlY3RlZCBiYXJlIGhhc2ggaW4gZXhwcmVzc2lvbgBJbnZhbGlkIGNoYXIgJ1x4JTAyWCcgaW4gZXhwcmVzc2lvbgBgJS4qc2AgYXQgdGhlIGVuZCBvZiBsaW5lIHdpdGhvdXQgYW4gZXhwcmVzc2lvbgB1bmV4cGVjdGVkIHZvaWQgdmFsdWUgZXhwcmVzc2lvbgBjYW5ub3QgcGFyc2UgdGhlIGV4cHJlc3Npb24AZXhwZWN0ZWQgYSByZXNjdWVkIGV4cHJlc3Npb24AZXhwZWN0ZWQgYSBgfWAgdG8gY2xvc2UgdGhlIGVtYmVkZGVkIGV4cHJlc3Npb24AdW5leHBlY3RlZCBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIGAqKmAgZXhwcmVzc2lvbgAnZGVmaW5lZD8nIGV4cHJlc3Npb24AdmVyc2lvbgBwbV9uZXdsaW5lX2xpc3RfbGluZV9jb2x1bW4AcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX3BpbgBzdGF0ZW1lbnRfcHJlZXhlX2JlZ2luAGZvcl9pbgBwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfaW4Ab3BlcmF0b3JfbXVsdGlfYXNzaWduAGFtcGFtcGVxX211bHRpX2Fzc2lnbgBwaXBlcGlwZWVxX211bHRpX2Fzc2lnbgBibG9jayBhcmd1bWVudCBzaG91bGQgbm90IGJlIGdpdmVuAHVuZXhwZWN0ZWQgJz0nOyB0YXJnZXQgY2Fubm90IGJlIHdyaXR0ZW4AY2hpbGRyZW4AZXhwZWN0X3JwYXJlbgBleHBlY3RfbHBhcmVuX2FmdGVyX25vdF9scGFyZW4AZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfbHBhcmVuAHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9wYXJlbgBhcmd1bWVudF90ZXJtX3BhcmVuAGRlZl9wYXJhbXNfdGVybV9wYXJlbgBwYXR0ZXJuX3Rlcm1fcGFyZW4AbGFtYmRhX29wZW4AbWlzc2luZyB0b2tlbgBVbmV4cGVjdGVkIHRva2VuAG5vdCBwcm92aWRlZCB0b2tlbgBVbmV4cGVjdGVkIFRva2VuAGNhc2VfZXhwcmVzc2lvbl9hZnRlcl93aGVuAHRoZW4ATWFjSmFwYW4AbmFuAGNvbnRleHRfaHVtYW4AcG1fdG9rZW5fdHlwZV9odW1hbgBwbV9kaWFnbm9zdGljX2lkX2h1bWFuAG1hY1JvbWFuAG1hY0Nyb2F0aWFuAFxuAGFycmF5X3Rlcm0AY2xhc3NfdGVybQBkZWZfcGFyYW1zX3Rlcm0AZm9yX3Rlcm0AbGlzdF93X2xvd2VyX3Rlcm0AbGlzdF9pX2xvd2VyX3Rlcm0AZGVmX3JlY2VpdmVyX3Rlcm0AbGlzdF93X3VwcGVyX3Rlcm0AbGlzdF9pX3VwcGVyX3Rlcm0AcmVnZXhwX3Rlcm0AYmVnaW5fdGVybQB1bnRpbF90ZXJtAHN0cmluZ19saXRlcmFsX3Rlcm0AY29uZGl0aW9uYWxfdGVybQBoYXNoX3Rlcm0AeHN0cmluZ190ZXJtAGRlZl90ZXJtAHJlc2N1ZV90ZXJtAGNvbmRpdGlvbmFsX3ByZWRpY2F0ZV90ZXJtAGJlZ2luX3VwY2FzZV90ZXJtAGVuZF91cGNhc2VfdGVybQBibG9ja19wYXJhbV9waXBlX3Rlcm0AbW9kdWxlX3Rlcm0Ad2hpbGVfdGVybQBlc2NhcGVfaW52YWxpZF91bmljb2RlX3Rlcm0Ac3RyaW5nX2ludGVycG9sYXRlZF90ZXJtAGhlcmVkb2NfdGVybQBlbWJkb2NfdGVybQBoYl9hcmVuYV9wYWdlX2FsbG9jX2Zyb20AU2xpbQBwYXJzZV9wcm9ncmFtAHBhcmFtAGVzY2FwZV9pbnZhbGlkX2NvbnRyb2wAYm9vbABkb3RfZG90X2RvdF9lb2wAa2V5d29yZF9lb2wAY29sAGludmFsaWRfc3ltYm9sAGludmFsaWQgc3ltYm9sAHVudGVybWluYXRlZCBzeW1ib2w7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBpbnRlcnBvbGF0ZWQgc3ltYm9sAHVudGVybWluYXRlZCBxdW90ZWQgc3RyaW5nOyBleHBlY3RlZCBhIGNsb3NpbmcgZGVsaW1pdGVyIGZvciB0aGUgZHluYW1pYyBzeW1ib2wAPD94bWwASGFtbAB1bmV4cGVjdGVkIGAuLi5gIGluIGFuIG5vbi1wYXJlbnRoZXNpemVkIGNhbGwAdW50aWwAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGVfbmlsACclLipzJyBpcyB0b28gYmlnIGZvciBhIG51bWJlciB2YXJpYWJsZSwgYWx3YXlzIG5pbABDYW4ndCBhc3NpZ24gdG8gbmlsAGJlZ2luX3VwY2FzZV90b3BsZXZlbABCRUdJTiBpcyBwZXJtaXR0ZWQgb25seSBhdCB0b3BsZXZlbABwbV9kaWFnbm9zdGljX2xldmVsAHBhdHRlcm5faGFzaF9rZXlfbGFiZWwAaGFzaF9leHByZXNzaW9uX2FmdGVyX2xhYmVsAHVuZXhwZWN0ZWRfbGFiZWwAdW5leHBlY3RlZCBsYWJlbABleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9lcXVhbABpbnZhbGlkX251bWJlcl9vY3RhbABpZ25vcmVkX2Zyb3plbl9zdHJpbmdfbGl0ZXJhbABlc2NhcGVfaW52YWxpZF91bmljb2RlX2xpdGVyYWwAY2hhcmFjdGVyIGxpdGVyYWwAcmVnZXhwIGxpdGVyYWwAc3ltYm9sIGxpdGVyYWwAdW5leHBlY3RlZCAlcywgZXhwZWN0aW5nICd9JyBvciBhIGtleSBpbiB0aGUgaGFzaCBsaXRlcmFsAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEgdmFsdWUgaW4gdGhlIGhhc2ggbGl0ZXJhbABleHBlY3RlZCBhIGB9YCB0byBjbG9zZSB0aGUgaGFzaCBsaXRlcmFsAHN0cmluZyBsaXRlcmFsAHVuZXhwZWN0ZWQgZnJhY3Rpb24gcGFydCBhZnRlciBudW1lcmljIGxpdGVyYWwAYSBsaXRlcmFsAGVxdWFsX2luX2NvbmRpdGlvbmFsAHBhcnNlX2NvbmRpdGlvbmFsAHJhdGlvbmFsAGludmFsaWRfbnVtYmVyX2hleGFkZWNpbWFsAGVzY2FwZV9pbnZhbGlkX2hleGFkZWNpbWFsAGludmFsaWRfbnVtYmVyX2RlY2ltYWwAYXJndW1lbnRfZm9ybWFsX2dsb2JhbABpbnZhbGlkX3ZhcmlhYmxlX2dsb2JhbABpbmNvbXBsZXRlX3F1ZXN0aW9uX21hcmsAbGluawBTSklTLVNvZnRCYW5rAFVURjgtU29mdEJhbmsAbWFjR3JlZWsAdW5leHBlY3RlZF9pbmRleF9ibG9jawBudW1iZXJlZF9wYXJhbWV0ZXJfb3V0ZXJfYmxvY2sAYXJndW1lbnRfYWZ0ZXJfYmxvY2sAbnVtYmVyZWRfcGFyYW1ldGVyX2lubmVyX2Jsb2NrAG9wZXJhdG9yX3dyaXRlX2Jsb2NrAHBhcnNlX2Jsb2NrAGFyZ3VtZW50X3VuZXhwZWN0ZWRfYmxvY2sAbnVtYmVyZWQgcGFyYW1ldGVyIGlzIGFscmVhZHkgdXNlZCBpbiBvdXRlciBibG9jawBudW1iZXJlZCBwYXJhbWV0ZXIgaXMgYWxyZWFkeSB1c2VkIGluIGlubmVyIGJsb2NrAHVuZXhwZWN0ZWQgYCpgOyBhbm9ueW1vdXMgcmVzdCBwYXJhbWV0ZXIgaXMgYWxzbyB1c2VkIHdpdGhpbiBibG9jawB1bmV4cGVjdGVkIGAqKmA7IGFub255bW91cyBrZXl3b3JkIHJlc3QgcGFyYW1ldGVyIGlzIGFsc28gdXNlZCB3aXRoaW4gYmxvY2sAdW5leHBlY3RlZCBgJmA7IGFub255bW91cyBibG9jayBwYXJhbWV0ZXIgaXMgYWxzbyB1c2VkIHdpdGhpbiBibG9jawBleHBlY3RlZCBhIGBkb2Aga2V5d29yZCBvciBhIGB7YCB0byBvcGVuIHRoZSBsYW1iZGEgYmxvY2sAJ3snLi4nfScgbGFtYmRhIGJsb2NrACdkbycuLidlbmQnIGxhbWJkYSBibG9jawB1bmV4cGVjdGVkIG9wZXJhdG9yIGFmdGVyIGEgY2FsbCB3aXRoIGEgYmxvY2sARVJCIGJsb2NrACd7Jy4uJ30nIGJsb2NrACdkbycuLidlbmQnIGJsb2NrACdCRUdJTicgYmxvY2sAJ0VORCcgYmxvY2sAcG1fdm9pZF9zdGF0ZW1lbnRzX2NoZWNrAHRyYWNrAEludmFsaWQgYnJlYWsAcGFyYW1ldGVyX3NwbGF0X211bHRpAHBhcmFtZXRlcl9hc3NvY19zcGxhdF9tdWx0aQBleHBlY3RfcnBhcmVuX2FmdGVyX211bHRpAGFyZ3VtZW50X2Jsb2NrX211bHRpAHBhcmFtZXRlcl9ibG9ja19tdWx0aQBtYWNUaGFpAG1pc21hdGNoZWQgaW5kZW50YXRpb25zIGF0ICclLipzJyB3aXRoICclLipzJyBhdCAlaQBrZXkgJS4qcyBpcyBkdXBsaWNhdGVkIGFuZCBvdmVyd3JpdHRlbiBvbiBsaW5lICVpAGluZGV4IDw9IGJ1ZmZlci0+bGVuZ3RoAHBtX2VuY29kaW5nX3V0Zl84X2NoYXJfd2lkdGgAcHVzaABtYWNUdXJraXNoAGJhY2tzbGFzaABhbWJpZ3VvdXNfc2xhc2gAZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfc3BsYXRfaGFzaABhcmd1bWVudF9iYXJlX2hhc2gAZXhwcmVzc2lvbl9iYXJlX2hhc2gAbm9kZV9oYXNoAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIGxhYmVsIGluIGEgaGFzaABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGAqKmAgaW4gYSBoYXNoAHJlZ2V4cF9lbmNvZGluZ19vcHRpb25fbWlzbWF0Y2gAaW5kZW50YXRpb25fbWlzbWF0Y2gAc3ZnAGVzY2FwZV9pbnZhbGlkX3VuaWNvZGVfbG9uZwB1bnNpZ25lZCBsb25nIGxvbmcAdW5zaWduZWQgbG9uZwB0YWdfY2xvc2luZwBzdGQ6OndzdHJpbmcAYmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAHN0ZDo6dTE2c3RyaW5nAHN0ZDo6dTMyc3RyaW5nAHVua25vd24gdHlwZSBvZiAlc3RyaW5nAGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJXhgIG9yIGJhY2t0aWNrIHN0cmluZwB1bnRlcm1pbmF0ZWQgc3RyaW5nOyBleHBlY3RlZCBhIGNsb3NpbmcgZGVsaW1pdGVyIGZvciB0aGUgaW50ZXJwb2xhdGVkIHN0cmluZwByZWd1bGFyIGV4cHJlc3Npb24gYmVnaW5uaW5nAGhlcmVkb2MgYmVnaW5uaW5nAHRhZ19vcGVuaW5nAGludmFsaWRfbnVtYmVyX3VuZGVyc2NvcmVfdHJhaWxpbmcAZXhwZXJpbWVudGFsX2V2ZXJ5dGhpbmcAYXJndW1lbnRfYmxvY2tfZm9yd2FyZGluZwB1bmV4cGVjdGVkIC4uLiB3aGVuIHRoZSBwYXJlbnQgbWV0aG9kIGlzIG5vdCBmb3J3YXJkaW5nAHJlZ2V4cF9pbmNvbXBhdF9jaGFyX2VuY29kaW5nAGV4cHJlc3Npb25fbm90X3dyaXRhYmxlX2VuY29kaW5nAG1peGVkX2VuY29kaW5nAHJlZ3VsYXIgZXhwcmVzc2lvbiBlbmRpbmcAc3RyaW5nIGVuZGluZwBoZXJlZG9jIGVuZGluZwBpbWcAb3Blbl90YWcAY2xvc2luZ190YWcAb3BlbmluZ190YWcAY2xvc2VfdGFnACVnAGludmFsaWRfcGVyY2VudF9lb2YAc3RyaW5nX2xpdGVyYWxfZW9mAGluZgBleHByZXNzaW9uX25vdF93cml0YWJsZV9zZWxmAENhbid0IGNoYW5nZSB0aGUgdmFsdWUgb2Ygc2VsZgBlbHNpZgBzdGF0ZW1lbnRfdW5kZWYAXGYAcG1fbG9jYWxzX3Jlc2l6ZQBwbV9jb25zdGFudF9wb29sX3Jlc2l6ZQBoYl9hcmVuYV9hbGlnbl9zaXplAGNvbnN0YW50X2lkICE9IFBNX0NPTlNUQU5UX0lEX1VOU0VUICYmIGNvbnN0YW50X2lkIDw9IHBvb2wtPnNpemUAdGVybmFyeV9leHByZXNzaW9uX3RydWUAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGVfdHJ1ZQBDYW4ndCBhc3NpZ24gdG8gdHJ1ZQBpbnZhbGlkX21hZ2ljX2NvbW1lbnRfdmFsdWUAc2hhcmVhYmxlX2NvbnN0YW50X3ZhbHVlAHJlc2N1ZV9tb2RpZmllcl92YWx1ZQBoYXNoX3ZhbHVlAHBtX3N0cmluZ192YWx1ZQBwbV9pbnQ2NF92YWx1ZQBwYXJhbWV0ZXIgZGVmYXVsdCB2YWx1ZQBVbmVzY2FwZWQgcXVvdGUgY2hhcmFjdGVyIGluIGF0dHJpYnV0ZSB2YWx1ZQBleHBlY3RlZCBhIGA9PmAgYmV0d2VlbiB0aGUgaGFzaCBrZXkgYW5kIHZhbHVlAGludmFsaWRfcmV0cnlfd2l0aG91dF9yZXNjdWUASW52YWxpZCByZXRyeSB3aXRob3V0IHJlc2N1ZQBJbnZhbGlkIHF1b3RlIGNoYXJhY3RlciBmb3IgSFRNTCBhdHRyaWJ1dGUAb3Blbl9xdW90ZQBjbG9zaW5nX3F1b3RlAG9wZW5pbmdfcXVvdGUAY2xvc2VfcXVvdGUAcG1fbG9jYWxzX3dyaXRlAHVuZXhwZWN0ZWRfbXVsdGlfd3JpdGUAaW52YWxpZF9sb2NhbF92YXJpYWJsZV93cml0ZQBwbV9mbG9hdF9ub2RlX3JhdGlvbmFsX2ltYWdpbmFyeV9jcmVhdGUAcG1faW50ZWdlcl9ub2RlX3JhdGlvbmFsX2ltYWdpbmFyeV9jcmVhdGUAcG1fZmxvYXRfbm9kZV9pbWFnaW5hcnlfY3JlYXRlAHBtX2ludGVnZXJfbm9kZV9pbWFnaW5hcnlfY3JlYXRlAHBtX2hhc2hfcGF0dGVybl9ub2RlX25vZGVfbGlzdF9jcmVhdGUAcG1fY2FsbF9ub2RlX25vdF9jcmVhdGUAcG1fc3ltYm9sX25vZGVfbGFiZWxfY3JlYXRlAHBtX2Zsb2F0X25vZGVfcmF0aW9uYWxfY3JlYXRlAHBtX2ludGVnZXJfbm9kZV9yYXRpb25hbF9jcmVhdGUAcG1fcmV0cnlfbm9kZV9jcmVhdGUAcG1fbmV4dF9ub2RlX2NyZWF0ZQBwbV9pbXBsaWNpdF9yZXN0X25vZGVfY3JlYXRlAHBtX2luZGV4X3RhcmdldF9ub2RlX2NyZWF0ZQBwbV9mbG9hdF9ub2RlX2NyZWF0ZQBwbV9hc3NvY19zcGxhdF9ub2RlX2NyZWF0ZQBwbV9mb3J3YXJkaW5nX2FyZ3VtZW50c19ub2RlX2NyZWF0ZQBwbV9ub19rZXl3b3Jkc19wYXJhbWV0ZXJfbm9kZV9jcmVhdGUAcG1fYmxvY2tfcGFyYW1ldGVyX25vZGVfY3JlYXRlAHBtX2ZvcndhcmRpbmdfcGFyYW1ldGVyX25vZGVfY3JlYXRlAHBtX3N1cGVyX25vZGVfY3JlYXRlAHBtX2ZvcndhcmRpbmdfc3VwZXJfbm9kZV9jcmVhdGUAcG1faW50ZWdlcl9ub2RlX2NyZWF0ZQBwbV9yZWRvX25vZGVfY3JlYXRlAHBtX2ZpbmRfcGF0dGVybl9ub2RlX2NyZWF0ZQBwbV9uaWxfbm9kZV9jcmVhdGUAcG1fYnJlYWtfbm9kZV9jcmVhdGUAcG1faGFzaF9ub2RlX2NyZWF0ZQBwbV9zb3VyY2VfZW5jb2Rpbmdfbm9kZV9jcmVhdGUAcG1fc2VsZl9ub2RlX2NyZWF0ZQBwbV91bmRlZl9ub2RlX2NyZWF0ZQBwbV90cnVlX25vZGVfY3JlYXRlAHBtX2luZGV4X29wZXJhdG9yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NhbGxfb3BlcmF0b3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1faW5kZXhfb3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY29uc3RhbnRfb3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY2FsbF9vcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jb25zdGFudF9wYXRoX29yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NsYXNzX3ZhcmlhYmxlX29yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2xvY2FsX3ZhcmlhYmxlX29yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2dsb2JhbF92YXJpYWJsZV9vcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9pbnN0YW5jZV92YXJpYWJsZV9vcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9pbmRleF9hbmRfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY29uc3RhbnRfYW5kX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NhbGxfYW5kX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NvbnN0YW50X3BhdGhfYW5kX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NsYXNzX3ZhcmlhYmxlX2FuZF93cml0ZV9ub2RlX2NyZWF0ZQBwbV9sb2NhbF92YXJpYWJsZV9hbmRfd3JpdGVfbm9kZV9jcmVhdGUAcG1fZ2xvYmFsX3ZhcmlhYmxlX2FuZF93cml0ZV9ub2RlX2NyZWF0ZQBwbV9pbnN0YW5jZV92YXJpYWJsZV9hbmRfd3JpdGVfbm9kZV9jcmVhdGUAcG1fZmFsc2Vfbm9kZV9jcmVhdGUAcG1fc291cmNlX2xpbmVfbm9kZV9jcmVhdGUAcG1fc291cmNlX2ZpbGVfbm9kZV9jcmVhdGUAcG1fYWxpYXNfZ2xvYmFsX3ZhcmlhYmxlX25vZGVfY3JlYXRlAHBtX2FsaWFzX21ldGhvZF9ub2RlX2NyZWF0ZQBwbV9jb25zdGFudF9yZWFkX25vZGVfY3JlYXRlAHBtX2NsYXNzX3ZhcmlhYmxlX3JlYWRfbm9kZV9jcmVhdGUAcG1faW5zdGFuY2VfdmFyaWFibGVfcmVhZF9ub2RlX2NyZWF0ZQBwbV9iYWNrX3JlZmVyZW5jZV9yZWFkX25vZGVfY3JlYXRlAHBtX251bWJlcmVkX3JlZmVyZW5jZV9yZWFkX25vZGVfY3JlYXRlAHVuZXhwZWN0ZWQgaW1wbGljaXQgaGFzaCBpbiBwYXR0ZXJuOyB1c2UgJ3snIHRvIGRlbGluZWF0ZQBwYXR0ZXJuX2hhc2hfa2V5X2R1cGxpY2F0ZQBwYXR0ZXJuX2NhcHR1cmVfZHVwbGljYXRlAGNvbmRpdGlvbmFsX3VubGVzc19wcmVkaWNhdGUAY29uZGl0aW9uYWxfdW50aWxfcHJlZGljYXRlAGNhc2VfbWF0Y2hfbWlzc2luZ19wcmVkaWNhdGUAY29uZGl0aW9uYWxfZWxzaWZfcHJlZGljYXRlAGNvbmRpdGlvbmFsX2lmX3ByZWRpY2F0ZQBjb25kaXRpb25hbF93aGlsZV9wcmVkaWNhdGUAbG9vcCBwcmVkaWNhdGUAZHVwbGljYXRlZF93aGVuX2NsYXVzZQByZXNjdWVfY2xhdXNlAGVsc2VfY2xhdXNlAGVuc3VyZV9jbGF1c2UAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGNvbmRpdGlvbmFsIGNsYXVzZQBleHBlY3RlZCBhIGRlbGltaXRlciBhZnRlciB0aGUgcGF0dGVybnMgb2YgYW4gYGluYCBjbGF1c2UAZXhwZWN0ZWQgYSBkZWxpbWl0ZXIgYWZ0ZXIgdGhlIHByZWRpY2F0ZXMgb2YgYSBgd2hlbmAgY2xhdXNlAGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgcmVzY3VlYCBjbGF1c2UAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGBlbHNlYCBjbGF1c2UAJ2luJyBjbGF1c2UAJ3doZW4nIGNsYXVzZQAnZWxzaWYnIGNsYXVzZQAncmVzY3VlJyBjbGF1c2UAJ2Vsc2UnIGNsYXVzZQAnZW5zdXJlJyBjbGF1c2UAZmxvYXRfcGFyc2UAcG1faW50ZWdlcl9wYXJzZQBsaXRlcmFsX2luX2NvbmRpdGlvbl92ZXJib3NlAGJlZ2luX2xvbmVseV9lbHNlAGludmFsaWRfcmV0cnlfYWZ0ZXJfZWxzZQBjb25kaXRpb25hbF90ZXJtX2Vsc2UASW52YWxpZCByZXRyeSBhZnRlciBlbHNlAHRlcm5hcnlfZXhwcmVzc2lvbl9mYWxzZQBleHByZXNzaW9uX25vdF93cml0YWJsZV9mYWxzZQBDYW4ndCBhc3NpZ24gdG8gZmFsc2UATWFjSmFwYW5lc2UAY2FzZV9leHByZXNzaW9uX2FmdGVyX2Nhc2UAcG1faW50ZWdlcl9jb252ZXJ0X2Jhc2UAaW52YWxpZF9yZXRyeV9hZnRlcl9lbnN1cmUASW52YWxpZCByZXRyeSBhZnRlciBlbnN1cmUAdW5leHBlY3RlZF90b2tlbl9pZ25vcmUAbnVtYmVyX2xpdGVyYWxfdW5kZXJzY29yZQBjbGFzc192YXJpYWJsZV9iYXJlAGdsb2JhbF92YXJpYWJsZV9iYXJlAGluc3RhbmNlX3ZhcmlhYmxlX2JhcmUAcHJvdG90eXBlAGV4cGVjdGVkX3R5cGUAcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX3BpcGUAcG1fdG9rZW5fYnVmZmVyX2VzY2FwZQBpbnZhbGlkX211bHRpYnl0ZV9lc2NhcGUAdW50ZXJtaW5hdGVkIFVuaWNvZGUgZXNjYXBlAG5vbmUAbmV4dF9uZXdsaW5lAGlnbm9yZWQgbmV3bGluZQBwbV9uZXdsaW5lX2xpc3RfbGluZQBzaGFyZWFibGVfY29uc3RhbnRfdmFsdWVfbGluZQBleHByZXNzaW9uX25vdF93cml0YWJsZV9saW5lACdzaGFyZWFibGVfY29uc3RhbnRfdmFsdWUnIGlzIGlnbm9yZWQgdW5sZXNzIGluIGNvbW1lbnQtb25seSBsaW5lAGVtYmVkZGVkIGRvY3VtZW50YXRpb24gbGluZQBtYWNVa3JhaW5lAGNsYXNzX25hbWUAdGFnX25hbWUAZGVmX25hbWUAcG1fZ2xvYmFsX3ZhcmlhYmxlX3dyaXRlX25hbWUAbW9kdWxlX25hbWUAcGFyYW1ldGVyX21ldGhvZF9uYW1lAGR1cGxpY2F0ZWQga2V5IG5hbWUAZHVwbGljYXRlZCBhcmd1bWVudCBuYW1lACdAQCcgd2l0aG91dCBpZGVudGlmaWVycyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWUAYCUuKnMnIGlzIG5vdCBhbGxvd2VkIGFzIGEgY2xhc3MgdmFyaWFibGUgbmFtZQAnJS4qcycgaXMgbm90IGFsbG93ZWQgYXMgYSBjbGFzcyB2YXJpYWJsZSBuYW1lACckJyB3aXRob3V0IGlkZW50aWZpZXJzIGlzIG5vdCBhbGxvd2VkIGFzIGEgZ2xvYmFsIHZhcmlhYmxlIG5hbWUAYCUuKnMnIGlzIG5vdCBhbGxvd2VkIGFzIGEgZ2xvYmFsIHZhcmlhYmxlIG5hbWUAJyUuKnMnIGlzIG5vdCBhbGxvd2VkIGFzIGEgZ2xvYmFsIHZhcmlhYmxlIG5hbWUAJ0AnIHdpdGhvdXQgaWRlbnRpZmllcnMgaXMgbm90IGFsbG93ZWQgYXMgYW4gaW5zdGFuY2UgdmFyaWFibGUgbmFtZQBgJS4qcycgaXMgbm90IGFsbG93ZWQgYXMgYW4gaW5zdGFuY2UgdmFyaWFibGUgbmFtZQAnJS4qcycgaXMgbm90IGFsbG93ZWQgYXMgYW4gaW5zdGFuY2UgdmFyaWFibGUgbmFtZQBkdXBsaWNhdGVkIHZhcmlhYmxlIG5hbWUAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSBtZXRob2QgbmFtZQBzdHlsZQBtb2R1bGUARW1hY3MtTXVsZQB3aGlsZQBleHByZXNzaW9uX25vdF93cml0YWJsZV9maWxlAGVtYmVkZGVkIGRvY3VtZW50IG1lZXRzIGVuZCBvZiBmaWxlAHVudGVybWluYXRlZCBxdW90ZWQgc3RyaW5nIG1lZXRzIGVuZCBvZiBmaWxlAHVudGVybWluYXRlZCBzdHJpbmcgbWVldHMgZW5kIG9mIGZpbGUAZG91YmxlAGV4cHJlc3Npb25fbm90X3dyaXRhYmxlAG5vX2xvY2FsX3ZhcmlhYmxlAGJsb2NrX3BhcmFtX2xvY2FsX3ZhcmlhYmxlAHVudXNlZF9sb2NhbF92YXJpYWJsZQByZXNjdWVfdmFyaWFibGUAaW52YWxpZCBmb3JtYWwgYXJndW1lbnQ7IGZvcm1hbCBhcmd1bWVudCBjYW5ub3QgYmUgYSBjbGFzcyB2YXJpYWJsZQAlLipzOiBubyBzdWNoIGxvY2FsIHZhcmlhYmxlAGludmFsaWQgYXJndW1lbnQgYmVpbmcgcGFzc2VkIHRvIGBhbGlhc2A7IGV4cGVjdGVkIGEgYmFyZSB3b3JkLCBzeW1ib2wsIGNvbnN0YW50LCBvciBnbG9iYWwgdmFyaWFibGUAaW52YWxpZCBmb3JtYWwgYXJndW1lbnQ7IGZvcm1hbCBhcmd1bWVudCBjYW5ub3QgYmUgYSBnbG9iYWwgdmFyaWFibGUAaW52YWxpZCBmb3JtYWwgYXJndW1lbnQ7IGZvcm1hbCBhcmd1bWVudCBjYW5ub3QgYmUgYW4gaW5zdGFuY2UgdmFyaWFibGUAaW52YWxpZCBlbWJlZGRlZCB2YXJpYWJsZQBhIHZhcmlhYmxlAHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9yYW5nZQBmbG9hdF9vdXRfb2ZfcmFuZ2UAcmVnZXhwX2ludmFsaWRfdW5pY29kZV9yYW5nZQBGbG9hdCAlLipzJXMgb3V0IG9mIHJhbmdlAGV4cGVjdF9tZXNzYWdlAGVycm9yX21lc3NhZ2UAcG1fZGlhZ25vc3RpY19tZXNzYWdlAGhiX2FyZW5hX2FwcGVuZF9wYWdlAHBtX3N0YXRpY19saXRlcmFsX2luc3BlY3Rfbm9kZQBlbmRfbm9kZQBiYWRfYXJyYXlfbmV3X2xlbmd0aCB3YXMgdGhyb3duIGluIC1mbm8tZXhjZXB0aW9ucyBtb2RlAGJhZF9hbGxvYyB3YXMgdGhyb3duIGluIC1mbm8tZXhjZXB0aW9ucyBtb2RlAGVzY2FwZV9pbnZhbGlkX3VuaWNvZGUAVVRGLTggbWl4ZWQgd2l0aGluICVzIHNvdXJjZQBpbnZhbGlkIGhleCBlc2NhcGUgc2VxdWVuY2UAaW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZQBhbGlhc19hcmd1bWVudF9udW1iZXJlZF9yZWZlcmVuY2UAaW52YWxpZF9udW1iZXJlZF9yZWZlcmVuY2UAYmFjayByZWZlcmVuY2UAbnVtYmVyZWQgcmVmZXJlbmNlAGluY29tcGxldGVfdmFyaWFibGVfaW5zdGFuY2UAcGF0dGVybl90ZXJtX2JyYWNlAGJsb2NrX3Rlcm1fYnJhY2UAbGFtYmRhX3Rlcm1fYnJhY2UAYmVnaW5fdXBjYXNlX2JyYWNlAGVuZF91cGNhc2VfYnJhY2UAdHJhY2tfd2hpdGVzcGFjZQBlbmNvdW50ZXJlZCBcciBpbiBtaWRkbGUgb2YgbGluZSwgdHJlYXRlZCBhcyBhIG1lcmUgc3BhY2UAZXNjYXBlZCBzcGFjZQBwYXJhbWV0ZXJfdW5leHBlY3RlZF9md2QAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIGBpbmAga2V5d29yZAB3cml0ZV90YXJnZXRfaW5fbWV0aG9kAGNsYXNzX2luX21ldGhvZABtb2R1bGVfaW5fbWV0aG9kAGVuZF9pbl9tZXRob2QAbG9jYWwgdmFyaWFibGUgb3IgbWV0aG9kAHNjcmlwdF9ub3RfZm91bmQAYXJndW1lbnRfZm9yd2FyZGluZ191bmJvdW5kAHBtX3BhcnNlcl9zY29wZV9maW5kAHBtX25ld2xpbmVfbGlzdF9hcHBlbmQAcG1fY2FzZV9tYXRjaF9ub2RlX2NvbmRpdGlvbl9hcHBlbmQAcG1fY2FzZV9ub2RlX2NvbmRpdGlvbl9hcHBlbmQAcG1faW50ZXJwb2xhdGVkX3N0cmluZ19ub2RlX2FwcGVuZABwbV9pbnRlcnBvbGF0ZWRfbm9kZV9hcHBlbmQAY29tbWVudF9lbmQAZW1iZXhwcl9lbmQAYmxvY2tfdGVybV9lbmQAbGFtYmRhX3Rlcm1fZW5kAHN0YXRlbWVudF9wb3N0ZXhlX2VuZABjbGFzc191bmV4cGVjdGVkX2VuZABwYXJzZXJfZmx1c2hfaGVyZWRvY19lbmQAcGFyc2VyLT5oZXJlZG9jX2VuZCA8PSBwYXJzZXItPmVuZABwYXJzZXItPmN1cnJlbnQuZW5kIDw9IHBhcnNlci0+ZW5kAHN0YXJ0IDw9IGVuZABhbWJpZ3VvdXNfcHJlZml4X2FtcGVyc2FuZABhcmd1bWVudF9jb25mbGljdF9hbXBlcnNhbmQAYXJndW1lbnRfbm9fZm9yd2FyZGluZ19hbXBlcnNhbmQAbWFjSWNlbGFuZABwYXJzZV95aWVsZABpbnZhbGlkX3lpZWxkAEludmFsaWQgeWllbGQAaXNfdm9pZABlbWJ2YXJfaW52YWxpZAByZXR1cm5faW52YWxpZABzeW1ib2xfaW52YWxpZABkaWFnbm9zdGljX2lkAHVuYXJ5X2Rpc2FsbG93ZWQAaW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZTsgTXVsdGlwbGUgY29kZXBvaW50cyBhdCBzaW5nbGUgY2hhcmFjdGVyIGxpdGVyYWwgYXJlIGRpc2FsbG93ZWQAc3ltYm9sIGxpdGVyYWwgd2l0aCBpbnRlcnBvbGF0aW9uIGlzIG5vdCBhbGxvd2VkAG11bHRpcGxlIGJsb2NrIHBhcmFtZXRlcnM7IG9ubHkgb25lIGJsb2NrIGlzIGFsbG93ZWQAYm90aCBibG9jayBhcmcgYW5kIGFjdHVhbCBibG9jayBnaXZlbjsgb25seSBvbmUgYmxvY2sgaXMgYWxsb3dlZABwYXJhbWV0ZXJfbnVtYmVyZWRfcmVzZXJ2ZWQAcXVvdGVkAHdyaXRlX3RhcmdldF91bmV4cGVjdGVkAHBhdHRlcm5faGFzaF9rZXlfaW50ZXJwb2xhdGVkAHN5bWJvbF90ZXJtX2ludGVycG9sYXRlZABpbnZhbGlkIGNvbnRyb2wgZXNjYXBlIHNlcXVlbmNlOyBjb250cm9sIGNhbm5vdCBiZSByZXBlYXRlZABpbnZhbGlkIG1ldGEgZXNjYXBlIHNlcXVlbmNlOyBtZXRhIGNhbm5vdCBiZSByZXBlYXRlZABwYXJhbWV0ZXJfbmFtZV9kdXBsaWNhdGVkACdpdCcgaXMgbm90IGFsbG93ZWQgd2hlbiBhIG51bWJlcmVkIHBhcmFtZXRlciBpcyBhbHJlYWR5IHVzZWQAbnVtYmVyZWQgcGFyYW1ldGVycyBhcmUgbm90IGFsbG93ZWQgd2hlbiAnaXQnIGlzIGFscmVhZHkgdXNlZABwYXJzZWQAJ3doZW4nIGNsYXVzZSBvbiBsaW5lICVpIGR1cGxpY2F0ZXMgJ3doZW4nIGNsYXVzZSBvbiBsaW5lICVpIGFuZCBpcyBpZ25vcmVkAGV4cHJlc3Npb25fbm90X3dyaXRhYmxlX251bWJlcmVkAGl0X25vdF9hbGxvd2VkX251bWJlcmVkACdpdCcgaXMgbm90IGFsbG93ZWQgd2hlbiBhbiBvcmRpbmFyeSBwYXJhbWV0ZXIgaXMgZGVmaW5lZABudW1iZXJlZCBwYXJhbWV0ZXJzIGFyZSBub3QgYWxsb3dlZCB3aGVuIGFuIG9yZGluYXJ5IHBhcmFtZXRlciBpcyBkZWZpbmVkAHVuZXhwZWN0ZWQgcmFuZ2Ugb3BlcmF0b3I7IC4uIGFuZCAuLi4gYXJlIG5vbi1hc3NvY2lhdGl2ZSBhbmQgY2Fubm90IGJlIGNoYWluZWQAbWFsbG9jX2ZhaWxlZAB0YXJnZXQgb2YgcmVwZWF0IG9wZXJhdG9yIGlzIG5vdCBzcGVjaWZpZWQAc3RhdGVtZW50IG5vdCByZWFjaGVkAGVzY2FwZWQgZm9ybSBmZWVkAGVtYmVkAGxvYWQAcG1fbG9jYWxzX3VucmVhZABwbV9sb2NhbHNfcmVhZABpbnZhbGlkX2xvY2FsX3ZhcmlhYmxlX3JlYWQAJWQAaGJfYXJlbmFfYWxsb2MAcGFyc2VfbmVnYXRpdmVfbnVtZXJpYwBzeW1ib2xfdGVybV9keW5hbWljAG1hY0N5cmlsbGljAHJlZ2V4cF9ub25fZXNjYXBlZF9tYmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC44LjIvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yOTI0ZjhmODgzMmQvc3JjL3V0aWwvcG1fbmV3bGluZV9saXN0LmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC44LjIvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yOTI0ZjhmODgzMmQvc3JjL3N0YXRpY19saXRlcmFscy5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuOC4yL3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjkyNGY4Zjg4MzJkL3NyYy91dGlsL3BtX2ludGVnZXIuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjguMi92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTI5MjRmOGY4ODMyZC9zcmMvdXRpbC9wbV9idWZmZXIuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjguMi92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTI5MjRmOGY4ODMyZC9zcmMvcHJpc20uYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjguMi92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTI5MjRmOGY4ODMyZC9zcmMvdXRpbC9wbV9jb25zdGFudF9wb29sLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC44LjIvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yOTI0ZjhmODgzMmQvc3JjL3V0aWwvcG1fc3RycGJyay5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuOC4yL3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjkyNGY4Zjg4MzJkL3NyYy91dGlsL3BtX3N0cmluZy5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuOC4yL3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjkyNGY4Zjg4MzJkL3NyYy9lbmNvZGluZy5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuOC4yL3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjkyNGY4Zjg4MzJkL3NyYy90b2tlbl90eXBlLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC44LjIvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yOTI0ZjhmODgzMmQvc3JjL2RpYWdub3N0aWMuYwAuLi9zcmMvdXRpbC9oYl9hcmVuYS5jAHByaXNtL3RlbXBsYXRlcy9zcmMvbm9kZS5jLmVyYgBlc2NhcGVkIGhvcml6b250YWwgdGFiAGVzY2FwZWQgdmVydGljYWwgdGFiAFxiAGVzY2FwZV9pbnZhbGlkX21ldGEAZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfY29tbWEAcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX2NvbW1hAHBhdHRlcm5fbGFiZWxfYWZ0ZXJfY29tbWEAcGFyYW1ldGVyX3dpbGRfbG9vc2VfY29tbWEAaW52YWxpZF9jb21tYQBpbnZhbGlkIGNvbW1hAG1hY1JvbWFuaWEAYXJlYQBcYQBleHBlY3RlZCBhIGxhbWJkYSBibG9jayBiZWdpbm5pbmcgd2l0aCBge2AgdG8gZW5kIHdpdGggYH1gAGV4cGVjdGVkIGEgYmxvY2sgYmVnaW5uaW5nIHdpdGggYHtgIHRvIGVuZCB3aXRoIGB9YABleHBlY3RlZCB0aGUgYmxvY2sgcGFyYW1ldGVycyB0byBlbmQgd2l0aCBgfGAAdW50ZXJtaW5hdGVkIGxpc3Q7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJXdgAGV4cGVjdGVkIGEgYChgIGltbWVkaWF0ZWx5IGFmdGVyIGBub3RgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYG5vdGAAZXhwZWN0ZWQgYSBgKGAgYWZ0ZXIgYG5vdGAAZXhwZWN0ZWQgYW4gaW5kZXggYWZ0ZXIgYGZvcmAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgd2hlbmAAdW50ZXJtaW5hdGVkIGxpc3Q7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJWlgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYGNhc2VgAGV4cGVjdGVkIGEgYHdoZW5gIG9yIGBpbmAgY2xhdXNlIGFmdGVyIGBjYXNlYABleHBlY3RlZCBhIGxhbWJkYSBibG9jayBiZWdpbm5pbmcgd2l0aCBgZG9gIHRvIGVuZCB3aXRoIGBlbmRgAGV4cGVjdGVkIGEgYmxvY2sgYmVnaW5uaW5nIHdpdGggYGRvYCB0byBlbmQgd2l0aCBgZW5kYAB1bmV4cGVjdGVkICVzLCBleHBlY3RlZCBhIHJlY2VpdmVyIGZvciB1bmFyeSBgJWNgAGludmFsaWQgY2hhcmFjdGVyIGAlY2AAbnVtYmVyIGxpdGVyYWwgZW5kaW5nIHdpdGggYSBgX2AAZXhwZWN0ZWQgYSBtYXRjaGluZyBgXWAAdW50ZXJtaW5hdGVkIGxpc3Q7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJVdgAGV4cGVjdGVkIGEgYHtgIGFmdGVyIGBCRUdJTmAAdW50ZXJtaW5hdGVkIGxpc3Q7IGV4cGVjdGVkIGEgY2xvc2luZyBkZWxpbWl0ZXIgZm9yIHRoZSBgJUlgAGV4cGVjdGVkIGEgYHtgIGFmdGVyIGBFTkRgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYGRlZmluZWQ/YABpbmNvbXBsZXRlIGV4cHJlc3Npb24gYXQgYD9gAGV4cGVjdGVkIGEgcGF0dGVybiBleHByZXNzaW9uIGFmdGVyIGA9PmAAYDwlIHJldHJ5ICU+YABgPCUgbmV4dCAlPmAAYDwlIHVubGVzcyAlPmAAYDwlIGZvciAlPmAAYDwlIHJlZG8gJT5gAGA8JSBiZWdpbiAlPmAAYDwlIGluICU+YABgPCUgd2hlbiAlPmAAYDwlIHVudGlsICU+YABgPCUgYnJlYWsgJT5gAGA8JSBlbHNpZiAlPmAAYDwlIGlmICU+YABgPCUgcmVzY3VlICU+YABgPCUgZWxzZSAlPmAAYDwlIGNhc2UgJT5gAGA8JSBlbnN1cmUgJT5gAGA8JSB3aGlsZSAlPmAAYDwlIGVuZCAlPmAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgfHw9YABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGA9YABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGAmJj1gAGV4cGVjdGVkIGEgc3VwZXJjbGFzcyBhZnRlciBgPGAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgPDxgAHVuZXhwZWN0ZWQgYXJndW1lbnQgYWZ0ZXIgYC4uLmAAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgYCxgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYCxgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYCpgAHVuZXhwZWN0ZWQgcGFyYW1ldGVyIGAqYABleHBlY3RlZCBhIG1hdGNoaW5nIGApYABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGAoYAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX19fRU5DT0RJTkdfXwBDYW4ndCBhc3NpZ24gdG8gX19FTkNPRElOR19fAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfX19MSU5FX18AQ2FuJ3QgYXNzaWduIHRvIF9fTElORV9fAGZpbGVfa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX19fRklMRV9fAENhbid0IGFzc2lnbiB0byBfX0ZJTEVfXwBfX0VORF9fACRfAFtdAGxpc3QtPnNpemUgPT0gMCB8fCBuZXdsaW5lX29mZnNldCA+IGxpc3QtPm9mZnNldHNbbGlzdC0+c2l6ZSAtIDFdAFxcADwhW0NEQVRBWwB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX1JFVFJZAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0ZMT0FUX0lNQUdJTkFSWQB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9JTlRFR0VSX0lNQUdJTkFSWQB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9GTE9BVF9SQVRJT05BTF9JTUFHSU5BUlkAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fSU5URUdFUl9SQVRJT05BTF9JTUFHSU5BUlkAQklOQVJZAGRpYWdfaWQgPCBQTV9ESUFHTk9TVElDX0lEX01BWABpbmRleCAhPSBVSU5UMzJfTUFYAGxvY2FsLT5yZWFkcyA8IFVJTlQzMl9NQVgAXHUlMDRYAFx4JTAyWABpbnZhbGlkIG11bHRpYnl0ZSBjaGFyYWN0ZXIgMHglWABldWNUVwBFVUMtVFcAS09JOC1VAFVua25vd24gZXJyb3JfdHlwZV9UAFVua25vd24gdG9rZW5fdHlwZV9UAFVua25vd24gYXN0X25vZGVfdHlwZV9UAGtleXdvcmQtPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9ORVhUAFRPS0VOX0hUTUxfQ09NTUVOVF9TVEFSVABUT0tFTl9IVE1MX1RBR19TVEFSVABUT0tFTl9JREVOVElGSUVSLCBUT0tFTl9RVU9URSwgVE9LRU5fRVJCX1NUQVJUAFRPS0VOX0NEQVRBX1NUQVJUAHRva2VuLT50eXBlID09IFBNX1RPS0VOX1VET1RfRE9UX0RPVABUT0tFTl9FUkJfQ09OVEVOVABUT0tFTl9QRVJDRU5UAHVuZXhwZWN0ZWQgY29uc3RhbnQgcGF0aCBhZnRlciBgY2xhc3NgOyBjbGFzcy9tb2R1bGUgbmFtZSBtdXN0IGJlIENPTlNUQU5UAHVuZXhwZWN0ZWQgY29uc3RhbnQgcGF0aCBhZnRlciBgbW9kdWxlYDsgY2xhc3MvbW9kdWxlIG5hbWUgbXVzdCBiZSBDT05TVEFOVABUT0tFTl9MVABBU0NJSS04QklUAHBtX2JpbmRpbmdfcG93ZXJzW3R5cGVdLmxlZnQgPT0gUE1fQklORElOR19QT1dFUl9VTlNFVABsaXN0LT5pZHNbaW5kZXhdID09IFBNX0NPTlNUQU5UX0lEX1VOU0VUAFRPS0VOX0FUAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0ZMT0FUAFRPS0VOX0VRVUFMUwBTaGlmdF9KSVMAU0pJUwBVVEYtOC1IRlMAQmlnNS1IS1NDUwBrZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfQUxJQVMAVU5DTE9TRURfRUxFTUVOVF9FUlJPUgBVTkVYUEVDVEVEX1RPS0VOX0VSUk9SAG5vdCBUT0tFTl9FUlJPUgBRVU9URVNfTUlTTUFUQ0hfRVJST1IAVEFHX05BTUVTX01JU01BVENIX0VSUk9SAFZPSURfRUxFTUVOVF9DTE9TSU5HX1RBR19FUlJPUgBNSVNTSU5HX0NMT1NJTkdfVEFHX0VSUk9SAE1JU1NJTkdfT1BFTklOR19UQUdfRVJST1IATUlTU0lOR0VSQl9FTkRfVEFHX0VSUk9SAFJVQllfUEFSU0VfRVJST1IARVJCX0NPTlRST0xfRkxPV19TQ09QRV9FUlJPUgBVTkVYUEVDVEVEX0VSUk9SAGV1Y0tSAEVVQy1LUgBUT0tFTl9DSEFSQUNURVIAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9TVVBFUgBrZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfU1VQRVIAVE9LRU5fSURFTlRJRklFUgB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9JTlRFR0VSAG9wZXJhdG9yLT50eXBlID09IFBNX1RPS0VOX1VTVEFSX1NUQVIgfHwgb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fU1RBUl9TVEFSAG9wZXJhdG9yLT50eXBlID09IFBNX1RPS0VOX1VTVEFSX1NUQVIAcGFyc2VyLT5jdXJyZW50LnR5cGUgPT0gUE1fVE9LRU5fVVNUQVJfU1RBUgBwYXJzZXItPnByZXZpb3VzLnR5cGUgPT0gUE1fVE9LRU5fVVNUQVIAS09JOC1SAFRPS0VOX05CU1AAZXVjSlAARVVDLUpQAHN0YXRlbGVzcy1JU08tMjAyMi1KUAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX1JFRE8AQmlnNS1VQU8AVE9LRU5fQ09MT04AVE9LRU5fU0VNSUNPTE9OAFRPS0VOX1hNTF9ERUNMQVJBVElPTgBUT0tFTl9FWENMQU1BVElPTgBwYXJzZXItPmN1cnJlbnQudHlwZSA9PSBQTV9UT0tFTl9TVFJJTkdfQkVHSU4AZXVjQ04ARVVDLUNOAE5BTgBleHRyYWN0SFRNTABwYXJhbXMtPmtleXdvcmRfcmVzdCA9PSBOVUxMAHRhcmdldC0+YmxvY2sgPT0gTlVMTABwYXJhbXMtPmJsb2NrID09IE5VTEwAcmVzdCAhPSBOVUxMAHBhcnNlci0+Y3VycmVudF9ibG9ja19leGl0cyAhPSBOVUxMAHoyLnZhbHVlcyAhPSBOVUxMAHowLnZhbHVlcyAhPSBOVUxMAHJlY2VpdmVyICE9IE5VTEwAYWxsb2NhdG9yLT50YWlsICE9IE5VTEwAb3BlbmluZyAhPSBOVUxMAHNjb3BlICE9IE5VTEwAc291cmNlICE9IE5VTEwAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9OSUwAa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX05JTABvcGVyYXRvci0+dHlwZSA9PSBQTV9UT0tFTl9QSVBFX1BJUEVfRVFVQUwAb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fQU1QRVJTQU5EX0FNUEVSU0FORF9FUVVBTAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9GTE9BVF9SQVRJT05BTAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9JTlRFR0VSX1JBVElPTkFMAFBDSwBUT0tFTl9CQUNLVElDSwBHQksAa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX0JSRUFLAGNzV2luZG93czMxSgBXaW5kb3dzLTMxSgBVUy1BU0NJSQBTSklTLUtEREkAc3RhdGVsZXNzLUlTTy0yMDIyLUpQLUtEREkAVVRGOC1LRERJAFRPS0VOX1NMQVNIAFRPS0VOX0JBQ0tTTEFTSABUT0tFTl9EQVNIAGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fUElQRSB8fCBjbG9zaW5nLT50eXBlID09IFBNX1RPS0VOX1BBUkVOVEhFU0lTX1JJR0hUIHx8IGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fTUlTU0lORwBuYW1lLT50eXBlID09IFBNX1RPS0VOX0NPTlNUQU5UIHx8IG5hbWUtPnR5cGUgPT0gUE1fVE9LRU5fTUlTU0lORwBlbmRfa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX0VORCB8fCBlbmRfa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9NSVNTSU5HAGxleF9tb2RlLT5tb2RlID09IFBNX0xFWF9TVFJJTkcAVE9LRU5fRU9GAHVudGVybWluYXRlZCBoZXJlZG9jOyBjYW4ndCBmaW5kIHN0cmluZyAiJS4qcyIgYW55d2hlcmUgYmVmb3JlIEVPRgBJTkYAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9TRUxGAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfVU5ERUYAJEYAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9UUlVFAFRPS0VOX1FVT1RFAFRPS0VOX0hUTUxfVEFHX1NUQVJUX0NMT1NFAFRPS0VOX0hUTUxfVEFHX1NFTEZfQ0xPU0UAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9GQUxTRQBUT0tFTl9VTkRFUlNDT1JFAFRPS0VOX0hUTUxfRE9DVFlQRQA8IURPQ1RZUEUAVE9LRU5fRVJCX1NUQVJULCBUT0tFTl9IVE1MX0RPQ1RZUEUsIFRPS0VOX0hUTUxfQ09NTUVOVF9TVEFSVCwgVE9LRU5fSURFTlRJRklFUiwgVE9LRU5fV0hJVEVTUEFDRSwgVE9LRU5fTkJTUCwgVE9LRU5fQVQsIFRPS0VOX0JBQ0tTTEFTSCwgb3IgVE9LRU5fTkVXTElORQBUT0tFTl9JREVOVElGSUVSLCBUT0tFTl9BVCwgVE9LRU5fRVJCX1NUQVJULFRPS0VOX1dISVRFU1BBQ0UsIG9yIFRPS0VOX05FV0xJTkUAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fQ0xBU1NfVkFSSUFCTEUAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fSU5TVEFOQ0VfVkFSSUFCTEUAQVNUX0hUTUxfVEVYVF9OT0RFAEFTVF9FUkJfQ09OVEVOVF9OT0RFAEFTVF9ET0NVTUVOVF9OT0RFAEFTVF9IVE1MX0NPTU1FTlRfTk9ERQBBU1RfSFRNTF9FTEVNRU5UX05PREUAQVNUX0VSQl9VTkxFU1NfTk9ERQBBU1RfRVJCX0ZPUl9OT0RFAFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9CTE9DS19MT0NBTF9WQVJJQUJMRV9OT0RFIHx8IFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9CTE9DS19QQVJBTUVURVJfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fS0VZV09SRF9SRVNUX1BBUkFNRVRFUl9OT0RFIHx8IFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9PUFRJT05BTF9LRVlXT1JEX1BBUkFNRVRFUl9OT0RFIHx8IFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9PUFRJT05BTF9QQVJBTUVURVJfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fUkVRVUlSRURfS0VZV09SRF9QQVJBTUVURVJfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fUkVRVUlSRURfUEFSQU1FVEVSX05PREUgfHwgUE1fTk9ERV9UWVBFKG5vZGUpID09IFBNX1JFU1RfUEFSQU1FVEVSX05PREUAQVNUX1hNTF9ERUNMQVJBVElPTl9OT0RFAEFTVF9FUkJfSU5fTk9ERQBBU1RfRVJCX0JFR0lOX05PREUAQVNUX0VSQl9XSEVOX05PREUAQVNUX0VSQl9VTlRJTF9OT0RFAEFTVF9MSVRFUkFMX05PREUAQVNUX0VSQl9CTE9DS19OT0RFAEFTVF9FUkJfQ0FTRV9NQVRDSF9OT0RFAEFTVF9IVE1MX09QRU5fVEFHX05PREUAQVNUX0hUTUxfQ0xPU0VfVEFHX05PREUAQVNUX0VSQl9JRl9OT0RFAEFTVF9IVE1MX0FUVFJJQlVURV9WQUxVRV9OT0RFAEFTVF9FUkJfUkVTQ1VFX05PREUAQVNUX0hUTUxfQVRUUklCVVRFX05PREUAQVNUX0VSQl9FTFNFX05PREUAQVNUX0VSQl9DQVNFX05PREUAQVNUX0VSQl9FTlNVUkVfTk9ERQBBU1RfSFRNTF9ET0NUWVBFX05PREUAQVNUX0hUTUxfQVRUUklCVVRFX05BTUVfTk9ERQBBU1RfRVJCX1dISUxFX05PREUAQVNUX1dISVRFU1BBQ0VfTk9ERQBBU1RfRVJCX0VORF9OT0RFAEFTVF9FUkJfWUlFTERfTk9ERQBBU1RfQ0RBVEFfTk9ERQBuYW1lLT50eXBlID09IFBNX1RPS0VOX0JBQ0tfUkVGRVJFTkNFAG5hbWUtPnR5cGUgPT0gUE1fVE9LRU5fTlVNQkVSRURfUkVGRVJFTkNFAFRPS0VOX1dISVRFU1BBQ0UAVE9LRU5fSFRNTF9DT01NRU5UX0VORABUT0tFTl9YTUxfREVDTEFSQVRJT05fRU5EAFRPS0VOX0hUTUxfVEFHX0VORABUT0tFTl9FUkJfRU5EAFRPS0VOX0NEQVRBX0VORABvcGVyYXRvci0+dHlwZSA9PSBQTV9UT0tFTl9OT1RfUFJPVklERUQgfHwgb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fVUFNUEVSU0FORCB8fCBvcGVyYXRvci0+dHlwZSA9PSBQTV9UT0tFTl9BTVBFUlNBTkQAY2xvc2luZy0+dHlwZSA9PSBQTV9UT0tFTl9CUkFDS0VUX1JJR0hUIHx8IGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fU1RSSU5HX0VORCB8fCBjbG9zaW5nLT50eXBlID09IFBNX1RPS0VOX01JU1NJTkcgfHwgY2xvc2luZy0+dHlwZSA9PSBQTV9UT0tFTl9OT1RfUFJPVklERUQAcGFyc2VyLT5sZXhfbW9kZXMuY3VycmVudC0+bW9kZSA9PSBQTV9MRVhfSEVSRURPQwBVVEY4LU1BQwB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9DT01NQQBsaWJwcmlzbUAALCBsaWJoZXJiQAAtQAArQABjYXRjaGluZyBhIGNsYXNzIHdpdGhvdXQgYW4gb2JqZWN0PwAuLi4gYXQgRU9MLCBzaG91bGQgYmUgcGFyZW50aGVzaXplZD8AZGVmaW5lZD8AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AIzxFbmNvZGluZzolcz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AXV0+AD8+AD4+ADw9PgAvPgAtLT4APSU+AC0lPgAlJT4AW109AD4+PQA8JT09AGZvdW5kIGA9IGxpdGVyYWwnIGluIGNvbmRpdGlvbmFsLCBzaG91bGQgYmUgPT0AZm91bmQgJz0gbGl0ZXJhbCcgaW4gY29uZGl0aW9uYWwsIHNob3VsZCBiZSA9PQA8PD0APCU9ADwlJT0APDwAJDsAOjoAXzkAQ1A4NjkASUJNODY5AENQOTQ5AElTTzg4NTktOQBJU08tODg1OS05AF84AEdCMTk4OABDUDg3OABBTlNJX1gzLjQtMTk2OABDUDEyNTgAV2luZG93cy0xMjU4AEJpZzUtSEtTQ1M6MjAwOABDRVNVLTgAVVRGLTgASVNPODg1OS04AElTTy04ODU5LTgAXzcAQ1A4NTcASUJNODU3AENQMTI1NwBXaW5kb3dzLTEyNTcAQ1A3MzcASUJNNzM3AENQNDM3AElCTTQzNwBJU084ODU5LTcASVNPLTg4NTktNwBfNgBDUDg2NgBJQk04NjYAQ1AxMjU2AFdpbmRvd3MtMTI1NgA2NDYAQ1A5MzYASVNPODg1OS0xNgBJU08tODg1OS0xNgBJU084ODU5LTYASVNPLTg4NTktNgBCaWc1AF81AENQNzc1AElCTTc3NQBDUDg2NQBJQk04NjUAQ1A4NTUASUJNODU1AENQMTI1NQBXaW5kb3dzLTEyNTUAR0IxMjM0NQBJU084ODU5LTE1AElTTy04ODU5LTE1AElTTzg4NTktNQBJU08tODg1OS01AF80AENQODc0AFdpbmRvd3MtODc0AENQODY0AElCTTg2NABDUDEyNTQAV2luZG93cy0xMjU0AElTTzg4NTktMTQASVNPLTg4NTktMTQARVVDLUpJUy0yMDA0AElTTzg4NTktNABJU08tODg1OS00AGluY29tcGxldGVfdmFyaWFibGVfY2xhc3NfM18zAGVxdWFsX2luX2NvbmRpdGlvbmFsXzNfMwBpbnZhbGlkX3ZhcmlhYmxlX2dsb2JhbF8zXzMAaW5jb21wbGV0ZV92YXJpYWJsZV9pbnN0YW5jZV8zXzMAQ1A4NjMASUJNODYzAENQMTI1MwBXaW5kb3dzLTEyNTMARVVDLUpJU1gwMjEzAElTTzg4NTktMTMASVNPLTg4NTktMTMASVNPODg1OS0zAElTTy04ODU5LTMAXzIAQ1A4NjIASUJNODYyAENQODUyAElCTTg1MgBDUDEyNTIAV2luZG93cy0xMjUyAENQOTMyAENQNTE5MzIAR0IyMzEyADAuOC4yAElTTzg4NTktMgBJU08tODg1OS0yAF8xAENQODYxAElCTTg2MQBDUDk1MQBDUDEyNTEAV2luZG93cy0xMjUxAElTTzg4NTktMTEASVNPLTg4NTktMTEAQ1A2NTAwMQBJU084ODU5LTEASVNPLTg4NTktMQBDUDg2MABJQk04NjAAQ1A5NTAAQ1A4NTAASUJNODUwAENQMTI1MABXaW5kb3dzLTEyNTAAR0IxODAzMABDUDcyMABJQk03MjAAVElTLTYyMABJU084ODU5LTEwAElTTy04ODU5LTEwADEuNi4wADAuMAAoMABsb2NhbC0+cmVhZHMgPiAwAGJpZ2ludHNfbGVuZ3RoID4gMABkaWZmID4gMABtaW5pbXVtX3NpemUgPiAwAHN0YXRlbWVudHMtPmJvZHkuc2l6ZSA+IDAAbm9kZS0+Ym9keS5zaXplID4gMABuID49IDAAbGVuZ3RoID49IDAAKGxhYmVsLmVuZCAtIGxhYmVsLnN0YXJ0KSA+PSAwAC8uLi4vbiBoYXMgYSBub24gZXNjYXBlZCBub24gQVNDSUkgY2hhcmFjdGVyIGluIG5vbiBBU0NJSS04QklUIHNjcmlwdDogLyUuKnMvAGluY29tcGF0aWJsZSBjaGFyYWN0ZXIgZW5jb2Rpbmc6IC8lLipzLwBpbnZhbGlkIG11bHRpYnl0ZSBlc2NhcGU6IC8lLipzLwBpbnZhbGlkIFVuaWNvZGUgcmFuZ2U6IC8lLipzLwBVVEYtOCBjaGFyYWN0ZXIgaW4gbm9uIFVURi04IHJlZ2V4cDogLyVzLwA8LwAkLwAlcyBzdGFydGVkIGhlcmUgYnV0IG5ldmVyIGNsb3NlZCB3aXRoIGFuIGVuZCB0YWcuIFRoZSBlbmQgdGFnIG1heSBiZSBpbiBhIGRpZmZlcmVudCBzY29wZS4ARm91bmQgY2xvc2luZyB0YWcgYDwvJXM+YCBhdCAoJXU6JXUpIHdpdGhvdXQgYSBtYXRjaGluZyBvcGVuaW5nIHRhZyBpbiB0aGUgc2FtZSBzY29wZS4AT3BlbmluZyB0YWcgYDwlcz5gIGF0ICgldToldSkgZG9lc24ndCBoYXZlIGEgbWF0Y2hpbmcgY2xvc2luZyB0YWcgYDwvJXM+YCBpbiB0aGUgc2FtZSBzY29wZS4AJXMuIEV4cGVjdGVkOiBgJXNgLCBmb3VuZDogYCVzYC4AYCVzYCBpcyBhIHZvaWQgZWxlbWVudCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIGEgY2xvc2luZyB0YWcuIFVzZSBgPCVzPmAgb3IgYDwlcyAvPmAgaW5zdGVhZCBvZiBgPC8lcz5gLgAuLi4AU3RyaW5nIG9wZW5lZCB3aXRoICVzIGJ1dCBjbG9zZWQgd2l0aCAlcyBhdCAoJXU6JXUpLgBGb3VuZCBgJXNgIHdoZW4gZXhwZWN0aW5nIGAlc2AgYXQgKCV1OiV1KS4AT3BlbmluZyB0YWcgYDwlcz5gIGF0ICgldToldSkgY2xvc2VkIHdpdGggYDwvJXM+YCBhdCAoJXU6JXUpLgAlcyBhcHBlYXJzIG91dHNpZGUgaXRzIGNvbnRyb2wgZmxvdyBibG9jay4gS2VlcCBFUkIgY29udHJvbCBmbG93IHN0YXRlbWVudHMgdG9nZXRoZXIgd2l0aGluIHRoZSBzYW1lIEhUTUwgc2NvcGUgKHRhZywgYXR0cmlidXRlLCBvciBjb250ZW50KS4AXE0tAFxDLQA8IS0tADwlLQAgLQArACoqAGlzX3Bvd2VyX29mX3R3byhwb29sLT5jYXBhY2l0eSkAIChXZWJBc3NlbWJseSkAaW52YWxpZCBtdWx0aWJ5dGUgY2hhciAoJXMpAChudWxsKQBpKQBiYWNrdGljayAoYCkAKG1vZGlmaWVyID09ICduJyAmJiBtb2RpZmllcl9lbmNvZGluZyA9PSBQTV9FTkNPRElOR19BU0NJSV84QklUX0VOVFJZKSB8fCAobW9kaWZpZXIgPT0gJ3UnICYmIG1vZGlmaWVyX2VuY29kaW5nID09IFBNX0VOQ09ESU5HX1VURl84X0VOVFJZKSB8fCAobW9kaWZpZXIgPT0gJ2UnICYmIG1vZGlmaWVyX2VuY29kaW5nID09IFBNX0VOQ09ESU5HX0VVQ19KUF9FTlRSWSkgfHwgKG1vZGlmaWVyID09ICdzJyAmJiBtb2RpZmllcl9lbmNvZGluZyA9PSBQTV9FTkNPRElOR19XSU5ET1dTXzMxSl9FTlRSWSkAcGFnZV9zaXplIDw9IFNJWkVfTUFYIC0gc2l6ZW9mKGhiX2FyZW5hX3BhZ2VfVCkAIXRhcmdldC0+YmxvY2sgfHwgUE1fTk9ERV9UWVBFX1AodGFyZ2V0LT5ibG9jaywgUE1fQkxPQ0tfQVJHVU1FTlRfTk9ERSkAUE1fTk9ERV9UWVBFX1AocmlnaHQsIFBNX1NQTEFUX05PREUpAFBNX05PREVfVFlQRV9QKGxlZnQsIFBNX1NQTEFUX05PREUpAGJvZHkgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChib2R5LCBQTV9TVEFURU1FTlRTX05PREUpAHN0YXRlbWVudHMgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChzdGF0ZW1lbnRzLCBQTV9TVEFURU1FTlRTX05PREUpAFBNX05PREVfVFlQRV9QKGNvbmRpdGlvbiwgUE1fSU5fTk9ERSkAUE1fTk9ERV9UWVBFX1AoY29uZGl0aW9uLCBQTV9XSEVOX05PREUpAFBNX05PREVfVFlQRV9QKHRhcmdldCwgUE1fTE9DQUxfVkFSSUFCTEVfUkVBRF9OT0RFKSB8fCBQTV9OT0RFX1RZUEVfUCh0YXJnZXQsIFBNX0lUX0xPQ0FMX1ZBUklBQkxFX1JFQURfTk9ERSkgfHwgUE1fTk9ERV9UWVBFX1AodGFyZ2V0LCBQTV9DQUxMX05PREUpAGFyZ3VtZW50cy0+YmxvY2sgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChhcmd1bWVudHMtPmJsb2NrLCBQTV9CTE9DS19OT0RFKQBQTV9OT0RFX1RZUEVfUChub2RlLCBQTV9IQVNIX05PREUpIHx8IFBNX05PREVfVFlQRV9QKG5vZGUsIFBNX0tFWVdPUkRfSEFTSF9OT0RFKQBQTV9OT0RFX1RZUEVfUChub2RlLCBQTV9MT0NBTF9WQVJJQUJMRV9SRUFEX05PREUpAHNpemUgPD0gU0laRV9NQVggLSAoYWxpZ25tZW50IC0gMSkAcG9vbC0+c2l6ZSA8ICgodWludDMyX3QpICgxIDw8IDMwKSkAc2luZ2xlIHF1b3RlICgnKSBvciBkb3VibGUgcXVvdGUgKCIpAGVzY2FwZWQgcXVvdGUgKFwnKSBvciBkaWZmZXJlbnQgcXVvdGUgc3R5bGUgKCIpACc9ficAJ34nACchficAJ30nACd8fCcAJ3wnACd7JwAnI3snACdyZXRyeScAJyV4JwAnJXcnACduZXh0JwAnbm90JwAndW5sZXNzJwAnY2xhc3MnACdhbGlhcycAY291bGQgbm90IHBhcnNlIHRoZSBmbG9hdCAnJS4qcycAcmVnZXhwIGVuY29kaW5nIG9wdGlvbiAnJWMnIGRpZmZlcnMgZnJvbSBzb3VyY2UgZW5jb2RpbmcgJyVzJwAnZm9yJwAnb3InACdzdXBlcicAJ3JlZG8nACdkbycAJ3JldHVybicAJz1iZWdpbicAJ2JlZ2luJwAnaW4nACd3aGVuJwAndGhlbicAZXhwZWN0ZWQgYHRoZW5gIG9yIGA7YCBvciAnXG4nAHVuZXhwZWN0ZWQgYGVuZGAsIGV4cGVjdGluZyAnOycgb3IgJ1xuJwAqY3Vyc29yID09ICdcbicAJ3VudGlsJwAnbmlsJwAnYnJlYWsnACclaScAJ3NlbGYnACdlbHNpZicAJ2lmJwAndW5kZWYnACdkZWYnACd0cnVlJwAncmVzY3VlJwAnZWxzZScAJ2ZhbHNlJwAnY2FzZScAJ2Vuc3VyZScAJ21vZHVsZScAJ3doaWxlJwAnPWVuZCcAJ2VuZCcAJ2FuZCcAJ3lpZWxkJwAnYCcAJ19fRU5DT0RJTkdfXycAJ19fTElORV9fJwAnX19GSUxFX18nACdfX0VORF9fJwAnXicAJ1tdJwAnXScAJ1snACclVycAJ0JFR0lOJwAnJUknACdFTkQnACdkZWZpbmVkPycAJz8n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Xh4AAF4eAABgHgAAYB4AAGIeAABiHgAAZB4AAGQeAABmHgAAZh4AAGgeAABoHgAAah4AAGoeAABsHgAAbB4AAG4eAABuHgAAcB4AAHAeAAByHgAAch4AAHQeAAB0HgAAdh4AAHYeAAB4HgAAeB4AAHoeAAB6HgAAfB4AAHweAAB+HgAAfh4AAIAeAACAHgAAgh4AAIIeAACEHgAAhB4AAIYeAACGHgAAiB4AAIgeAACKHgAAih4AAIweAACMHgAAjh4AAI4eAACQHgAAkB4AAJIeAACSHgAAlB4AAJQeAACeHgAAnh4AAKAeAACgHgAAoh4AAKIeAACkHgAApB4AAKYeAACmHgAAqB4AAKgeAACqHgAAqh4AAKweAACsHgAArh4AAK4eAACwHgAAsB4AALIeAACyHgAAtB4AALQeAAC2HgAAth4AALgeAAC4HgAAuh4AALoeAAC8HgAAvB4AAL4eAAC+HgAAwB4AAMAeAADCHgAAwh4AAMQeAADEHgAAxh4AAMYeAADIHgAAyB4AAMoeAADKHgAAzB4AAMweAADOHgAAzh4AANAeAADQHgAA0h4AANIeAADUHgAA1B4AANYeAADWHgAA2B4AANgeAADaHgAA2h4AANweAADcHgAA3h4AAN4eAADgHgAA4B4AAOIeAADiHgAA5B4AAOQeAADmHgAA5h4AAOgeAADoHgAA6h4AAOoeAADsHgAA7B4AAO4eAADuHgAA8B4AAPAeAADyHgAA8h4AAPQeAAD0HgAA9h4AAPYeAAD4HgAA+B4AAPoeAAD6HgAA/B4AAPweAAD+HgAA/h4AAAgfAAAPHwAAGB8AAB0fAAAoHwAALx8AADgfAAA/HwAASB8AAE0fAABZHwAAWR8AAFsfAABbHwAAXR8AAF0fAABfHwAAXx8AAGgfAABvHwAAiB8AAI8fAACYHwAAnx8AAKgfAACvHwAAuB8AALwfAADIHwAAzB8AANgfAADbHwAA6B8AAOwfAAD4HwAA/B8AAAIhAAACIQAAByEAAAchAAALIQAADSEAABAhAAASIQAAFSEAABUhAAAZIQAAHSEAACQhAAAkIQAAJiEAACYhAAAoIQAAKCEAACohAAAtIQAAMCEAADMhAAA+IQAAPyEAAEUhAABFIQAAYCEAAG8hAACDIQAAgyEAALYkAADPJAAAACwAAC8sAABgLAAAYCwAAGIsAABkLAAAZywAAGcsAABpLAAAaSwAAGssAABrLAAAbSwAAHAsAAByLAAAciwAAHUsAAB1LAAAfiwAAIAsAACCLAAAgiwAAIQsAACELAAAhiwAAIYsAACILAAAiCwAAIosAACKLAAAjCwAAIwsAACOLAAAjiwAAJAsAACQLAAAkiwAAJIsAACULAAAlCwAAJYsAACWLAAAmCwAAJgsAACaLAAAmiwAAJwsAACcLAAAniwAAJ4sAACgLAAAoCwAAKIsAACiLAAApCwAAKQsAACmLAAApiwAAKgsAACoLAAAqiwAAKosAACsLAAArCwAAK4sAACuLAAAsCwAALAsAACyLAAAsiwAALQsAAC0LAAAtiwAALYsAAC4LAAAuCwAALosAAC6LAAAvCwAALwsAAC+LAAAviwAAMAsAADALAAAwiwAAMIsAADELAAAxCwAAMYsAADGLAAAyCwAAMgsAADKLAAAyiwAAMwsAADMLAAAziwAAM4sAADQLAAA0CwAANIsAADSLAAA1CwAANQsAADWLAAA1iwAANgsAADYLAAA2iwAANosAADcLAAA3CwAAN4sAADeLAAA4CwAAOAsAADiLAAA4iwAAOssAADrLAAA7SwAAO0sAADyLAAA8iwAAECmAABApgAAQqYAAEKmAABEpgAARKYAAEamAABGpgAASKYAAEimAABKpgAASqYAAEymAABMpgAATqYAAE6mAABQpgAAUKYAAFKmAABSpgAAVKYAAFSmAABWpgAAVqYAAFimAABYpgAAWqYAAFqmAABcpgAAXKYAAF6mAABepgAAYKYAAGCmAABipgAAYqYAAGSmAABkpgAAZqYAAGamAABopgAAaKYAAGqmAABqpgAAbKYAAGymAACApgAAgKYAAIKmAACCpgAAhKYAAISmAACGpgAAhqYAAIimAACIpgAAiqYAAIqmAACMpgAAjKYAAI6mAACOpgAAkKYAAJCmAACSpgAAkqYAAJSmAACUpgAAlqYAAJamAACYpgAAmKYAAJqmAACapgAAIqcAACKnAAAkpwAAJKcAACanAAAmpwAAKKcAACinAAAqpwAAKqcAACynAAAspwAALqcAAC6nAAAypwAAMqcAADSnAAA0pwAANqcAADanAAA4pwAAOKcAADqnAAA6pwAAPKcAADynAAA+pwAAPqcAAECnAABApwAA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BwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAwAAAAADAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwcAAAcHBwcABwcAAwADAAMDAAADAwMDAAMDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAHAAAHBwcHAAAHAAMAAAADAwAAAwMDAwAAAwcHBwAHBwcHBwcHBwcHBwcABwcHBwcHAAcHBwcHBwcDAwMDAAMDAwMDAwMDAwMDAwADAwMDAwMAAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcDBwAHBwAABwcHBwAHAAADAAMAAwMAAAMDAwMHAwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBwcHBwcHBwcHBwcABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMDAwMDAwADAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwcHAAcABwcDBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAADAAAAAAMAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHBwcHBwAHBwcHBwAHBwADAwMDAwMAAwMDAwMAAwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAHAAAAAAADAAADAAMAAAAAAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcDAAcDBwAHAAcDBwAABwcDBwMHAwAHAwMDBwMHAwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAwADAAAAAAAAAAAABwMAAAMAAwAHAwcABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwMHAAAHAAMABwAHAAMHAAAHAwcAAAADAwMABwMHAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAAMDAAAAAAADAAAAAAAHBwAHBwAAAAAABwAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAABwAHBwcHAAAAAAAAAAAAAAMAAwMDAwAAAAcABwAAAAAHAAAAAAcAAAADAAMAAAADAwAHAAMDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAABwcAAwAAAAAAAAcABwcHBwMAAAAAAAAAAAADAAMDAwMABwMHAAcAAAcABwAAAAAHAAAHAwMDAAADAAMAAwcDAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAHAAcABwAAAAAAAAAAAAAAAwADAAMHAAAAAAAAAAAAAAMAAAAAAAAAAAAAAwAAAAADAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAMHAAcHBwAHAAcHAwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAADAAMAAAcAAAAAAAAAAAAAAwAAAAAAAAAAAAADAAAAAAMAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAHAAAAAAADAAADAAMAAAAAAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANbcAfwBAAAQAQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0KXAAAAAANClwjAAAAXCAJDA0LCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAEALAAAAAQAAAAMAAEALAAAEAAAAAAsAAAABAAAAAwAAQAsAAEAhAABABQAAAAsAAAABAAAAAwAAQAsAAAALAAAAAQAAAAMAAEALAAACAAAAAgAAAAiAAAAAAQAAwAEAABAAAAAAAQAAAAQAAMABAAAEAAAAAAsAAAABAAAAAwAAQAsAACAQAAACAAAAAAsAAAABAAAAAwAAQAsAAAIAAAAAgAAABAAAAABQAQAEAAAAAgAAAAALAAAAAQAAAAMAAEALAAACAAAAQAEAAAABAAAAAQAAAAAAAAAAAAD1kAEAlJABADeQAQBXjwEA5Y4BAIaOAQAzjgEAzo0BAKONAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAQMDAwAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA///8/Pz8/Pzw8AAAAAAAAADAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACqAMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4P////////////////////////////////AP8KCwwNDg/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wSAIAiDkCAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAADwSAIA0DkCAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAA8EgCABw6AgBOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAPBIAgBoOgIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAADwSAIAkDoCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAA8EgCALg6AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAPBIAgDgOgIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAADwSAIACDsCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAA8EgCADA7AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAAPBIAgBYOwIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAADwSAIAgDsCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAA8EgCAKg7AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAAPBIAgDQOwIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeEVFAADwSAIA+DsCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXlFRQAA8EgCACA8AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAAPBIAgBIPAIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAAAUlgEAB6EBAAehAQAHoQEAB6EBAAehAQAHoQEAB6EBAAehAQAHoQEAf39/f39/f39/f39/f38AAOhTAgAAAAAAAAAAAAAAAADRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AAAAAAAAAABkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAATAAAAABMAAAAACQwAAAAAAAwAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAADwAAAAQPAAAAAAkQAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAABEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAGhoaAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFwAAAAAXAAAAAAkUAAAAAAAUAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAAAAAAAAAAAAABUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRlN1Y2Nlc3MASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGVmaW5lZCBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAE93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBNdWx0aWhvcCBhdHRlbXB0ZWQAUmVxdWlyZWQga2V5IG5vdCBhdmFpbGFibGUAS2V5IGhhcyBleHBpcmVkAEtleSBoYXMgYmVlbiByZXZva2VkAEtleSB3YXMgcmVqZWN0ZWQgYnkgc2VydmljZQAAAAAAAACgAk4A6wGnBX4FIAF1BhgDhgT6ALkDLAP9BbcBigF6A7wEHgDMBqIAPQNJA9cBAAQIAJMGCAGPAgYCKgZfArcC+gJYA9kE/QbKAr0F4QXNBdwCEAZAAngAfQJnA2EE7ADlAwoF1ADMAz4GTwJ2AZgDrwQAAEQAEAKuAK4DYAD6AXcEIQXrBCsAYAFBAZIAqQajAW4CTgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATBAAAAAAAAAAAKgIAAAAAAAAAAAAAAAAAAAAAAAAAACcEOQRIBAAAAAAAAAAAAAAAAAAAAACSBAAAAAAAAAAAAAAAAAAAAAAAADgFUgVgBVMGAADKAQAAAAAAAAAAuwbbBusGEAcrBzsHUAcYSQIAkEcCAGxJAgBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAAAYSQIAwEcCAIRHAgBOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAAAAAAAAAEgCAPIAAADzAAAA9AAAAPUAAAD2AAAAGEkCAAxIAgCERwIATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAOxHAgA8SAIAdgAAAOxHAgBISAIAYgAAAOxHAgBUSAIAYwAAAOxHAgBgSAIAaAAAAOxHAgBsSAIAYQAAAOxHAgB4SAIAcwAAAOxHAgCESAIAdAAAAOxHAgCQSAIAaQAAAOxHAgCcSAIAagAAAOxHAgCoSAIAbAAAAOxHAgC0SAIAbQAAAOxHAgDASAIAeAAAAOxHAgDMSAIAeQAAAOxHAgDYSAIAZgAAAOxHAgDkSAIAZAAAAAAAAAC0RwIA8gAAAPcAAAD0AAAA9QAAAPgAAAD5AAAA+gAAAPsAAAAAAAAAOEkCAPIAAAD8AAAA9AAAAPUAAAD4AAAA/QAAAP4AAAD/AAAAGEkCAERJAgC0RwIATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAAPBIAgB0SQIAU3Q5dHlwZV9pbmZvAABBkJMJC4gXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAA0AAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIgAAACMAAAABAAAAGgAAABsAAAABAAAALgAAABIAAAABAAAAMgAAADIAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALgAAAC4AAAAAAAAAHAAAAB0AAAABAQAAHAAAAB0AAAABAQAAAAAAAAAAAAAAAAAAMAAAADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACEAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgAAADIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgAAADIAAAABAAAAFgAAABcAAAABAQAAFgAAABcAAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALgAAABIAAAABAAAAHAAAAB0AAAABAQAAHAAAAB0AAAABAQAADAAAAA0AAAABAQAAHAAAAB0AAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAB8AAAABAAAAHgAAAB8AAAABAAAAJAAAACUAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAkAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAkAAAABAAAAAAAAAAAAAAAAAAAABAAAAAgAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAB8AAAABAAAAHgAAAB8AAAABAAAAHAAAAB0AAAABAQAAJAAAACUAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAJgAAACcAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACEAAAABAAAALgAAABIAAAABAAAAGAAAABkAAAABAAAALgAAABIAAAABAAAAJgAAACcAAAABAAAALgAAABIAAAABAAAAFAAAABQAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAALAAAACwAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALgAAAC4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAABgAAAAAAAAAGAAAABgAAAAAAAAAKgAAACoAAAAAAAAAKgAAADQAAAAAAAAALgAAAC4AAAAAAAAAKAAAACgAAAAAAAAALgAAAC4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAFAAAAAAAAAAAAAADqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrAAAA7AAAAGRWAgAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAA//////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADoUwIAAAAAAAUAAAAAAAAAAAAAAO0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOsAAADuAAAAeFYCAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAD/////CgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIBUAgBwXAIAAJQBD3RhcmdldF9mZWF0dXJlcwgrC2J1bGstbWVtb3J5Kw9idWxrLW1lbW9yeS1vcHQrFmNhbGwtaW5kaXJlY3Qtb3ZlcmxvbmcrCm11bHRpdmFsdWUrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsPcmVmZXJlbmNlLXR5cGVzKwhzaWduLWV4dA==');
}

function getBinarySync(file) {
  if (ArrayBuffer.isView(file)) {
    return file;
  }
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  // Throwing a plain string here, even though it not normally adviables since
  // this gets turning into an `abort` in instantiateArrayBuffer.
  throw 'both async and sync fetching of the wasm failed';
}

async function getWasmBinary(binaryFile) {

  // Otherwise, getBinarySync should be able to get it synchronously
  return getBinarySync(binaryFile);
}

async function instantiateArrayBuffer(binaryFile, imports) {
  try {
    var binary = await getWasmBinary(binaryFile);
    var instance = await WebAssembly.instantiate(binary, imports);
    return instance;
  } catch (reason) {
    err(`failed to asynchronously prepare wasm: ${reason}`);

    // Warn on some common problems.
    if (isFileURI(binaryFile)) {
      err(`warning: Loading from a file URI (${binaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
    }
    abort(reason);
  }
}

async function instantiateAsync(binary, binaryFile, imports) {
  return instantiateArrayBuffer(binaryFile, imports);
}

function getWasmImports() {
  // prepare imports
  return {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports,
  }
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
async function createWasm() {
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;

    

    assignWasmExports(wasmExports);

    updateMemoryViews();

    return wasmExports;
  }

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above PTHREADS-enabled path.
    return receiveInstance(result['instance']);
  }

  var info = getWasmImports();

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {
    return new Promise((resolve, reject) => {
      try {
        Module['instantiateWasm'](info, (inst, mod) => {
          resolve(receiveInstance(inst, mod));
        });
      } catch(e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        reject(e);
      }
    });
  }

  wasmBinaryFile ??= findWasmBinary();
  var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
  var exports$1 = receiveInstantiationResult(result);
  return exports$1;
}

// end include: preamble.js

// Begin JS library code


  class ExitStatus {
      name = 'ExitStatus';
      constructor(status) {
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    }

  var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.push(cb);

  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.push(cb);

  /** @noinline */
  var base64Decode = (b64) => {
      {
        var buf = Buffer.from(b64, 'base64');
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
      }
    };

  var noExitRuntime = true;

  var ptrToString = (ptr) => {
      assert(typeof ptr === 'number', `ptrToString expects a number, got ${typeof ptr}`);
      // Convert to 32-bit unsigned value
      ptr >>>= 0;
      return '0x' + ptr.toString(16).padStart(8, '0');
    };

  var warnOnce = (text) => {
      warnOnce.shown ||= {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        text = 'warning: ' + text;
        err(text);
      }
    };

  var UTF8Decoder = globalThis.TextDecoder && new TextDecoder();
  
  var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {
      var maxIdx = idx + maxBytesToRead;
      if (ignoreNul) return maxIdx;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.
      // As a tiny code save trick, compare idx against maxIdx using a negation,
      // so that maxBytesToRead=undefined/NaN means Infinity.
      while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;
      return idx;
    };
  
  
    /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number=} idx
     * @param {number=} maxBytesToRead
     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.
     * @return {string}
     */
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {
  
      var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);
  
      // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
        }
  
        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
      return str;
    };
  
    /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index.
     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.
     * @return {string}
     */
  var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : '';
    };
  var ___assert_fail = (condition, filename, line, func) =>
      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);

  var __abort_js = () =>
      abort('native code called abort()');

  var AsciiToString = (ptr) => {
      var str = '';
      while (1) {
        var ch = HEAPU8[ptr++];
        if (!ch) return str;
        str += String.fromCharCode(ch);
      }
    };
  
  var awaitingDependencies = {
  };
  
  var registeredTypes = {
  };
  
  var typeDependencies = {
  };
  
  var BindingError =  class BindingError extends Error { constructor(message) { super(message); this.name = 'BindingError'; }};
  var throwBindingError = (message) => { throw new BindingError(message); };
  /** @param {Object=} options */
  function sharedRegisterType(rawType, registeredInstance, options = {}) {
      var name = registeredInstance.name;
      if (!rawType) {
        throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError(`Cannot register type '${name}' twice`);
        }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
  /** @param {Object=} options */
  function registerType(rawType, registeredInstance, options = {}) {
      return sharedRegisterType(rawType, registeredInstance, options);
    }
  
  var integerReadValueFromPointer = (name, width, signed) => {
      // integers are quite common, so generate very specialized functions
      switch (width) {
        case 1: return signed ?
          (pointer) => HEAP8[pointer] :
          (pointer) => HEAPU8[pointer];
        case 2: return signed ?
          (pointer) => HEAP16[((pointer)>>1)] :
          (pointer) => HEAPU16[((pointer)>>1)]
        case 4: return signed ?
          (pointer) => HEAP32[((pointer)>>2)] :
          (pointer) => HEAPU32[((pointer)>>2)]
        case 8: return signed ?
          (pointer) => HEAP64[((pointer)>>3)] :
          (pointer) => HEAPU64[((pointer)>>3)]
        default:
          throw new TypeError(`invalid integer width (${width}): ${name}`);
      }
    };
  
  var embindRepr = (v) => {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    };
  
  var assertIntegerRange = (typeName, value, minRange, maxRange) => {
      if (value < minRange || value > maxRange) {
        throw new TypeError(`Passing a number "${embindRepr(value)}" from JS side to C/C++ side to an argument of type "${typeName}", which is outside the valid range [${minRange}, ${maxRange}]!`);
      }
    };
  /** @suppress {globalThis} */
  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {
      name = AsciiToString(name);
  
      const isUnsignedType = minRange === 0n;
  
      let fromWireType = (value) => value;
      if (isUnsignedType) {
        // uint64 get converted to int64 in ABI, fix them up like we do for 32-bit integers.
        const bitSize = size * 8;
        fromWireType = (value) => {
          return BigInt.asUintN(bitSize, value);
        };
        maxRange = fromWireType(maxRange);
      }
  
      registerType(primitiveType, {
        name,
        fromWireType: fromWireType,
        toWireType: (destructors, value) => {
          if (typeof value == "number") {
            value = BigInt(value);
          }
          else if (typeof value != "bigint") {
            throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${this.name}`);
          }
          assertIntegerRange(name, value, minRange, maxRange);
          return value;
        },
        readValueFromPointer: integerReadValueFromPointer(name, size, !isUnsignedType),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  /** @suppress {globalThis} */
  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: function(wt) {
          // ambiguous emscripten ABI: sometimes return values are
          // true or false, and sometimes integers (0 or 1)
          return !!wt;
        },
        toWireType: function(destructors, o) {
          return o ? trueValue : falseValue;
        },
        readValueFromPointer: function(pointer) {
          return this.fromWireType(HEAPU8[pointer]);
        },
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  var emval_freelist = [];
  
  var emval_handles = [0,1,,1,null,1,true,1,false,1];
  var __emval_decref = (handle) => {
      if (handle > 9 && 0 === --emval_handles[handle + 1]) {
        assert(emval_handles[handle] !== undefined, `Decref for unallocated handle.`);
        emval_handles[handle] = undefined;
        emval_freelist.push(handle);
      }
    };
  
  
  
  var Emval = {
  toValue:(handle) => {
        if (!handle) {
            throwBindingError(`Cannot use deleted val. handle = ${handle}`);
        }
        // handle 2 is supposed to be `undefined`.
        assert(handle === 2 || emval_handles[handle] !== undefined && handle % 2 === 0, `invalid handle: ${handle}`);
        return emval_handles[handle];
      },
  toHandle:(value) => {
        switch (value) {
          case undefined: return 2;
          case null: return 4;
          case true: return 6;
          case false: return 8;
          default:{
            const handle = emval_freelist.pop() || emval_handles.length;
            emval_handles[handle] = value;
            emval_handles[handle + 1] = 1;
            return handle;
          }
        }
      },
  };
  
  /** @suppress {globalThis} */
  function readPointer(pointer) {
      return this.fromWireType(HEAPU32[((pointer)>>2)]);
    }
  var EmValType = {
      name: 'emscripten::val',
      fromWireType: (handle) => {
        var rv = Emval.toValue(handle);
        __emval_decref(handle);
        return rv;
      },
      toWireType: (destructors, value) => Emval.toHandle(value),
      readValueFromPointer: readPointer,
      destructorFunction: null, // This type does not need a destructor
  
      // TODO: do we need a deleteObject here?  write a test where
      // emval is passed into JS via an interface
    };
  var __embind_register_emval = (rawType) => registerType(rawType, EmValType);

  var floatReadValueFromPointer = (name, width) => {
      switch (width) {
        case 4: return function(pointer) {
          return this.fromWireType(HEAPF32[((pointer)>>2)]);
        };
        case 8: return function(pointer) {
          return this.fromWireType(HEAPF64[((pointer)>>3)]);
        };
        default:
          throw new TypeError(`invalid float width (${width}): ${name}`);
      }
    };
  
  
  
  var __embind_register_float = (rawType, name, size) => {
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: (value) => value,
        toWireType: (destructors, value) => {
          if (typeof value != "number" && typeof value != "boolean") {
            throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);
          }
          // The VM will perform JS to Wasm value conversion, according to the spec:
          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
          return value;
        },
        readValueFromPointer: floatReadValueFromPointer(name, size),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  var createNamedFunction = (name, func) => Object.defineProperty(func, 'name', { value: name });
  
  var runDestructors = (destructors) => {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    };
  
  
  function usesDestructorStack(argTypes) {
      // Skip return value at index 0 - it's not deleted here.
      for (var i = 1; i < argTypes.length; ++i) {
        // The type does not define a destructor function - must use dynamic stack
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
          return true;
        }
      }
      return false;
    }
  
  
  function checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError) {
      if (numArgs < minArgs || numArgs > maxArgs) {
        var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;
        throwBindingError(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);
      }
    }
  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
      var needsDestructorStack = usesDestructorStack(argTypes);
      var argCount = argTypes.length - 2;
      var argsList = [];
      var argsListWired = ['fn'];
      for (var i = 0; i < argCount; ++i) {
        argsList.push(`arg${i}`);
        argsListWired.push(`arg${i}Wired`);
      }
      argsList = argsList.join(',');
      argsListWired = argsListWired.join(',');
  
      var invokerFnBody = `return function (${argsList}) {\n`;
  
      invokerFnBody += "checkArgCount(arguments.length, minArgs, maxArgs, humanName, throwBindingError);\n";
  
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
  
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "fromRetWire", "toClassParamWire"];
  
      for (var i = 0; i < argCount; ++i) {
        var argName = `toArg${i}Wire`;
        invokerFnBody += `var arg${i}Wired = ${argName}(${dtorStack}, arg${i});\n`;
        args1.push(argName);
      }
  
      invokerFnBody += (returns || isAsync ? "var rv = ":"") + `invoker(${argsListWired});\n`;
  
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = 2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
          var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += `${paramName}_dtor(${paramName});\n`;
            args1.push(`${paramName}_dtor`);
          }
        }
      }
  
      if (returns) {
        invokerFnBody += "var ret = fromRetWire(rv);\n" +
                         "return ret;\n";
      }
  
      invokerFnBody += "}\n";
  
      args1.push('checkArgCount', 'minArgs', 'maxArgs');
      invokerFnBody = `if (arguments.length !== ${args1.length}){ throw new Error(humanName + "Expected ${args1.length} closure arguments " + arguments.length + " given."); }\n${invokerFnBody}`;
      return new Function(args1, invokerFnBody);
    }
  
  function getRequiredArgCount(argTypes) {
      var requiredArgCount = argTypes.length - 2;
      for (var i = argTypes.length - 1; i >= 2; --i) {
        if (!argTypes[i].optional) {
          break;
        }
        requiredArgCount--;
      }
      return requiredArgCount;
    }
  
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.
      var argCount = argTypes.length;
  
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
  
      assert(!isAsync, 'Async bindings are only supported with JSPI.');
      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
  
      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
      // TODO: This omits argument count check - enable only at -O3 or similar.
      //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
      //       return FUNCTION_TABLE[fn];
      //    }
  
      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = usesDestructorStack(argTypes);
  
      var returns = !argTypes[0].isVoid;
  
      var expectedArgCount = argCount - 2;
      var minArgs = getRequiredArgCount(argTypes);
      // Builld the arguments that will be passed into the closure around the invoker
      // function.
      var retType = argTypes[0];
      var instType = argTypes[1];
      var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, retType.fromWireType.bind(retType), instType?.toWireType.bind(instType)];
      for (var i = 2; i < argCount; ++i) {
        var argType = argTypes[i];
        closureArgs.push(argType.toWireType.bind(argType));
      }
      if (!needsDestructorStack) {
        // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
        for (var i = 2; i < argTypes.length; ++i) {
          if (argTypes[i].destructorFunction !== null) {
            closureArgs.push(argTypes[i].destructorFunction);
          }
        }
      }
      closureArgs.push(checkArgCount, minArgs, expectedArgCount);
  
      let invokerFactory = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);
      var invokerFn = invokerFactory(...closureArgs);
      return createNamedFunction(humanName, invokerFn);
    }
  
  var ensureOverloadTable = (proto, methodName, humanName) => {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
        proto[methodName] = function(...args) {
          // TODO This check can be removed in -O3 level "unsafe" optimizations.
          if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
          }
          return proto[methodName].overloadTable[args.length].apply(this, args);
        };
        // Move the previous function into the overload table.
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    };
  
  /** @param {number=} numArguments */
  var exposePublicSymbol = (name, value, numArguments) => {
      if (Module.hasOwnProperty(name)) {
        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
          throwBindingError(`Cannot register public name '${name}' twice`);
        }
  
        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
        // that routes between the two.
        ensureOverloadTable(Module, name, name);
        if (Module[name].overloadTable.hasOwnProperty(numArguments)) {
          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
        }
        // Add the new function into the overload table.
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };
  
  var heap32VectorToArray = (count, firstElement) => {
      var array = [];
      for (var i = 0; i < count; i++) {
        // TODO(https://github.com/emscripten-core/emscripten/issues/17310):
        // Find a way to hoist the `>> 2` or `>> 3` out of this loop.
        array.push(HEAPU32[(((firstElement)+(i * 4))>>2)]);
      }
      return array;
    };
  
  
  var InternalError =  class InternalError extends Error { constructor(message) { super(message); this.name = 'InternalError'; }};
  var throwInternalError = (message) => { throw new InternalError(message); };
  /** @param {number=} numArguments */
  var replacePublicSymbol = (name, value, numArguments) => {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError('Replacing nonexistent public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };
  
  
  
  var wasmTableMirror = [];
  
  
  var getWasmTableEntry = (funcPtr) => {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        /** @suppress {checkTypes} */
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      /** @suppress {checkTypes} */
      assert(wasmTable.get(funcPtr) == func, 'JavaScript-side Wasm function table mirror is out of date!');
      return func;
    };
  var embind__requireFunction = (signature, rawFunction, isAsync = false) => {
      assert(!isAsync, 'Async bindings are only supported with JSPI.');
  
      signature = AsciiToString(signature);
  
      function makeDynCaller() {
        var rtn = getWasmTableEntry(rawFunction);
        return rtn;
      }
  
      var fp = makeDynCaller();
      if (typeof fp != 'function') {
          throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
      }
      return fp;
    };
  
  
  
  class UnboundTypeError extends Error {}
  
  
  
  var getTypeName = (type) => {
      var ptr = ___getTypeName(type);
      var rv = AsciiToString(ptr);
      _free(ptr);
      return rv;
    };
  var throwUnboundTypeError = (message, types) => {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
  
      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));
    };
  
  
  
  
  var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
      myTypes.forEach((type) => typeDependencies[type] = dependentTypes);
  
      function onComplete(typeConverters) {
        var myTypeConverters = getTypeConverters(typeConverters);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError('Mismatched type converter count');
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    };
  
  var getFunctionName = (signature) => {
      signature = signature.trim();
      const argsIndex = signature.indexOf("(");
      if (argsIndex === -1) return signature;
      assert(signature.endsWith(")"), "Parentheses for argument names should match.");
      return signature.slice(0, argsIndex);
    };
  var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) => {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = AsciiToString(name);
      name = getFunctionName(name);
  
      rawInvoker = embind__requireFunction(signature, rawInvoker, isAsync);
  
      exposePublicSymbol(name, function() {
        throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
      }, argCount - 1);
  
      whenDependentTypesAreResolved([], argTypes, (argTypes) => {
        var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn, isAsync), argCount - 1);
        return [];
      });
    };

  
  
  
  
  /** @suppress {globalThis} */
  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {
      name = AsciiToString(name);
  
      const isUnsignedType = minRange === 0;
  
      let fromWireType = (value) => value;
      if (isUnsignedType) {
        var bitshift = 32 - 8*size;
        fromWireType = (value) => (value << bitshift) >>> bitshift;
        maxRange = fromWireType(maxRange);
      }
  
      registerType(primitiveType, {
        name,
        fromWireType: fromWireType,
        toWireType: (destructors, value) => {
          if (typeof value != "number" && typeof value != "boolean") {
            throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${name}`);
          }
          assertIntegerRange(name, value, minRange, maxRange);
          // The VM will perform JS to Wasm value conversion, according to the spec:
          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
          return value;
        },
        readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {
      var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
        BigInt64Array,
        BigUint64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
        var size = HEAPU32[((handle)>>2)];
        var data = HEAPU32[(((handle)+(4))>>2)];
        return new TA(HEAP8.buffer, data, size);
      }
  
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: decodeMemoryView,
        readValueFromPointer: decodeMemoryView,
      }, {
        ignoreDuplicateRegistrations: true,
      });
    };

  
  
  
  
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);
      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
      // undefined and false each don't write out any bytes.
      if (!(maxBytesToWrite > 0))
        return 0;
  
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
      for (var i = 0; i < str.length; ++i) {
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
        // and https://www.ietf.org/rfc/rfc2279.txt
        // and https://tools.ietf.org/html/rfc3629
        var u = str.codePointAt(i);
        if (u <= 0x7F) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7FF) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xC0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xFFFF) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xE0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
          heap[outIdx++] = 0xF0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
          // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
          // We need to manually skip over the second code unit for correct iteration.
          i++;
        }
      }
      // Null-terminate the pointer to the buffer.
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
  
  var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var c = str.charCodeAt(i); // possibly a lead surrogate
        if (c <= 0x7F) {
          len++;
        } else if (c <= 0x7FF) {
          len += 2;
        } else if (c >= 0xD800 && c <= 0xDFFF) {
          len += 4; ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
  
  
  
  var __embind_register_std_string = (rawType, name) => {
      name = AsciiToString(name);
  
      registerType(rawType, {
        name,
        // For some method names we use string keys here since they are part of
        // the public/external API and/or used by the runtime-generated code.
        fromWireType(value) {
          var length = HEAPU32[((value)>>2)];
          var payload = value + 4;
  
          var str;
          {
            str = UTF8ToString(payload, length, true);
          }
  
          _free(value);
  
          return str;
        },
        toWireType(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
  
          var length;
          var valueIsOfTypeString = (typeof value == 'string');
  
          // We accept `string` or array views with single byte elements
          if (!(valueIsOfTypeString || (ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1))) {
            throwBindingError('Cannot pass non-string to std::string');
          }
          if (valueIsOfTypeString) {
            length = lengthBytesUTF8(value);
          } else {
            length = value.length;
          }
  
          // assumes POINTER_SIZE alignment
          var base = _malloc(4 + length + 1);
          var ptr = base + 4;
          HEAPU32[((base)>>2)] = length;
          if (valueIsOfTypeString) {
            {
              stringToUTF8(value, ptr, length + 1);
            }
          } else {
            HEAPU8.set(value, ptr);
          }
  
          if (destructors !== null) {
            destructors.push(_free, base);
          }
          return base;
        },
        readValueFromPointer: readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        },
      });
    };

  
  
  
  var UTF16Decoder = globalThis.TextDecoder ? new TextDecoder('utf-16le') : undefined;  
  var UTF16ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
      var idx = ((ptr)>>1);
      var endIdx = findStringEnd(HEAPU16, idx, maxBytesToRead / 2, ignoreNul);
  
      // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.
      if (endIdx - idx > 16 && UTF16Decoder)
        return UTF16Decoder.decode(HEAPU16.subarray(idx, endIdx));
  
      // Fallback: decode without UTF16Decoder
      var str = '';
  
      // If maxBytesToRead is not passed explicitly, it will be undefined, and the
      // for-loop's condition will always evaluate to true. The loop is then
      // terminated on the first null char.
      for (var i = idx; i < endIdx; ++i) {
        var codeUnit = HEAPU16[i];
        // fromCharCode constructs a character from a UTF-16 code unit, so we can
        // pass the UTF16 string right through.
        str += String.fromCharCode(codeUnit);
      }
  
      return str;
    };
  
  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      maxBytesToWrite ??= 0x7FFFFFFF;
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2; // Null terminator.
      var startPtr = outPtr;
      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
        HEAP16[((outPtr)>>1)] = codeUnit;
        outPtr += 2;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP16[((outPtr)>>1)] = 0;
      return outPtr - startPtr;
    };
  
  var lengthBytesUTF16 = (str) => str.length*2;
  
  var UTF32ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
      var str = '';
      var startIdx = ((ptr)>>2);
      // If maxBytesToRead is not passed explicitly, it will be undefined, and this
      // will always evaluate to true. This saves on code size.
      for (var i = 0; !(i >= maxBytesToRead / 4); i++) {
        var utf32 = HEAPU32[startIdx + i];
        if (!utf32 && !ignoreNul) break;
        str += String.fromCodePoint(utf32);
      }
      return str;
    };
  
  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      maxBytesToWrite ??= 0x7FFFFFFF;
      if (maxBytesToWrite < 4) return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        var codePoint = str.codePointAt(i);
        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
        // We need to manually skip over the second code unit for correct iteration.
        if (codePoint > 0xFFFF) {
          i++;
        }
        HEAP32[((outPtr)>>2)] = codePoint;
        outPtr += 4;
        if (outPtr + 4 > endPtr) break;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP32[((outPtr)>>2)] = 0;
      return outPtr - startPtr;
    };
  
  var lengthBytesUTF32 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var codePoint = str.codePointAt(i);
        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
        // We need to manually skip over the second code unit for correct iteration.
        if (codePoint > 0xFFFF) {
          i++;
        }
        len += 4;
      }
  
      return len;
    };
  var __embind_register_std_wstring = (rawType, charSize, name) => {
      name = AsciiToString(name);
      var decodeString, encodeString, lengthBytesUTF;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
      } else {
        assert(charSize === 4, 'only 2-byte and 4-byte strings are currently supported');
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
      }
      registerType(rawType, {
        name,
        fromWireType: (value) => {
          // Code mostly taken from _embind_register_std_string fromWireType
          var length = HEAPU32[((value)>>2)];
          var str = decodeString(value + 4, length * charSize, true);
  
          _free(value);
  
          return str;
        },
        toWireType: (destructors, value) => {
          if (!(typeof value == 'string')) {
            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
          }
  
          // assumes POINTER_SIZE alignment
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[((ptr)>>2)] = length / charSize;
  
          encodeString(value, ptr + 4, length + charSize);
  
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        },
        readValueFromPointer: readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        }
      });
    };

  
  var __embind_register_void = (rawType, name) => {
      name = AsciiToString(name);
      registerType(rawType, {
        isVoid: true, // void return values can be optimized out sometimes
        name,
        fromWireType: () => undefined,
        // TODO: assert if anything else is given?
        toWireType: (destructors, o) => undefined,
      });
    };

  var emval_methodCallers = [];
  var emval_addMethodCaller = (caller) => {
      var id = emval_methodCallers.length;
      emval_methodCallers.push(caller);
      return id;
    };
  
  
  
  var requireRegisteredType = (rawType, humanName) => {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
        throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);
      }
      return impl;
    };
  var emval_lookupTypes = (argCount, argTypes) => {
      var a = new Array(argCount);
      for (var i = 0; i < argCount; ++i) {
        a[i] = requireRegisteredType(HEAPU32[(((argTypes)+(i*4))>>2)],
                                     `parameter ${i}`);
      }
      return a;
    };
  
  
  var emval_returnValue = (toReturnWire, destructorsRef, handle) => {
      var destructors = [];
      var result = toReturnWire(destructors, handle);
      if (destructors.length) {
        // void, primitives and any other types w/o destructors don't need to allocate a handle
        HEAPU32[((destructorsRef)>>2)] = Emval.toHandle(destructors);
      }
      return result;
    };
  
  
  var emval_symbols = {
  };
  
  var getStringOrSymbol = (address) => {
      var symbol = emval_symbols[address];
      if (symbol === undefined) {
        return AsciiToString(address);
      }
      return symbol;
    };
  var __emval_create_invoker = (argCount, argTypesPtr, kind) => {
      var GenericWireTypeSize = 8;
  
      var [retType, ...argTypes] = emval_lookupTypes(argCount, argTypesPtr);
      var toReturnWire = retType.toWireType.bind(retType);
      var argFromPtr = argTypes.map(type => type.readValueFromPointer.bind(type));
      argCount--; // remove the extracted return type
  
      var captures = {'toValue': Emval.toValue};
      var args = argFromPtr.map((argFromPtr, i) => {
        var captureName = `argFromPtr${i}`;
        captures[captureName] = argFromPtr;
        return `${captureName}(args${i ? '+' + i * GenericWireTypeSize : ''})`;
      });
      var functionBody;
      switch (kind){
        case 0:
          functionBody = 'toValue(handle)';
          break;
        case 2:
          functionBody = 'new (toValue(handle))';
          break;
        case 3:
          functionBody = '';
          break;
        case 1:
          captures['getStringOrSymbol'] = getStringOrSymbol;
          functionBody = 'toValue(handle)[getStringOrSymbol(methodName)]';
          break;
      }
      functionBody += `(${args})`;
      if (!retType.isVoid) {
        captures['toReturnWire'] = toReturnWire;
        captures['emval_returnValue'] = emval_returnValue;
        functionBody = `return emval_returnValue(toReturnWire, destructorsRef, ${functionBody})`;
      }
      functionBody = `return function (handle, methodName, destructorsRef, args) {
  ${functionBody}
  }`;
  
      var invokerFunction = new Function(Object.keys(captures), functionBody)(...Object.values(captures));
      var functionName = `methodCaller<(${argTypes.map(t => t.name)}) => ${retType.name}>`;
      return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
    };


  
  var __emval_get_global = (name) => {
      if (!name) {
        return Emval.toHandle(globalThis);
      }
      name = getStringOrSymbol(name);
      return Emval.toHandle(globalThis[name]);
    };

  var __emval_get_property = (handle, key) => {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      return Emval.toHandle(handle[key]);
    };

  var __emval_incref = (handle) => {
      if (handle > 9) {
        emval_handles[handle + 1] += 1;
      }
    };

  
  
  var __emval_invoke = (caller, handle, methodName, destructorsRef, args) => {
      return emval_methodCallers[caller](handle, methodName, destructorsRef, args);
    };

  var __emval_new_array = () => Emval.toHandle([]);

  
  var __emval_new_cstring = (v) => Emval.toHandle(getStringOrSymbol(v));

  var __emval_new_object = () => Emval.toHandle({});

  
  
  var __emval_run_destructors = (handle) => {
      var destructors = Emval.toValue(handle);
      runDestructors(destructors);
      __emval_decref(handle);
    };

  var __emval_set_property = (handle, key, value) => {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      value = Emval.toValue(value);
      handle[key] = value;
    };

  var __emval_typeof = (handle) => {
      handle = Emval.toValue(handle);
      return Emval.toHandle(typeof handle);
    };
  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
  
  
      return -52;
  }

  function __munmap_js(addr, len, prot, flags, fd, offset) {
  }

  var getHeapMax = () =>
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648;
  
  var alignMemory = (size, alignment) => {
      assert(alignment, "alignment argument is required");
      return Math.ceil(size / alignment) * alignment;
    };
  
  var growMemory = (size) => {
      var oldHeapSize = wasmMemory.buffer.byteLength;
      var pages = ((size - oldHeapSize + 65535) / 65536) | 0;
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
        updateMemoryViews();
        return 1 /*success*/;
      } catch(e) {
        err(`growMemory: Attempted to grow heap from ${oldHeapSize} bytes to ${size} bytes, but got error: ${e}`);
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    };
  var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      requestedSize >>>= 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.
      assert(requestedSize > oldSize);
  
      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
        return false;
      }
  
      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = growMemory(newSize);
        if (replacement) {
  
          return true;
        }
      }
      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
      return false;
    };

  
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
      if (!keepRuntimeAlive()) {
        Module['onExit']?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    };
  
  
  /** @suppress {duplicate } */
  /** @param {boolean|number=} implicit */
  var exitJS = (status, implicit) => {
  
      checkUnflushedContent();
  
      // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
      if (keepRuntimeAlive() && !implicit) {
        var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;
        readyPromiseReject?.(msg);
        err(msg);
      }
  
      _proc_exit(status);
    };
  var _exit = exitJS;

  var _fd_close = (fd) => {
      abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');
    };

  function _fd_seek(fd, offset, whence, newOffset) {
  
  
      return 70;
  }

  var printCharBuffers = [null,[],[]];
  
  var printChar = (stream, curr) => {
      var buffer = printCharBuffers[stream];
      assert(buffer);
      if (curr === 0 || curr === 10) {
        (stream === 1 ? out : err)(UTF8ArrayToString(buffer));
        buffer.length = 0;
      } else {
        buffer.push(curr);
      }
    };
  
  var flush_NO_FILESYSTEM = () => {
      // flush anything remaining in the buffers during shutdown
      _fflush(0);
      if (printCharBuffers[1].length) printChar(1, 10);
      if (printCharBuffers[2].length) printChar(2, 10);
    };
  
  
  var _fd_write = (fd, iov, iovcnt, pnum) => {
      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
      var num = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, HEAPU8[ptr+j]);
        }
        num += len;
      }
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    };

    // Precreate a reverse lookup table from chars
    // "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" back to
    // bytes to make decoding fast.
    for (var base64ReverseLookup = new Uint8Array(123/*'z'+1*/), i = 25; i >= 0; --i) {
      base64ReverseLookup[48+i] = 52+i; // '0-9'
      base64ReverseLookup[65+i] = i; // 'A-Z'
      base64ReverseLookup[97+i] = 26+i; // 'a-z'
    }
    base64ReverseLookup[43] = 62; // '+'
    base64ReverseLookup[47] = 63; // '/'
assert(emval_handles.length === 5 * 2);
// End JS library code

// include: postlibrary.js
// This file is included after the automatically-generated JS library code
// but before the wasm module is created.

{

  // Begin ATMODULES hooks
  if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];
if (Module['print']) out = Module['print'];
if (Module['printErr']) err = Module['printErr'];
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];

Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;

  // End ATMODULES hooks

  checkIncomingModuleAPI();

  if (Module['arguments']) Module['arguments'];
  if (Module['thisProgram']) Module['thisProgram'];

  // Assertions on removed incoming Module JS APIs.
  assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['read'] == 'undefined', 'Module.read option was removed');
  assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
  assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
  assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');
  assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
  assert(typeof Module['ENVIRONMENT'] == 'undefined', 'Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
  assert(typeof Module['STACK_SIZE'] == 'undefined', 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');
  // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
  assert(typeof Module['wasmMemory'] == 'undefined', 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');
  assert(typeof Module['INITIAL_MEMORY'] == 'undefined', 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');

  if (Module['preInit']) {
    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
    while (Module['preInit'].length > 0) {
      Module['preInit'].shift()();
    }
  }
  consumedModuleProp('preInit');
}

// Begin runtime exports
  var missingLibrarySymbols = [
  'writeI53ToI64',
  'writeI53ToI64Clamped',
  'writeI53ToI64Signaling',
  'writeI53ToU64Clamped',
  'writeI53ToU64Signaling',
  'readI53FromI64',
  'readI53FromU64',
  'convertI32PairToI53',
  'convertI32PairToI53Checked',
  'convertU32PairToI53',
  'stackAlloc',
  'getTempRet0',
  'setTempRet0',
  'zeroMemory',
  'withStackSave',
  'strError',
  'inetPton4',
  'inetNtop4',
  'inetPton6',
  'inetNtop6',
  'readSockaddr',
  'writeSockaddr',
  'readEmAsmArgs',
  'jstoi_q',
  'getExecutableName',
  'autoResumeAudioContext',
  'getDynCaller',
  'dynCall',
  'handleException',
  'runtimeKeepalivePush',
  'runtimeKeepalivePop',
  'callUserCallback',
  'maybeExit',
  'asyncLoad',
  'asmjsMangle',
  'mmapAlloc',
  'HandleAllocator',
  'getNativeTypeSize',
  'getUniqueRunDependency',
  'addRunDependency',
  'removeRunDependency',
  'addOnInit',
  'addOnPostCtor',
  'addOnPreMain',
  'addOnExit',
  'STACK_SIZE',
  'STACK_ALIGN',
  'POINTER_SIZE',
  'ASSERTIONS',
  'ccall',
  'cwrap',
  'convertJsFunctionToWasm',
  'getEmptyTableSlot',
  'updateTableMap',
  'getFunctionAddress',
  'addFunction',
  'removeFunction',
  'intArrayFromString',
  'intArrayToString',
  'stringToAscii',
  'stringToNewUTF8',
  'stringToUTF8OnStack',
  'writeArrayToMemory',
  'registerKeyEventCallback',
  'maybeCStringToJsString',
  'findEventTarget',
  'getBoundingClientRect',
  'fillMouseEventData',
  'registerMouseEventCallback',
  'registerWheelEventCallback',
  'registerUiEventCallback',
  'registerFocusEventCallback',
  'fillDeviceOrientationEventData',
  'registerDeviceOrientationEventCallback',
  'fillDeviceMotionEventData',
  'registerDeviceMotionEventCallback',
  'screenOrientation',
  'fillOrientationChangeEventData',
  'registerOrientationChangeEventCallback',
  'fillFullscreenChangeEventData',
  'registerFullscreenChangeEventCallback',
  'JSEvents_requestFullscreen',
  'JSEvents_resizeCanvasForFullscreen',
  'registerRestoreOldStyle',
  'hideEverythingExceptGivenElement',
  'restoreHiddenElements',
  'setLetterbox',
  'softFullscreenResizeWebGLRenderTarget',
  'doRequestFullscreen',
  'fillPointerlockChangeEventData',
  'registerPointerlockChangeEventCallback',
  'registerPointerlockErrorEventCallback',
  'requestPointerLock',
  'fillVisibilityChangeEventData',
  'registerVisibilityChangeEventCallback',
  'registerTouchEventCallback',
  'fillGamepadEventData',
  'registerGamepadEventCallback',
  'registerBeforeUnloadEventCallback',
  'fillBatteryEventData',
  'registerBatteryEventCallback',
  'setCanvasElementSize',
  'getCanvasElementSize',
  'jsStackTrace',
  'getCallstack',
  'convertPCtoSourceLocation',
  'getEnvStrings',
  'checkWasiClock',
  'wasiRightsToMuslOFlags',
  'wasiOFlagsToMuslOFlags',
  'initRandomFill',
  'randomFill',
  'safeSetTimeout',
  'setImmediateWrapped',
  'safeRequestAnimationFrame',
  'clearImmediateWrapped',
  'registerPostMainLoop',
  'registerPreMainLoop',
  'getPromise',
  'makePromise',
  'idsToPromises',
  'makePromiseCallback',
  'ExceptionInfo',
  'findMatchingCatch',
  'Browser_asyncPrepareDataCounter',
  'isLeapYear',
  'ydayFromDate',
  'arraySum',
  'addDays',
  'getSocketFromFD',
  'getSocketAddress',
  'FS_createPreloadedFile',
  'FS_preloadFile',
  'FS_modeStringToFlags',
  'FS_getMode',
  'FS_stdin_getChar',
  'FS_mkdirTree',
  '_setNetworkCallback',
  'heapObjectForWebGLType',
  'toTypedArrayIndex',
  'webgl_enable_ANGLE_instanced_arrays',
  'webgl_enable_OES_vertex_array_object',
  'webgl_enable_WEBGL_draw_buffers',
  'webgl_enable_WEBGL_multi_draw',
  'webgl_enable_EXT_polygon_offset_clamp',
  'webgl_enable_EXT_clip_control',
  'webgl_enable_WEBGL_polygon_mode',
  'emscriptenWebGLGet',
  'computeUnpackAlignedImageSize',
  'colorChannelsInGlTextureFormat',
  'emscriptenWebGLGetTexPixelData',
  'emscriptenWebGLGetUniform',
  'webglGetUniformLocation',
  'webglPrepareUniformLocationsBeforeFirstUse',
  'webglGetLeftBracePos',
  'emscriptenWebGLGetVertexAttrib',
  '__glGetActiveAttribOrUniform',
  'writeGLArray',
  'registerWebGlEventCallback',
  'runAndAbortIfError',
  'ALLOC_NORMAL',
  'ALLOC_STACK',
  'allocate',
  'writeStringToMemory',
  'writeAsciiToMemory',
  'demangle',
  'stackTrace',
  'getFunctionArgsName',
  'createJsInvokerSignature',
  'PureVirtualError',
  'getBasestPointer',
  'registerInheritedInstance',
  'unregisterInheritedInstance',
  'getInheritedInstance',
  'getInheritedInstanceCount',
  'getLiveInheritedInstances',
  'enumReadValueFromPointer',
  'genericPointerToWireType',
  'constNoSmartPtrRawPointerToWireType',
  'nonConstNoSmartPtrRawPointerToWireType',
  'init_RegisteredPointer',
  'RegisteredPointer',
  'RegisteredPointer_fromWireType',
  'runDestructor',
  'releaseClassHandle',
  'detachFinalizer',
  'attachFinalizer',
  'makeClassHandle',
  'init_ClassHandle',
  'ClassHandle',
  'throwInstanceAlreadyDeleted',
  'flushPendingDeletes',
  'setDelayFunction',
  'RegisteredClass',
  'shallowCopyInternalPointer',
  'downcastPointer',
  'upcastPointer',
  'validateThis',
  'char_0',
  'char_9',
  'makeLegalFunctionName',
  'count_emval_handles',
];
missingLibrarySymbols.forEach(missingLibrarySymbol);

  var unexportedSymbols = [
  'run',
  'out',
  'err',
  'callMain',
  'abort',
  'wasmMemory',
  'wasmExports',
  'HEAPF32',
  'HEAPF64',
  'HEAP8',
  'HEAPU8',
  'HEAP16',
  'HEAPU16',
  'HEAP32',
  'HEAPU32',
  'HEAP64',
  'HEAPU64',
  'writeStackCookie',
  'checkStackCookie',
  'INT53_MAX',
  'INT53_MIN',
  'bigintToI53Checked',
  'stackSave',
  'stackRestore',
  'createNamedFunction',
  'ptrToString',
  'exitJS',
  'getHeapMax',
  'growMemory',
  'ENV',
  'ERRNO_CODES',
  'DNS',
  'Protocols',
  'Sockets',
  'timers',
  'warnOnce',
  'readEmAsmArgsArray',
  'keepRuntimeAlive',
  'alignMemory',
  'wasmTable',
  'noExitRuntime',
  'addOnPreRun',
  'addOnPostRun',
  'freeTableIndexes',
  'functionsInTableMap',
  'setValue',
  'getValue',
  'PATH',
  'PATH_FS',
  'UTF8Decoder',
  'UTF8ArrayToString',
  'UTF8ToString',
  'stringToUTF8Array',
  'stringToUTF8',
  'lengthBytesUTF8',
  'AsciiToString',
  'UTF16Decoder',
  'UTF16ToString',
  'stringToUTF16',
  'lengthBytesUTF16',
  'UTF32ToString',
  'stringToUTF32',
  'lengthBytesUTF32',
  'JSEvents',
  'specialHTMLTargets',
  'findCanvasEventTarget',
  'currentFullscreenStrategy',
  'restoreOldWindowedStyle',
  'UNWIND_CACHE',
  'ExitStatus',
  'flush_NO_FILESYSTEM',
  'emSetImmediate',
  'emClearImmediate_deps',
  'emClearImmediate',
  'promiseMap',
  'uncaughtExceptionCount',
  'exceptionLast',
  'exceptionCaught',
  'Browser',
  'requestFullscreen',
  'requestFullScreen',
  'setCanvasSize',
  'getUserMedia',
  'createContext',
  'getPreloadedImageData__data',
  'wget',
  'MONTH_DAYS_REGULAR',
  'MONTH_DAYS_LEAP',
  'MONTH_DAYS_REGULAR_CUMULATIVE',
  'MONTH_DAYS_LEAP_CUMULATIVE',
  'base64Decode',
  'SYSCALLS',
  'preloadPlugins',
  'FS_stdin_getChar_buffer',
  'FS_unlink',
  'FS_createPath',
  'FS_createDevice',
  'FS_readFile',
  'FS',
  'FS_root',
  'FS_mounts',
  'FS_devices',
  'FS_streams',
  'FS_nextInode',
  'FS_nameTable',
  'FS_currentPath',
  'FS_initialized',
  'FS_ignorePermissions',
  'FS_filesystems',
  'FS_syncFSRequests',
  'FS_readFiles',
  'FS_lookupPath',
  'FS_getPath',
  'FS_hashName',
  'FS_hashAddNode',
  'FS_hashRemoveNode',
  'FS_lookupNode',
  'FS_createNode',
  'FS_destroyNode',
  'FS_isRoot',
  'FS_isMountpoint',
  'FS_isFile',
  'FS_isDir',
  'FS_isLink',
  'FS_isChrdev',
  'FS_isBlkdev',
  'FS_isFIFO',
  'FS_isSocket',
  'FS_flagsToPermissionString',
  'FS_nodePermissions',
  'FS_mayLookup',
  'FS_mayCreate',
  'FS_mayDelete',
  'FS_mayOpen',
  'FS_checkOpExists',
  'FS_nextfd',
  'FS_getStreamChecked',
  'FS_getStream',
  'FS_createStream',
  'FS_closeStream',
  'FS_dupStream',
  'FS_doSetAttr',
  'FS_chrdev_stream_ops',
  'FS_major',
  'FS_minor',
  'FS_makedev',
  'FS_registerDevice',
  'FS_getDevice',
  'FS_getMounts',
  'FS_syncfs',
  'FS_mount',
  'FS_unmount',
  'FS_lookup',
  'FS_mknod',
  'FS_statfs',
  'FS_statfsStream',
  'FS_statfsNode',
  'FS_create',
  'FS_mkdir',
  'FS_mkdev',
  'FS_symlink',
  'FS_rename',
  'FS_rmdir',
  'FS_readdir',
  'FS_readlink',
  'FS_stat',
  'FS_fstat',
  'FS_lstat',
  'FS_doChmod',
  'FS_chmod',
  'FS_lchmod',
  'FS_fchmod',
  'FS_doChown',
  'FS_chown',
  'FS_lchown',
  'FS_fchown',
  'FS_doTruncate',
  'FS_truncate',
  'FS_ftruncate',
  'FS_utime',
  'FS_open',
  'FS_close',
  'FS_isClosed',
  'FS_llseek',
  'FS_read',
  'FS_write',
  'FS_mmap',
  'FS_msync',
  'FS_ioctl',
  'FS_writeFile',
  'FS_cwd',
  'FS_chdir',
  'FS_createDefaultDirectories',
  'FS_createDefaultDevices',
  'FS_createSpecialDirectories',
  'FS_createStandardStreams',
  'FS_staticInit',
  'FS_init',
  'FS_quit',
  'FS_findObject',
  'FS_analyzePath',
  'FS_createFile',
  'FS_createDataFile',
  'FS_forceLoadFile',
  'FS_createLazyFile',
  'FS_absolutePath',
  'FS_createFolder',
  'FS_createLink',
  'FS_joinPath',
  'FS_mmapAlloc',
  'FS_standardizePath',
  'MEMFS',
  'TTY',
  'PIPEFS',
  'SOCKFS',
  'tempFixedLengthArray',
  'miniTempWebGLFloatBuffers',
  'miniTempWebGLIntBuffers',
  'GL',
  'AL',
  'GLUT',
  'EGL',
  'GLEW',
  'IDBStore',
  'SDL',
  'SDL_gfx',
  'allocateUTF8',
  'allocateUTF8OnStack',
  'print',
  'printErr',
  'jstoi_s',
  'InternalError',
  'BindingError',
  'throwInternalError',
  'throwBindingError',
  'registeredTypes',
  'awaitingDependencies',
  'typeDependencies',
  'tupleRegistrations',
  'structRegistrations',
  'sharedRegisterType',
  'whenDependentTypesAreResolved',
  'getTypeName',
  'getFunctionName',
  'heap32VectorToArray',
  'requireRegisteredType',
  'usesDestructorStack',
  'checkArgCount',
  'getRequiredArgCount',
  'createJsInvoker',
  'UnboundTypeError',
  'EmValType',
  'EmValOptionalType',
  'throwUnboundTypeError',
  'ensureOverloadTable',
  'exposePublicSymbol',
  'replacePublicSymbol',
  'embindRepr',
  'registeredInstances',
  'registeredPointers',
  'registerType',
  'integerReadValueFromPointer',
  'floatReadValueFromPointer',
  'assertIntegerRange',
  'readPointer',
  'runDestructors',
  'craftInvokerFunction',
  'embind__requireFunction',
  'finalizationRegistry',
  'detachFinalizer_deps',
  'deletionQueue',
  'delayFunction',
  'emval_freelist',
  'emval_handles',
  'emval_symbols',
  'getStringOrSymbol',
  'Emval',
  'emval_returnValue',
  'emval_lookupTypes',
  'emval_methodCallers',
  'emval_addMethodCaller',
];
unexportedSymbols.forEach(unexportedRuntimeSymbol);

  // End runtime exports
  // Begin JS library exports
  // End JS library exports

// end include: postlibrary.js

function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}

// Imports from the Wasm binary.
var _malloc = makeInvalidEarlyAccess('_malloc');
var _free = makeInvalidEarlyAccess('_free');
var ___getTypeName = makeInvalidEarlyAccess('___getTypeName');
var _fflush = makeInvalidEarlyAccess('_fflush');
var _emscripten_stack_get_end = makeInvalidEarlyAccess('_emscripten_stack_get_end');
var _emscripten_stack_init = makeInvalidEarlyAccess('_emscripten_stack_init');
var wasmMemory = makeInvalidEarlyAccess('wasmMemory');
var wasmTable = makeInvalidEarlyAccess('wasmTable');

function assignWasmExports(wasmExports) {
  _malloc = createExportWrapper('malloc', 1);
  _free = createExportWrapper('free', 1);
  ___getTypeName = createExportWrapper('__getTypeName', 1);
  _fflush = createExportWrapper('fflush', 1);
  _emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'];
  wasmExports['emscripten_stack_get_base'];
  _emscripten_stack_init = wasmExports['emscripten_stack_init'];
  wasmExports['emscripten_stack_get_free'];
  wasmExports['_emscripten_stack_restore'];
  wasmExports['_emscripten_stack_alloc'];
  wasmExports['emscripten_stack_get_current'];
  wasmMemory = wasmExports['memory'];
  wasmTable = wasmExports['__indirect_function_table'];
}

var wasmImports = {
  /** @export */
  __assert_fail: ___assert_fail,
  /** @export */
  _abort_js: __abort_js,
  /** @export */
  _embind_register_bigint: __embind_register_bigint,
  /** @export */
  _embind_register_bool: __embind_register_bool,
  /** @export */
  _embind_register_emval: __embind_register_emval,
  /** @export */
  _embind_register_float: __embind_register_float,
  /** @export */
  _embind_register_function: __embind_register_function,
  /** @export */
  _embind_register_integer: __embind_register_integer,
  /** @export */
  _embind_register_memory_view: __embind_register_memory_view,
  /** @export */
  _embind_register_std_string: __embind_register_std_string,
  /** @export */
  _embind_register_std_wstring: __embind_register_std_wstring,
  /** @export */
  _embind_register_void: __embind_register_void,
  /** @export */
  _emval_create_invoker: __emval_create_invoker,
  /** @export */
  _emval_decref: __emval_decref,
  /** @export */
  _emval_get_global: __emval_get_global,
  /** @export */
  _emval_get_property: __emval_get_property,
  /** @export */
  _emval_incref: __emval_incref,
  /** @export */
  _emval_invoke: __emval_invoke,
  /** @export */
  _emval_new_array: __emval_new_array,
  /** @export */
  _emval_new_cstring: __emval_new_cstring,
  /** @export */
  _emval_new_object: __emval_new_object,
  /** @export */
  _emval_run_destructors: __emval_run_destructors,
  /** @export */
  _emval_set_property: __emval_set_property,
  /** @export */
  _emval_typeof: __emval_typeof,
  /** @export */
  _mmap_js: __mmap_js,
  /** @export */
  _munmap_js: __munmap_js,
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap,
  /** @export */
  exit: _exit,
  /** @export */
  fd_close: _fd_close,
  /** @export */
  fd_seek: _fd_seek,
  /** @export */
  fd_write: _fd_write
};


// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

var calledRun;

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  _emscripten_stack_init();
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  writeStackCookie();
}

function run() {

  stackCheckInit();

  preRun();

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    assert(!calledRun);
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    readyPromiseResolve?.(Module);
    Module['onRuntimeInitialized']?.();
    consumedModuleProp('onRuntimeInitialized');

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(() => {
      setTimeout(() => Module['setStatus'](''), 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  };
  try { // it doesn't matter if it fails
    flush_NO_FILESYSTEM();
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');
    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');
  }
}

var wasmExports;

// In modularize mode the generated code is within a factory function so we
// can use await here (since it's not top-level-await).
wasmExports = await (createWasm());

run();

// end include: postamble.js

// include: postamble_modularize.js
// In MODULARIZE mode we wrap the generated code in a factory function
// and return either the Module itself, or a promise of the module.
//
// We assign to the `moduleRtn` global here and configure closure to see
// this as and extern so it won't get minified.

if (runtimeInitialized)  {
  moduleRtn = Module;
} else {
  // Set up the promise that indicates the Module is initialized
  moduleRtn = new Promise((resolve, reject) => {
    readyPromiseResolve = resolve;
    readyPromiseReject = reject;
  });
}

// Assertion for attempting to access module properties on the incoming
// moduleArg.  In the past we used this object as the prototype of the module
// and assigned properties to it, but now we return a distinct object.  This
// keeps the instance private until it is ready (i.e the promise has been
// resolved).
for (const prop of Object.keys(Module)) {
  if (!(prop in moduleArg)) {
    Object.defineProperty(moduleArg, prop, {
      configurable: true,
      get() {
        abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`);
      }
    });
  }
}
// end include: postamble_modularize.js



  return moduleRtn;
}

/**
 * An instance of the `Herb` class using a Node.js WASM backend.
 * This loads `libherb` in Node.js using WebAssembly (WASM).
 */
const Herb = new HerbBackendNodeWASM(Herb$1);

const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR$1 = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR$1;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode$1(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR$1:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (isNode$1(ctrl) || isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (isMap(node))
        return visitor.Map?.(key, node, path);
    if (isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (isPair(node))
        return visitor.Pair?.(key, node, path);
    if (isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
            try {
                return prefix + decodeURIComponent(suffix);
            }
            catch (error) {
                onError(String(error));
                return null;
            }
        }
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode$1(doc.contents)) {
            const tags = {};
            visit(doc.contents, (_key, node) => {
                if (isNode$1(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            prevAnchors ?? (prevAnchors = anchorNames(doc));
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (isScalar(ref.node) || isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                // eslint-disable-next-line @typescript-eslint/no-array-delete
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

class NodeBase {
    constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
            throw new TypeError('A document argument is required');
        const ctx = {
            anchors: new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS(this, '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver(reviver, { '': res }, '', res)
            : res;
    }
}

class Alias extends NodeBase {
    constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
            nodes = ctx.aliasResolveCache;
        }
        else {
            nodes = [];
            visit(doc, {
                Node: (_key, node) => {
                    if (isAlias(node) || hasAnchor(node))
                        nodes.push(node);
                }
            });
            if (ctx)
                ctx.aliasResolveCache = nodes;
        }
        let found = undefined;
        for (const node of nodes) {
            if (node === this)
                break;
            if (node.anchor === this.source)
                found = node;
        }
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends NodeBase {
    constructor(value) {
        super(SCALAR$1);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (isDocument(value))
        value = value.contents;
    if (isNode$1(value))
        return value;
    if (isPair(value)) {
        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            ref.anchor ?? (ref.anchor = onAnchor(value));
            return new Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[MAP]
                : Symbol.iterator in Object(value)
                    ? schema[SEQ]
                    : schema[MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
            ? tagObj.nodeClass.from(ctx.schema, value, ctx)
            : new Scalar(value);
    if (tagName)
        node.tag = tagName;
    else if (!tagObj.default)
        node.tag = tagObj.tag;
    if (ref)
        ref.node = node;
    return node;
}

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => isNode$1(it) || isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && isScalar(node) ? node.value : node;
        else
            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}

/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    if (lineWidth < minContentWidth)
        minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i, indent.length);
            end = i + indent.length + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === ' ' || ch === '\t') {
        if (i < start + indent) {
            ch = text[++i];
        }
        else {
            do {
                ch = text[++i];
            } while (ch && ch !== '\n');
            end = i;
            start = i + 1;
            ch = text[start];
        }
    }
    return end;
}

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    // Leading | or > is added later
    let header = (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (!literal) {
        const foldedValue = value
            .replace(/\n+/g, '\n$&')
            .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
            .replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== 'folded' && type !== Scalar.BLOCK_FOLDED) {
            foldOptions.onOverflow = () => {
                literalFallback = true;
            };
        }
        const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
        if (!literalFallback)
            return `>${header}\n${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}\n${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if ((implicitKey && value.includes('\n')) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
        if (indent === '') {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        else if (implicitKey && indent === indentStep) {
            return quotedString(value, ctx);
        }
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.BLOCK_FOLDED:
            case Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (isScalar(item)) {
        obj = item.value;
        let match = tags.filter(t => t.identify?.(obj));
        if (match.length > 1) {
            const testMatch = match.filter(t => t.test);
            if (testMatch.length > 0)
                match = testMatch;
        }
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? 'null' : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
    if (anchor && anchorIsValid(anchor)) {
        anchors.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify$1(item, ctx, onComment, onChompKeep) {
    if (isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = isNode$1(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : isScalar(node)
            ? stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (isNode$1(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (isCollection(key) || (!isNode$1(key) && typeof key === 'object')) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            isCollection(key) ||
            (isScalar(key)
                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify$1(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (isNode$1(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify$1(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        console.warn(warning);
    }
}

// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
const MERGE_KEY = '<<';
const merge$1 = {
    identify: value => value === MERGE_KEY ||
        (typeof value === 'symbol' && value.description === MERGE_KEY),
    default: 'key',
    tag: 'tag:yaml.org,2002:merge',
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
};
const isMergeKey = (ctx, key) => (merge$1.identify(key) ||
    (isScalar(key) &&
        (!key.type || key.type === Scalar.PLAIN) &&
        merge$1.identify(key.value))) &&
    ctx?.doc.schema.tags.some(tag => tag.tag === merge$1.tag && tag.default);
function addMergeToJSMap(ctx, map, value) {
    value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
        for (const it of value.items)
            mergeValue(ctx, map, it);
    else if (Array.isArray(value))
        for (const it of value)
            mergeValue(ctx, map, it);
    else
        mergeValue(ctx, map, value);
}
function mergeValue(ctx, map, value) {
    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}

function addPairToJSMap(ctx, map, { key, value }) {
    if (isNode$1(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value);
    // TODO: Should drop this special case for bare << handling
    else if (isMergeKey(ctx, key))
        addMergeToJSMap(ctx, map, value);
    else {
        const jsKey = toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (isNode$1(key) && ctx?.doc) {
        const strCtx = createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

function createPair(key, value, ctx) {
    const k = createNode(key, undefined, ctx);
    const v = createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (isNode$1(key))
            key = key.clone(schema);
        if (isNode$1(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (isNode$1(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (isPair(item)) {
            const ik = isNode$1(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify$1(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (isNode$1(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (isPair(item)) {
            const ik = isNode$1(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = isNode$1(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify$1(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
        return start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            return `${str}\n${indent}${end}`;
        }
        else {
            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

function findPair(items, key) {
    const k = isScalar(key) ? key.value : key;
    for (const it of items) {
        if (isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair(pair, pair?.value);
        }
        else
            _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (isScalar(prev.value) && isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

const map = {
    collection: 'map',
    default: true,
    nodeClass: YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)
};

class YAMLSeq extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar(prev) && isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

const seq = {
    collection: 'seq',
    default: true,
    nodeClass: YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)
};

const string$2 = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
    }
};

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

const floatNaN$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
};
const floatExp$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
};
const float$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber
};

const intIdentify$2 = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve$1 = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify$1(node, radix, prefix) {
    const { value } = node;
    if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber(node);
}
const intOct$1 = {
    identify: value => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
    stringify: node => intStringify$1(node, 8, '0o')
};
const int$2 = {
    identify: intIdentify$2,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
    stringify: stringifyNumber
};
const intHex$1 = {
    identify: value => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
    stringify: node => intStringify$1(node, 16, '0x')
};

const schema$2 = [
    map,
    seq,
    string$2,
    nullTag,
    boolTag,
    intOct$1,
    int$2,
    intHex$1,
    floatNaN$1,
    floatExp$1,
    float$1
];

function intIdentify$1(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true$|^false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify$1,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema$1 = [map, seq].concat(jsonScalars, jsonError);

const binary = {
    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
            return '';
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        type ?? (type = Scalar.BLOCK_LITERAL);
        if (type !== Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

function resolvePairs(seq, onError) {
    if (isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (isPair(item))
                continue;
            else if (isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair(new Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = isPair(item) ? item : new Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else {
                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                }
            }
            else {
                key = it;
            }
            pairs.items.push(createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

class YAMLOMap extends YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (isPair(pair)) {
                key = toJS(pair.key, '', ctx);
                value = toJS(pair.value, key, ctx);
            }
            else {
                key = toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs = createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs.items;
        return omap;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs = resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs.items) {
            if (isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
};

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar(false),
    stringify: boolStringify
};

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber
};

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int$1 = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

class YAMLSet extends YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair(key.key, null);
        else
            pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair)
            ? isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
    static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(createPair(value, null, ctx));
            }
        return set;
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
        if (isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    }
};

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => String(n).padStart(2, '0'))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, '') ?? ''
};

const schema = [
    map,
    seq,
    string$2,
    nullTag,
    trueTag,
    falseTag,
    intBin,
    intOct,
    int$1,
    intHex,
    floatNaN,
    floatExp,
    float,
    binary,
    merge$1,
    omap,
    pairs,
    set,
    intTime,
    floatTime,
    timestamp
];

const schemas = new Map([
    ['core', schema$2],
    ['failsafe', [map, seq, string$2]],
    ['json', schema$1],
    ['yaml11', schema],
    ['yaml-1.1', schema]
]);
const tagsByName = {
    binary,
    bool: boolTag,
    float: float$1,
    floatExp: floatExp$1,
    floatNaN: floatNaN$1,
    floatTime,
    int: int$2,
    intHex: intHex$1,
    intOct: intOct$1,
    intTime,
    map,
    merge: merge$1,
    null: nullTag,
    omap,
    pairs,
    seq,
    set,
    timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary,
    'tag:yaml.org,2002:merge': merge$1,
    'tag:yaml.org,2002:omap': omap,
    'tag:yaml.org,2002:pairs': pairs,
    'tag:yaml.org,2002:set': set,
    'tag:yaml.org,2002:timestamp': timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge$1)
            ? schemaTags.concat(merge$1)
            : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    if (addMergeTag)
        tags = tags.concat(merge$1);
    return tags.reduce((tags, tag) => {
        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;
        if (!tagObj) {
            const tagName = JSON.stringify(tag);
            const keys = Object.keys(tagsByName)
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags.includes(tagObj))
            tags.push(tagObj);
        return tags;
    }, []);
}

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? getTags(compat, 'compat')
            : compat
                ? getTags(null, compat)
                : null;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR$1, { value: string$2 });
        Object.defineProperty(this, SEQ, { value: seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (isNode$1(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify$1(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify$1(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            stringKeys: false,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = isNode$1(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (isEmptyPath(path))
            return !keepScalar && isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (isEmptyPath(path))
            return this.contents !== undefined;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (isEmptyPath(path)) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value;
        }
        else if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new Directives({ version: '1.1' });
                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new Directives({ version });
                opt = { resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        if (tab) {
            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {
                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
            }
            tab = null;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&
                    token.source.includes('\t')) {
                    tab = token;
                }
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else if (!found || indicator !== 'seq-item-ind')
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    newlineAfterProp = token;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                start ?? (start = token.offset);
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                start ?? (start = token.offset);
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline =
                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== '')) {
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    }
    if (tab &&
        ((atNewline && tab.indent <= parentIndent) ||
            next?.type === 'block-map' ||
            next?.type === 'block-seq'))
        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
    };
}

function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b || (isScalar(a) && isScalar(b) && a.value === b.value);
    return items.some(pair => isEqual(pair.key, search));
}

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: bm.indent,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.newlineAfterProp || containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: bm.indent,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    if (ctx.atKey)
        ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            parentIndent: bs.indent,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    if (ctx.atKey)
        ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            //  key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            ctx.atKey = true;
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            ctx.atKey = false;
            // value properties
            const valueProps = resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                parentIndent: fc.indent,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                const endRange = (valueNode ?? keyNode).range;
                map.range = [keyNode.range[0], endRange[1], endRange[2]];
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === 'block-map'
        ? resolveBlockMap(CN, ctx, token, onError, tag)
        : token.type === 'block-seq'
            ? resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName)
        coll.tag = tagName;
    return coll;
}
function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    if (token.type === 'block-seq') {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken
            ? anchor.offset > tagToken.offset
                ? anchor
                : tagToken
            : (anchor ?? tagToken);
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
            const message = 'Missing newline after block sequence props';
            onError(lastProp, 'MISSING_CHAR', message);
        }
    }
    const expType = token.type === 'block-map'
        ? 'map'
        : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
                ? 'map'
                : 'seq';
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.tagName && expType === 'seq')) {
        return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            if (kt) {
                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            }
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
    const node = isNode$1(res)
        ? res
        : new Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            if (trimIndent === 0 && !ctx.atRoot) {
                const message = 'Block scalar values in collections must be indented';
                onError(offset, 'BAD_INDENT', message);
            }
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0', // null character
    a: '\x07', // bell character
    b: '\b', // backspace
    e: '\x1b', // escape character
    f: '\f', // form feed
    n: '\n', // line feed
    r: '\r', // carriage return
    t: '\t', // horizontal tab
    v: '\v', // vertical tab
    N: '\u0085', // Unicode next line
    _: '\u00a0', // Unicode non-breaking space
    L: '\u2028', // Unicode line separator
    P: '\u2029', // Unicode paragraph separator
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar(ctx, token, onError)
        : resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[SCALAR$1];
    }
    else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === 'scalar')
        tag = findScalarTagByTest(ctx, value, token, onError);
    else
        tag = ctx.schema[SCALAR$1];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = isScalar(res) ? res : new Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[SCALAR$1]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[SCALAR$1];
}
function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&
        tag.test?.test(value)) || schema[SCALAR$1];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[SCALAR$1];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

function emptyScalarPosition(offset, before, pos) {
    if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection(CN, ctx, token, props, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (atKey &&
        ctx.options.stringKeys &&
        (!isScalar(node) ||
            typeof node.value !== 'string' ||
            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {
        const msg = 'With stringKeys, all keys must be strings';
        onError(tag ?? token, 'NON_STRING_KEY', msg);
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document(undefined, opts);
    const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value
        ? composeNode(ctx, value, props, onError)
        : composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new YAMLWarning(pos, code, message));
            else
                this.errors.push(new YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = new Set('0123456789ABCDEFabcdef');
const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const flowIndicatorChars = new Set(',[]{}');
const invalidAnchorChars = new Set(' ,[]{}\n\r\t');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            if (typeof source !== 'string')
                throw TypeError('source is not a string');
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            let cs = line.indexOf('#');
            while (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t') {
                    dirEnd = cs - 1;
                    break;
                }
                else {
                    cs = line.indexOf('#', cs + 1);
                }
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return s === '---' ? 'doc' : 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else {
                this.indentNext =
                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
            }
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        // Trailing insufficiently indented tabs are invalid.
        // To catch that during parsing, we include them in the block scalar value.
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === ' ')
            ch = this.buffer[++i];
        if (ch === '\t') {
            while (ch === '\t' || ch === ' ' || ch === '\r' || ch === '\n')
                ch = this.buffer[++i];
            nl = i - 1;
        }
        else if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && flowIndicatorChars.has(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.has(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.has(this.buffer[i + 1]) &&
                    hexDigits.has(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !it.explicitKey;
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atMapIndent = !this.onKeyLine && this.indent === map.indent;
            const atNextItem = atMapIndent &&
                (it.sep || it.explicitKey) &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !it.explicitKey) {
                        it.start.push(this.sourceToken);
                        it.explicitKey = true;
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start, explicitKey: true });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken], explicitKey: true }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (it.explicitKey) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key;
                            // @ts-expect-error type guard is wrong here
                            delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (bv.type === 'block-seq') {
                            if (!it.explicitKey &&
                                it.sep &&
                                !includesToken(it.sep, 'newline')) {
                                yield* this.pop({
                                    type: 'error',
                                    offset: this.offset,
                                    message: 'Unexpected block-seq-ind on same line with key',
                                    source: this.source
                                });
                                return;
                            }
                        }
                        else if (atMapIndent) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, explicitKey: true }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;
    return { lineCounter, prettyErrors };
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser = new Parser(lineCounter?.addNewLine);
    const composer = new Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(prettifyError(source, lineCounter));
        doc.warnings.forEach(prettifyError(source, lineCounter));
    }
    return doc;
}
function parse$1(src, reviver, options) {
    let _reviver = undefined;
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
            return undefined;
    }
    if (isDocument(value) && !_replacer)
        return value.toString(options);
    return new Document(value, _replacer, options).toString(options);
}

/** A special constant with type `never` */
function $constructor(name, initializer, params) {
    function init(inst, def) {
        var _a;
        Object.defineProperty(inst, "_zod", {
            value: inst._zod ?? {},
            enumerable: false,
        });
        (_a = inst._zod).traits ?? (_a.traits = new Set());
        inst._zod.traits.add(name);
        initializer(inst, def);
        // support prototype modifications
        for (const k in _.prototype) {
            if (!(k in inst))
                Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
        }
        inst._zod.constr = _;
        inst._zod.def = def;
    }
    // doesn't work if Parent has a constructor with arguments
    const Parent = params?.Parent ?? Object;
    class Definition extends Parent {
    }
    Object.defineProperty(Definition, "name", { value: name });
    function _(def) {
        var _a;
        const inst = params?.Parent ? new Definition() : this;
        init(inst, def);
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        for (const fn of inst._zod.deferred) {
            fn();
        }
        return inst;
    }
    Object.defineProperty(_, "init", { value: init });
    Object.defineProperty(_, Symbol.hasInstance, {
        value: (inst) => {
            if (params?.Parent && inst instanceof params.Parent)
                return true;
            return inst?._zod?.traits?.has(name);
        },
    });
    Object.defineProperty(_, "name", { value: name });
    return _;
}
class $ZodAsyncError extends Error {
    constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
}
class $ZodEncodeError extends Error {
    constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
    }
}
const globalConfig = {};
function config(newConfig) {
    return globalConfig;
}

// functions
function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === "number");
    const values = Object.entries(entries)
        .filter(([k, _]) => numericValues.indexOf(+k) === -1)
        .map(([_, v]) => v);
    return values;
}
function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
        return value.toString();
    return value;
}
function cached(getter) {
    return {
        get value() {
            {
                const value = getter();
                Object.defineProperty(this, "value", { value });
                return value;
            }
        },
    };
}
function nullish(input) {
    return input === null || input === undefined;
}
function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepString = step.toString();
    let stepDecCount = (stepString.split(".")[1] || "").length;
    if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
        const match = stepString.match(/\d?e-(\d?)/);
        if (match?.[1]) {
            stepDecCount = Number.parseInt(match[1]);
        }
    }
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
    let value = undefined;
    Object.defineProperty(object, key, {
        get() {
            if (value === EVALUATING) {
                // Circular reference detected, return undefined to break the cycle
                return undefined;
            }
            if (value === undefined) {
                value = EVALUATING;
                value = getter();
            }
            return value;
        },
        set(v) {
            Object.defineProperty(object, key, {
                value: v,
                // configurable: true,
            });
            // object[key] = v;
        },
        configurable: true,
    });
}
function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
function mergeDefs(...defs) {
    const mergedDescriptors = {};
    for (const def of defs) {
        const descriptors = Object.getOwnPropertyDescriptors(def);
        Object.assign(mergedDescriptors, descriptors);
    }
    return Object.defineProperties({}, mergedDescriptors);
}
function esc(str) {
    return JSON.stringify(str);
}
const captureStackTrace = ("captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => { });
function isObject$1(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
    // @ts-ignore
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
    }
    try {
        const F = Function;
        new F("");
        return true;
    }
    catch (_) {
        return false;
    }
});
function isPlainObject(o) {
    if (isObject$1(o) === false)
        return false;
    // modified constructor
    const ctor = o.constructor;
    if (ctor === undefined)
        return true;
    // modified prototype
    const prot = ctor.prototype;
    if (isObject$1(prot) === false)
        return false;
    // ctor doesn't have static `isPrototypeOf`
    if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
        return false;
    }
    return true;
}
function shallowClone(o) {
    if (isPlainObject(o))
        return { ...o };
    if (Array.isArray(o))
        return [...o];
    return o;
}
const propertyKeyTypes = new Set(["string", "number", "symbol"]);
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
// zod-specific utils
function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
        cl._zod.parent = inst;
    return cl;
}
function normalizeParams(_params) {
    const params = _params;
    if (!params)
        return {};
    if (typeof params === "string")
        return { error: () => params };
    if (params?.message !== undefined) {
        if (params?.error !== undefined)
            throw new Error("Cannot specify both `message` and `error` params");
        params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
        return { ...params, error: () => params.error };
    return params;
}
function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
        return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
    });
}
const NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 3.4028234663852886e38],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
function pick(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const newShape = {};
            for (const key in mask) {
                if (!(key in currDef.shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                    continue;
                newShape[key] = currDef.shape[key];
            }
            assignProp(this, "shape", newShape); // self-caching
            return newShape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function omit(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const newShape = { ...schema._zod.def.shape };
            for (const key in mask) {
                if (!(key in currDef.shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                    continue;
                delete newShape[key];
            }
            assignProp(this, "shape", newShape); // self-caching
            return newShape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function extend(schema, shape) {
    if (!isPlainObject(shape)) {
        throw new Error("Invalid input to extend: expected a plain object");
    }
    const checks = schema._zod.def.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
        throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
    }
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function safeExtend(schema, shape) {
    if (!isPlainObject(shape)) {
        throw new Error("Invalid input to safeExtend: expected a plain object");
    }
    const def = {
        ...schema._zod.def,
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        checks: schema._zod.def.checks,
    };
    return clone(schema, def);
}
function merge(a, b) {
    const def = mergeDefs(a._zod.def, {
        get shape() {
            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        get catchall() {
            return b._zod.def.catchall;
        },
        checks: [], // delete existing checks
    });
    return clone(a, def);
}
function partial(Class, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const oldShape = schema._zod.def.shape;
            const shape = { ...oldShape };
            if (mask) {
                for (const key in mask) {
                    if (!(key in oldShape)) {
                        throw new Error(`Unrecognized key: "${key}"`);
                    }
                    if (!mask[key])
                        continue;
                    // if (oldShape[key]!._zod.optin === "optional") continue;
                    shape[key] = Class
                        ? new Class({
                            type: "optional",
                            innerType: oldShape[key],
                        })
                        : oldShape[key];
                }
            }
            else {
                for (const key in oldShape) {
                    // if (oldShape[key]!._zod.optin === "optional") continue;
                    shape[key] = Class
                        ? new Class({
                            type: "optional",
                            innerType: oldShape[key],
                        })
                        : oldShape[key];
                }
            }
            assignProp(this, "shape", shape); // self-caching
            return shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function required(Class, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const oldShape = schema._zod.def.shape;
            const shape = { ...oldShape };
            if (mask) {
                for (const key in mask) {
                    if (!(key in shape)) {
                        throw new Error(`Unrecognized key: "${key}"`);
                    }
                    if (!mask[key])
                        continue;
                    // overwrite with non-optional
                    shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key],
                    });
                }
            }
            else {
                for (const key in oldShape) {
                    // overwrite with non-optional
                    shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key],
                    });
                }
            }
            assignProp(this, "shape", shape); // self-caching
            return shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
// invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom
function aborted(x, startIndex = 0) {
    if (x.aborted === true)
        return true;
    for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i]?.continue !== true) {
            return true;
        }
    }
    return false;
}
function prefixIssues(path, issues) {
    return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
    });
}
function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config) {
    const full = { ...iss, path: iss.path ?? [] };
    // for backwards compatibility
    if (!iss.message) {
        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
            unwrapMessage(ctx?.error?.(iss)) ??
            unwrapMessage(config.customError?.(iss)) ??
            unwrapMessage(config.localeError?.(iss)) ??
            "Invalid input";
        full.message = message;
    }
    // delete (full as any).def;
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
        delete full.input;
    }
    return full;
}
function getLengthableOrigin(input) {
    if (Array.isArray(input))
        return "array";
    if (typeof input === "string")
        return "string";
    return "unknown";
}
function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
        return {
            message: iss,
            code: "custom",
            input,
            inst,
        };
    }
    return { ...iss };
}

const initializer$1 = (inst, def) => {
    inst.name = "$ZodError";
    Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false,
    });
    Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false,
    });
    inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
    Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false,
    });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of error.issues) {
        if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
        }
        else {
            formErrors.push(mapper(sub));
        }
    }
    return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue) => issue.message) {
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
        for (const issue of error.issues) {
            if (issue.code === "invalid_union" && issue.errors.length) {
                issue.errors.map((issues) => processError({ issues }));
            }
            else if (issue.code === "invalid_key") {
                processError({ issues: issue.issues });
            }
            else if (issue.code === "invalid_element") {
                processError({ issues: issue.issues });
            }
            else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
            }
            else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                    const el = issue.path[i];
                    const terminal = i === issue.path.length - 1;
                    if (!terminal) {
                        curr[el] = curr[el] || { _errors: [] };
                    }
                    else {
                        curr[el] = curr[el] || { _errors: [] };
                        curr[el]._errors.push(mapper(issue));
                    }
                    curr = curr[el];
                    i++;
                }
            }
        }
    };
    processError(error);
    return fieldErrors;
}

const _parse = (_Err) => (schema, value, _ctx, _params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
        throw new $ZodAsyncError();
    }
    if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, _params?.callee);
        throw e;
    }
    return result.value;
};
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
        result = await result;
    if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, params?.callee);
        throw e;
    }
    return result.value;
};
const _safeParse = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
        throw new $ZodAsyncError();
    }
    return result.issues.length
        ? {
            success: false,
            error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
        }
        : { success: true, data: result.value };
};
const safeParse$1 = /* @__PURE__*/ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
        result = await result;
    return result.issues.length
        ? {
            success: false,
            error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
        }
        : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__*/ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parse(_Err)(schema, value, ctx);
};
const _decode = (_Err) => (schema, value, _ctx) => {
    return _parse(_Err)(schema, value, _ctx);
};
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parseAsync(_Err)(schema, value, ctx);
};
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _parseAsync(_Err)(schema, value, _ctx);
};
const _safeEncode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParse(_Err)(schema, value, ctx);
};
const _safeDecode = (_Err) => (schema, value, _ctx) => {
    return _safeParse(_Err)(schema, value, _ctx);
};
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParseAsync(_Err)(schema, value, ctx);
};
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _safeParseAsync(_Err)(schema, value, _ctx);
};

const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 9562/4122 UUID.
 *
 * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid = (version) => {
    if (!version)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
/** Practical email validation */
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
    return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
// export const hostname: RegExp = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
const hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
// const dateSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$1 = /*@__PURE__*/ new RegExp(`^${dateSource}$`);
function timeSource(args) {
    const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
    const regex = typeof args.precision === "number"
        ? args.precision === -1
            ? `${hhmm}`
            : args.precision === 0
                ? `${hhmm}:[0-5]\\d`
                : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
        : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    return regex;
}
function time$1(args) {
    return new RegExp(`^${timeSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetime$1(args) {
    const time = timeSource({ precision: args.precision });
    const opts = ["Z"];
    if (args.local)
        opts.push("");
    // if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
    if (args.offset)
        opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
    const timeRegex = `${time}(?:${opts.join("|")})`;
    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
    const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
    return new RegExp(`^${regex}$`);
};
const integer = /^-?\d+$/;
const number$1 = /^-?\d+(?:\.\d+)?/;
const boolean$1 = /^(?:true|false)$/i;
// regex for string with no uppercase letters
const lowercase = /^[^A-Z]*$/;
// regex for string with no lowercase letters
const uppercase = /^[^a-z]*$/;

// import { $ZodType } from "./schemas.js";
const $ZodCheck = /*@__PURE__*/ $constructor("$ZodCheck", (inst, def) => {
    var _a;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date",
};
const $ZodCheckLessThan = /*@__PURE__*/ $constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
            if (def.inclusive)
                bag.maximum = def.value;
            else
                bag.exclusiveMaximum = def.value;
        }
    });
    inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
            return;
        }
        payload.issues.push({
            origin,
            code: "too_big",
            maximum: def.value,
            input: payload.value,
            inclusive: def.inclusive,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckGreaterThan = /*@__PURE__*/ $constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
            if (def.inclusive)
                bag.minimum = def.value;
            else
                bag.exclusiveMinimum = def.value;
        }
    });
    inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
            return;
        }
        payload.issues.push({
            origin,
            code: "too_small",
            minimum: def.value,
            input: payload.value,
            inclusive: def.inclusive,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckMultipleOf = 
/*@__PURE__*/ $constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst) => {
        var _a;
        (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
            throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint"
            ? payload.value % def.value === BigInt(0)
            : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
            return;
        payload.issues.push({
            origin: typeof payload.value,
            code: "not_multiple_of",
            divisor: def.value,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckNumberFormat = /*@__PURE__*/ $constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def); // no format checks
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
            bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
            if (!Number.isInteger(input)) {
                // invalid_format issue
                // payload.issues.push({
                //   expected: def.format,
                //   format: def.format,
                //   code: "invalid_format",
                //   input,
                //   inst,
                // });
                // invalid_type issue
                payload.issues.push({
                    expected: origin,
                    format: def.format,
                    code: "invalid_type",
                    continue: false,
                    input,
                    inst,
                });
                return;
                // not_multiple_of issue
                // payload.issues.push({
                //   code: "not_multiple_of",
                //   origin: "number",
                //   input,
                //   inst,
                //   divisor: 1,
                // });
            }
            if (!Number.isSafeInteger(input)) {
                if (input > 0) {
                    // too_big
                    payload.issues.push({
                        input,
                        code: "too_big",
                        maximum: Number.MAX_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst,
                        origin,
                        continue: !def.abort,
                    });
                }
                else {
                    // too_small
                    payload.issues.push({
                        input,
                        code: "too_small",
                        minimum: Number.MIN_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst,
                        origin,
                        continue: !def.abort,
                    });
                }
                return;
            }
        }
        if (input < minimum) {
            payload.issues.push({
                origin: "number",
                input,
                code: "too_small",
                minimum,
                inclusive: true,
                inst,
                continue: !def.abort,
            });
        }
        if (input > maximum) {
            payload.issues.push({
                origin: "number",
                input,
                code: "too_big",
                maximum,
                inst,
            });
        }
    };
});
const $ZodCheckMaxLength = /*@__PURE__*/ $constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
        if (def.maximum < curr)
            inst._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
            return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
            origin,
            code: "too_big",
            maximum: def.maximum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckMinLength = /*@__PURE__*/ $constructor("$ZodCheckMinLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
        if (def.minimum > curr)
            inst._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
            return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
            origin,
            code: "too_small",
            minimum: def.minimum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckLengthEquals = /*@__PURE__*/ $constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
            return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
            origin,
            ...(tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length }),
            inclusive: true,
            exact: true,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckStringFormat = /*@__PURE__*/ $constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a, _b;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
            bag.patterns ?? (bag.patterns = new Set());
            bag.patterns.add(def.pattern);
        }
    });
    if (def.pattern)
        (_a = inst._zod).check ?? (_a.check = (payload) => {
            def.pattern.lastIndex = 0;
            if (def.pattern.test(payload.value))
                return;
            payload.issues.push({
                origin: "string",
                code: "invalid_format",
                format: def.format,
                input: payload.value,
                ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
                inst,
                continue: !def.abort,
            });
        });
    else
        (_b = inst._zod).check ?? (_b.check = () => { });
});
const $ZodCheckRegex = /*@__PURE__*/ $constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "regex",
            input: payload.value,
            pattern: def.pattern.toString(),
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckLowerCase = /*@__PURE__*/ $constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /*@__PURE__*/ $constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /*@__PURE__*/ $constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: def.includes,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckStartsWith = /*@__PURE__*/ $constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: def.prefix,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckEndsWith = /*@__PURE__*/ $constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: def.suffix,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckOverwrite = /*@__PURE__*/ $constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
    };
});

class Doc {
    constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
            this.args = args;
    }
    indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
    }
    write(arg) {
        if (typeof arg === "function") {
            arg(this, { execution: "sync" });
            arg(this, { execution: "async" });
            return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
            this.content.push(line);
        }
    }
    compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        // console.log(lines.join("\n"));
        return new F(...args, lines.join("\n"));
    }
}

const version$1 = {
    major: 4,
    minor: 1,
    patch: 12,
};

const $ZodType = /*@__PURE__*/ $constructor("$ZodType", (inst, def) => {
    var _a;
    inst ?? (inst = {});
    inst._zod.def = def; // set _def property
    inst._zod.bag = inst._zod.bag || {}; // initialize _bag object
    inst._zod.version = version$1;
    const checks = [...(inst._zod.def.checks ?? [])];
    // if inst is itself a checks.$ZodCheck, run it as a check
    if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
    }
    for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
            fn(inst);
        }
    }
    if (checks.length === 0) {
        // deferred initializer
        // inst._zod.parse is not yet defined
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        inst._zod.deferred?.push(() => {
            inst._zod.run = inst._zod.parse;
        });
    }
    else {
        const runChecks = (payload, checks, ctx) => {
            let isAborted = aborted(payload);
            let asyncResult;
            for (const ch of checks) {
                if (ch._zod.def.when) {
                    const shouldRun = ch._zod.def.when(payload);
                    if (!shouldRun)
                        continue;
                }
                else if (isAborted) {
                    continue;
                }
                const currLen = payload.issues.length;
                const _ = ch._zod.check(payload);
                if (_ instanceof Promise && ctx?.async === false) {
                    throw new $ZodAsyncError();
                }
                if (asyncResult || _ instanceof Promise) {
                    asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                        await _;
                        const nextLen = payload.issues.length;
                        if (nextLen === currLen)
                            return;
                        if (!isAborted)
                            isAborted = aborted(payload, currLen);
                    });
                }
                else {
                    const nextLen = payload.issues.length;
                    if (nextLen === currLen)
                        continue;
                    if (!isAborted)
                        isAborted = aborted(payload, currLen);
                }
            }
            if (asyncResult) {
                return asyncResult.then(() => {
                    return payload;
                });
            }
            return payload;
        };
        // const handleChecksResult = (
        //   checkResult: ParsePayload,
        //   originalResult: ParsePayload,
        //   ctx: ParseContextInternal
        // ): util.MaybeAsync<ParsePayload> => {
        //   // if the checks mutated the value && there are no issues, re-parse the result
        //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)
        //     return inst._zod.parse(checkResult, ctx);
        //   return originalResult;
        // };
        const handleCanaryResult = (canary, payload, ctx) => {
            // abort if the canary is aborted
            if (aborted(canary)) {
                canary.aborted = true;
                return canary;
            }
            // run checks first, then
            const checkResult = runChecks(payload, checks, ctx);
            if (checkResult instanceof Promise) {
                if (ctx.async === false)
                    throw new $ZodAsyncError();
                return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));
            }
            return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
            if (ctx.skipChecks) {
                return inst._zod.parse(payload, ctx);
            }
            if (ctx.direction === "backward") {
                // run canary
                // initial pass (no checks)
                const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
                if (canary instanceof Promise) {
                    return canary.then((canary) => {
                        return handleCanaryResult(canary, payload, ctx);
                    });
                }
                return handleCanaryResult(canary, payload, ctx);
            }
            // forward
            const result = inst._zod.parse(payload, ctx);
            if (result instanceof Promise) {
                if (ctx.async === false)
                    throw new $ZodAsyncError();
                return result.then((result) => runChecks(result, checks, ctx));
            }
            return runChecks(result, checks, ctx);
        };
    }
    inst["~standard"] = {
        validate: (value) => {
            try {
                const r = safeParse$1(inst, value);
                return r.success ? { value: r.data } : { issues: r.error?.issues };
            }
            catch (_) {
                return safeParseAsync$1(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));
            }
        },
        vendor: "zod",
        version: 1,
    };
});
const $ZodString = /*@__PURE__*/ $constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? string$1(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
        if (def.coerce)
            try {
                payload.value = String(payload.value);
            }
            catch (_) { }
        if (typeof payload.value === "string")
            return payload;
        payload.issues.push({
            expected: "string",
            code: "invalid_type",
            input: payload.value,
            inst,
        });
        return payload;
    };
});
const $ZodStringFormat = /*@__PURE__*/ $constructor("$ZodStringFormat", (inst, def) => {
    // check initialization must come first
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
});
const $ZodGUID = /*@__PURE__*/ $constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid);
    $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /*@__PURE__*/ $constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
        const versionMap = {
            v1: 1,
            v2: 2,
            v3: 3,
            v4: 4,
            v5: 5,
            v6: 6,
            v7: 7,
            v8: 8,
        };
        const v = versionMap[def.version];
        if (v === undefined)
            throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
    }
    else
        def.pattern ?? (def.pattern = uuid());
    $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /*@__PURE__*/ $constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email);
    $ZodStringFormat.init(inst, def);
});
const $ZodURL = /*@__PURE__*/ $constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        try {
            // Trim whitespace from input
            const trimmed = payload.value.trim();
            // @ts-ignore
            const url = new URL(trimmed);
            if (def.hostname) {
                def.hostname.lastIndex = 0;
                if (!def.hostname.test(url.hostname)) {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid hostname",
                        pattern: hostname.source,
                        input: payload.value,
                        inst,
                        continue: !def.abort,
                    });
                }
            }
            if (def.protocol) {
                def.protocol.lastIndex = 0;
                if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid protocol",
                        pattern: def.protocol.source,
                        input: payload.value,
                        inst,
                        continue: !def.abort,
                    });
                }
            }
            // Set the output value based on normalize flag
            if (def.normalize) {
                // Use normalized URL
                payload.value = url.href;
            }
            else {
                // Preserve the original input (trimmed)
                payload.value = trimmed;
            }
            return;
        }
        catch (_) {
            payload.issues.push({
                code: "invalid_format",
                format: "url",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
const $ZodEmoji = /*@__PURE__*/ $constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji());
    $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /*@__PURE__*/ $constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid);
    $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /*@__PURE__*/ $constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid);
    $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /*@__PURE__*/ $constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid2);
    $ZodStringFormat.init(inst, def);
});
const $ZodULID = /*@__PURE__*/ $constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid);
    $ZodStringFormat.init(inst, def);
});
const $ZodXID = /*@__PURE__*/ $constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid);
    $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /*@__PURE__*/ $constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid);
    $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /*@__PURE__*/ $constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime$1(def));
    $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /*@__PURE__*/ $constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date$1);
    $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /*@__PURE__*/ $constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time$1(def));
    $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /*@__PURE__*/ $constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration$1);
    $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /*@__PURE__*/ $constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = `ipv4`;
    });
});
const $ZodIPv6 = /*@__PURE__*/ $constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = `ipv6`;
    });
    inst._zod.check = (payload) => {
        try {
            // @ts-ignore
            new URL(`http://[${payload.value}]`);
            // return;
        }
        catch {
            payload.issues.push({
                code: "invalid_format",
                format: "ipv6",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
const $ZodCIDRv4 = /*@__PURE__*/ $constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv4);
    $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /*@__PURE__*/ $constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv6); // not used for validation
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
            if (parts.length !== 2)
                throw new Error();
            const [address, prefix] = parts;
            if (!prefix)
                throw new Error();
            const prefixNum = Number(prefix);
            if (`${prefixNum}` !== prefix)
                throw new Error();
            if (prefixNum < 0 || prefixNum > 128)
                throw new Error();
            // @ts-ignore
            new URL(`http://[${address}]`);
        }
        catch {
            payload.issues.push({
                code: "invalid_format",
                format: "cidrv6",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
//////////////////////////////   ZodBase64   //////////////////////////////
function isValidBase64(data) {
    if (data === "")
        return true;
    if (data.length % 4 !== 0)
        return false;
    try {
        // @ts-ignore
        atob(data);
        return true;
    }
    catch {
        return false;
    }
}
const $ZodBase64 = /*@__PURE__*/ $constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        inst._zod.bag.contentEncoding = "base64";
    });
    inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "base64",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
//////////////////////////////   ZodBase64   //////////////////////////////
function isValidBase64URL(data) {
    if (!base64url.test(data))
        return false;
    const base64 = data.replace(/[-_]/g, (c) => (c === "-" ? "+" : "/"));
    const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, "=");
    return isValidBase64(padded);
}
const $ZodBase64URL = /*@__PURE__*/ $constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        inst._zod.bag.contentEncoding = "base64url";
    });
    inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodE164 = /*@__PURE__*/ $constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e164);
    $ZodStringFormat.init(inst, def);
});
//////////////////////////////   ZodJWT   //////////////////////////////
function isValidJWT(token, algorithm = null) {
    try {
        const tokensParts = token.split(".");
        if (tokensParts.length !== 3)
            return false;
        const [header] = tokensParts;
        if (!header)
            return false;
        // @ts-ignore
        const parsedHeader = JSON.parse(atob(header));
        if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
            return false;
        if (!parsedHeader.alg)
            return false;
        if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
            return false;
        return true;
    }
    catch {
        return false;
    }
}
const $ZodJWT = /*@__PURE__*/ $constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodNumber = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
    inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
            try {
                payload.value = Number(payload.value);
            }
            catch (_) { }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
            return payload;
        }
        const received = typeof input === "number"
            ? Number.isNaN(input)
                ? "NaN"
                : !Number.isFinite(input)
                    ? "Infinity"
                    : undefined
            : undefined;
        payload.issues.push({
            expected: "number",
            code: "invalid_type",
            input,
            inst,
            ...(received ? { received } : {}),
        });
        return payload;
    };
});
const $ZodNumberFormat = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def); // no format checksp
});
const $ZodBoolean = /*@__PURE__*/ $constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = boolean$1;
    inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
            try {
                payload.value = Boolean(payload.value);
            }
            catch (_) { }
        const input = payload.value;
        if (typeof input === "boolean")
            return payload;
        payload.issues.push({
            expected: "boolean",
            code: "invalid_type",
            input,
            inst,
        });
        return payload;
    };
});
const $ZodUnknown = /*@__PURE__*/ $constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
});
const $ZodNever = /*@__PURE__*/ $constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
            expected: "never",
            code: "invalid_type",
            input: payload.value,
            inst,
        });
        return payload;
    };
});
function handleArrayResult(result, final, index) {
    if (result.issues.length) {
        final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
}
const $ZodArray = /*@__PURE__*/ $constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
            payload.issues.push({
                expected: "array",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
            const item = input[i];
            const result = def.element._zod.run({
                value: item,
                issues: [],
            }, ctx);
            if (result instanceof Promise) {
                proms.push(result.then((result) => handleArrayResult(result, payload, i)));
            }
            else {
                handleArrayResult(result, payload, i);
            }
        }
        if (proms.length) {
            return Promise.all(proms).then(() => payload);
        }
        return payload; //handleArrayResultsAsync(parseResults, final);
    };
});
function handlePropertyResult(result, final, key, input) {
    if (result.issues.length) {
        final.issues.push(...prefixIssues(key, result.issues));
    }
    if (result.value === undefined) {
        if (key in input) {
            final.value[key] = undefined;
        }
    }
    else {
        final.value[key] = result.value;
    }
}
function normalizeDef(def) {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
        if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
            throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
        }
    }
    const okeys = optionalKeys(def.shape);
    return {
        ...def,
        keys,
        keySet: new Set(keys),
        numKeys: keys.length,
        optionalKeys: new Set(okeys),
    };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
    const unrecognized = [];
    // iterate over input keys
    const keySet = def.keySet;
    const _catchall = def.catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
        if (keySet.has(key))
            continue;
        if (t === "never") {
            unrecognized.push(key);
            continue;
        }
        const r = _catchall.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
            proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
        }
        else {
            handlePropertyResult(r, payload, key, input);
        }
    }
    if (unrecognized.length) {
        payload.issues.push({
            code: "unrecognized_keys",
            keys: unrecognized,
            input,
            inst,
        });
    }
    if (!proms.length)
        return payload;
    return Promise.all(proms).then(() => {
        return payload;
    });
}
const $ZodObject = /*@__PURE__*/ $constructor("$ZodObject", (inst, def) => {
    // requires cast because technically $ZodObject doesn't extend
    $ZodType.init(inst, def);
    // const sh = def.shape;
    const desc = Object.getOwnPropertyDescriptor(def, "shape");
    if (!desc?.get) {
        const sh = def.shape;
        Object.defineProperty(def, "shape", {
            get: () => {
                const newSh = { ...sh };
                Object.defineProperty(def, "shape", {
                    value: newSh,
                });
                return newSh;
            },
        });
    }
    const _normalized = cached(() => normalizeDef(def));
    defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
            const field = shape[key]._zod;
            if (field.values) {
                propValues[key] ?? (propValues[key] = new Set());
                for (const v of field.values)
                    propValues[key].add(v);
            }
        }
        return propValues;
    });
    const isObject = isObject$1;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject(input)) {
            payload.issues.push({
                expected: "object",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
            const el = shape[key];
            const r = el._zod.run({ value: input[key], issues: [] }, ctx);
            if (r instanceof Promise) {
                proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
            }
            else {
                handlePropertyResult(r, payload, key, input);
            }
        }
        if (!catchall) {
            return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
});
const $ZodObjectJIT = /*@__PURE__*/ $constructor("$ZodObjectJIT", (inst, def) => {
    // requires cast because technically $ZodObject doesn't extend
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
            const k = esc(key);
            return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
            ids[key] = `key_${counter++}`;
        }
        // A: preserve key order {
        doc.write(`const newResult = {};`);
        for (const key of normalized.keys) {
            const id = ids[key];
            const k = esc(key);
            doc.write(`const ${id} = ${parseStr(key)};`);
            doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject = isObject$1;
    const jit = !globalConfig.jitless;
    const allowsEval$1 = allowsEval;
    const fastEnabled = jit && allowsEval$1.value; // && !def.catchall;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject(input)) {
            payload.issues.push({
                expected: "object",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
            // always synchronous
            if (!fastpass)
                fastpass = generateFastpass(def.shape);
            payload = fastpass(payload, ctx);
            if (!catchall)
                return payload;
            return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
    };
});
function handleUnionResults(results, final, inst, ctx) {
    for (const result of results) {
        if (result.issues.length === 0) {
            final.value = result.value;
            return final;
        }
    }
    const nonaborted = results.filter((r) => !aborted(r));
    if (nonaborted.length === 1) {
        final.value = nonaborted[0].value;
        return nonaborted[0];
    }
    final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
    });
    return final;
}
const $ZodUnion = /*@__PURE__*/ $constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
            return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return undefined;
    });
    defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
            const patterns = def.options.map((o) => o._zod.pattern);
            return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return undefined;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
        if (single) {
            return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
            const result = option._zod.run({
                value: payload.value,
                issues: [],
            }, ctx);
            if (result instanceof Promise) {
                results.push(result);
                async = true;
            }
            else {
                if (result.issues.length === 0)
                    return result;
                results.push(result);
            }
        }
        if (!async)
            return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results) => {
            return handleUnionResults(results, payload, inst, ctx);
        });
    };
});
const $ZodIntersection = /*@__PURE__*/ $constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
            return Promise.all([left, right]).then(([left, right]) => {
                return handleIntersectionResults(payload, left, right);
            });
        }
        return handleIntersectionResults(payload, left, right);
    };
});
function mergeValues(a, b) {
    // const aType = parse.t(a);
    // const bType = parse.t(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    if (a instanceof Date && b instanceof Date && +a === +b) {
        return { valid: true, data: a };
    }
    if (isPlainObject(a) && isPlainObject(b)) {
        const bKeys = Object.keys(b);
        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return {
                    valid: false,
                    mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
                };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return { valid: false, mergeErrorPath: [] };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return {
                    valid: false,
                    mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
                };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
    if (left.issues.length) {
        result.issues.push(...left.issues);
    }
    if (right.issues.length) {
        result.issues.push(...right.issues);
    }
    if (aborted(result))
        return result;
    const merged = mergeValues(left.value, right.value);
    if (!merged.valid) {
        throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
    }
    result.value = merged.data;
    return result;
}
const $ZodRecord = /*@__PURE__*/ $constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
            payload.issues.push({
                expected: "record",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
            const values = def.keyType._zod.values;
            payload.value = {};
            for (const key of values) {
                if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
                    const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                    if (result instanceof Promise) {
                        proms.push(result.then((result) => {
                            if (result.issues.length) {
                                payload.issues.push(...prefixIssues(key, result.issues));
                            }
                            payload.value[key] = result.value;
                        }));
                    }
                    else {
                        if (result.issues.length) {
                            payload.issues.push(...prefixIssues(key, result.issues));
                        }
                        payload.value[key] = result.value;
                    }
                }
            }
            let unrecognized;
            for (const key in input) {
                if (!values.has(key)) {
                    unrecognized = unrecognized ?? [];
                    unrecognized.push(key);
                }
            }
            if (unrecognized && unrecognized.length > 0) {
                payload.issues.push({
                    code: "unrecognized_keys",
                    input,
                    inst,
                    keys: unrecognized,
                });
            }
        }
        else {
            payload.value = {};
            for (const key of Reflect.ownKeys(input)) {
                if (key === "__proto__")
                    continue;
                const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
                if (keyResult instanceof Promise) {
                    throw new Error("Async schemas not supported in object keys currently");
                }
                if (keyResult.issues.length) {
                    payload.issues.push({
                        code: "invalid_key",
                        origin: "record",
                        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                        input: key,
                        path: [key],
                        inst,
                    });
                    payload.value[keyResult.value] = keyResult.value;
                    continue;
                }
                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                if (result instanceof Promise) {
                    proms.push(result.then((result) => {
                        if (result.issues.length) {
                            payload.issues.push(...prefixIssues(key, result.issues));
                        }
                        payload.value[keyResult.value] = result.value;
                    }));
                }
                else {
                    if (result.issues.length) {
                        payload.issues.push(...prefixIssues(key, result.issues));
                    }
                    payload.value[keyResult.value] = result.value;
                }
            }
        }
        if (proms.length) {
            return Promise.all(proms).then(() => payload);
        }
        return payload;
    };
});
const $ZodEnum = /*@__PURE__*/ $constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values
        .filter((k) => propertyKeyTypes.has(typeof k))
        .map((o) => (typeof o === "string" ? escapeRegex(o) : o.toString()))
        .join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
            return payload;
        }
        payload.issues.push({
            code: "invalid_value",
            values,
            input,
            inst,
        });
        return payload;
    };
});
const $ZodTransform = /*@__PURE__*/ $constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            throw new $ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
            const output = _out instanceof Promise ? _out : Promise.resolve(_out);
            return output.then((output) => {
                payload.value = output;
                return payload;
            });
        }
        if (_out instanceof Promise) {
            throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
    };
});
function handleOptionalResult(result, input) {
    if (result.issues.length && input === undefined) {
        return { issues: [], value: undefined };
    }
    return result;
}
const $ZodOptional = /*@__PURE__*/ $constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
    });
    defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
            const result = def.innerType._zod.run(payload, ctx);
            if (result instanceof Promise)
                return result.then((r) => handleOptionalResult(r, payload.value));
            return handleOptionalResult(result, payload.value);
        }
        if (payload.value === undefined) {
            return payload;
        }
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodNullable = /*@__PURE__*/ $constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
    });
    defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        // Forward direction (decode): allow null to pass through
        if (payload.value === null)
            return payload;
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodDefault = /*@__PURE__*/ $constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    // inst._zod.qin = "true";
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply defaults for undefined input
        if (payload.value === undefined) {
            payload.value = def.defaultValue;
            /**
             * $ZodDefault returns the default value immediately in forward direction.
             * It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
            return payload;
        }
        // Forward direction: continue with default handling
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => handleDefaultResult(result, def));
        }
        return handleDefaultResult(result, def);
    };
});
function handleDefaultResult(payload, def) {
    if (payload.value === undefined) {
        payload.value = def.defaultValue;
    }
    return payload;
}
const $ZodPrefault = /*@__PURE__*/ $constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply prefault for undefined input
        if (payload.value === undefined) {
            payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodNonOptional = /*@__PURE__*/ $constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => handleNonOptionalResult(result, inst));
        }
        return handleNonOptionalResult(result, inst);
    };
});
function handleNonOptionalResult(payload, inst) {
    if (!payload.issues.length && payload.value === undefined) {
        payload.issues.push({
            code: "invalid_type",
            expected: "nonoptional",
            input: payload.value,
            inst,
        });
    }
    return payload;
}
const $ZodCatch = /*@__PURE__*/ $constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply catch logic
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => {
                payload.value = result.value;
                if (result.issues.length) {
                    payload.value = def.catchValue({
                        ...payload,
                        error: {
                            issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                        },
                        input: payload.value,
                    });
                    payload.issues = [];
                }
                return payload;
            });
        }
        payload.value = result.value;
        if (result.issues.length) {
            payload.value = def.catchValue({
                ...payload,
                error: {
                    issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                },
                input: payload.value,
            });
            payload.issues = [];
        }
        return payload;
    };
});
const $ZodPipe = /*@__PURE__*/ $constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            const right = def.out._zod.run(payload, ctx);
            if (right instanceof Promise) {
                return right.then((right) => handlePipeResult(right, def.in, ctx));
            }
            return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
            return left.then((left) => handlePipeResult(left, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
    };
});
function handlePipeResult(left, next, ctx) {
    if (left.issues.length) {
        // prevent further checks
        left.aborted = true;
        return left;
    }
    return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /*@__PURE__*/ $constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
    };
});
function handleReadonlyResult(payload) {
    payload.value = Object.freeze(payload.value);
    return payload;
}
const $ZodCustom = /*@__PURE__*/ $constructor("$ZodCustom", (inst, def) => {
    $ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
        return payload;
    };
    inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
            return r.then((r) => handleRefineResult(r, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
    };
});
function handleRefineResult(result, payload, input, inst) {
    if (!result) {
        const _iss = {
            code: "custom",
            input,
            inst, // incorporates params.error into issue reporting
            path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting
            continue: !inst._zod.def.abort,
            // params: inst._zod.def.params,
        };
        if (inst._zod.def.params)
            _iss.params = inst._zod.def.params;
        payload.issues.push(issue(_iss));
    }
}

class $ZodRegistry {
    constructor() {
        this._map = new WeakMap();
        this._idmap = new Map();
    }
    add(schema, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
            if (this._idmap.has(meta.id)) {
                throw new Error(`ID ${meta.id} already exists in the registry`);
            }
            this._idmap.set(meta.id, schema);
        }
        return this;
    }
    clear() {
        this._map = new WeakMap();
        this._idmap = new Map();
        return this;
    }
    remove(schema) {
        const meta = this._map.get(schema);
        if (meta && typeof meta === "object" && "id" in meta) {
            this._idmap.delete(meta.id);
        }
        this._map.delete(schema);
        return this;
    }
    get(schema) {
        // return this._map.get(schema) as any;
        // inherit metadata
        const p = schema._zod.parent;
        if (p) {
            const pm = { ...(this.get(p) ?? {}) };
            delete pm.id; // do not inherit id
            const f = { ...pm, ...this._map.get(schema) };
            return Object.keys(f).length ? f : undefined;
        }
        return this._map.get(schema);
    }
    has(schema) {
        return this._map.has(schema);
    }
}
// registries
function registry() {
    return new $ZodRegistry();
}
const globalRegistry = /*@__PURE__*/ registry();

function _string(Class, params) {
    return new Class({
        type: "string",
        ...normalizeParams(params),
    });
}
function _email(Class, params) {
    return new Class({
        type: "string",
        format: "email",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _guid(Class, params) {
    return new Class({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _uuid(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _uuidv4(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v4",
        ...normalizeParams(params),
    });
}
function _uuidv6(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v6",
        ...normalizeParams(params),
    });
}
function _uuidv7(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v7",
        ...normalizeParams(params),
    });
}
function _url(Class, params) {
    return new Class({
        type: "string",
        format: "url",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _emoji(Class, params) {
    return new Class({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _nanoid(Class, params) {
    return new Class({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _cuid(Class, params) {
    return new Class({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _cuid2(Class, params) {
    return new Class({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _ulid(Class, params) {
    return new Class({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _xid(Class, params) {
    return new Class({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _ksuid(Class, params) {
    return new Class({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _ipv4(Class, params) {
    return new Class({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _ipv6(Class, params) {
    return new Class({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _cidrv4(Class, params) {
    return new Class({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _cidrv6(Class, params) {
    return new Class({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _base64(Class, params) {
    return new Class({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _base64url(Class, params) {
    return new Class({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _e164(Class, params) {
    return new Class({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _jwt(Class, params) {
    return new Class({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _isoDateTime(Class, params) {
    return new Class({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: false,
        local: false,
        precision: null,
        ...normalizeParams(params),
    });
}
function _isoDate(Class, params) {
    return new Class({
        type: "string",
        format: "date",
        check: "string_format",
        ...normalizeParams(params),
    });
}
function _isoTime(Class, params) {
    return new Class({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...normalizeParams(params),
    });
}
function _isoDuration(Class, params) {
    return new Class({
        type: "string",
        format: "duration",
        check: "string_format",
        ...normalizeParams(params),
    });
}
function _number(Class, params) {
    return new Class({
        type: "number",
        checks: [],
        ...normalizeParams(params),
    });
}
function _int(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "safeint",
        ...normalizeParams(params),
    });
}
function _boolean(Class, params) {
    return new Class({
        type: "boolean",
        ...normalizeParams(params),
    });
}
function _unknown(Class) {
    return new Class({
        type: "unknown",
    });
}
function _never(Class, params) {
    return new Class({
        type: "never",
        ...normalizeParams(params),
    });
}
function _lt(value, params) {
    return new $ZodCheckLessThan({
        check: "less_than",
        ...normalizeParams(params),
        value,
        inclusive: false,
    });
}
function _lte(value, params) {
    return new $ZodCheckLessThan({
        check: "less_than",
        ...normalizeParams(params),
        value,
        inclusive: true,
    });
}
function _gt(value, params) {
    return new $ZodCheckGreaterThan({
        check: "greater_than",
        ...normalizeParams(params),
        value,
        inclusive: false,
    });
}
function _gte(value, params) {
    return new $ZodCheckGreaterThan({
        check: "greater_than",
        ...normalizeParams(params),
        value,
        inclusive: true,
    });
}
function _multipleOf(value, params) {
    return new $ZodCheckMultipleOf({
        check: "multiple_of",
        ...normalizeParams(params),
        value,
    });
}
function _maxLength(maximum, params) {
    const ch = new $ZodCheckMaxLength({
        check: "max_length",
        ...normalizeParams(params),
        maximum,
    });
    return ch;
}
function _minLength(minimum, params) {
    return new $ZodCheckMinLength({
        check: "min_length",
        ...normalizeParams(params),
        minimum,
    });
}
function _length(length, params) {
    return new $ZodCheckLengthEquals({
        check: "length_equals",
        ...normalizeParams(params),
        length,
    });
}
function _regex(pattern, params) {
    return new $ZodCheckRegex({
        check: "string_format",
        format: "regex",
        ...normalizeParams(params),
        pattern,
    });
}
function _lowercase(params) {
    return new $ZodCheckLowerCase({
        check: "string_format",
        format: "lowercase",
        ...normalizeParams(params),
    });
}
function _uppercase(params) {
    return new $ZodCheckUpperCase({
        check: "string_format",
        format: "uppercase",
        ...normalizeParams(params),
    });
}
function _includes(includes, params) {
    return new $ZodCheckIncludes({
        check: "string_format",
        format: "includes",
        ...normalizeParams(params),
        includes,
    });
}
function _startsWith(prefix, params) {
    return new $ZodCheckStartsWith({
        check: "string_format",
        format: "starts_with",
        ...normalizeParams(params),
        prefix,
    });
}
function _endsWith(suffix, params) {
    return new $ZodCheckEndsWith({
        check: "string_format",
        format: "ends_with",
        ...normalizeParams(params),
        suffix,
    });
}
function _overwrite(tx) {
    return new $ZodCheckOverwrite({
        check: "overwrite",
        tx,
    });
}
// normalize
function _normalize(form) {
    return _overwrite((input) => input.normalize(form));
}
// trim
function _trim() {
    return _overwrite((input) => input.trim());
}
// toLowerCase
function _toLowerCase() {
    return _overwrite((input) => input.toLowerCase());
}
// toUpperCase
function _toUpperCase() {
    return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
    return new Class({
        type: "array",
        element,
        // get element() {
        //   return element;
        // },
        ...normalizeParams(params),
    });
}
// same as _custom but defaults to abort:false
function _refine(Class, fn, _params) {
    const schema = new Class({
        type: "custom",
        check: "custom",
        fn: fn,
        ...normalizeParams(_params),
    });
    return schema;
}
function _superRefine(fn) {
    const ch = _check((payload) => {
        payload.addIssue = (issue$1) => {
            if (typeof issue$1 === "string") {
                payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
            }
            else {
                // for Zod 3 backwards compatibility
                const _issue = issue$1;
                if (_issue.fatal)
                    _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = ch);
                _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...
                payload.issues.push(issue(_issue));
            }
        };
        return fn(payload.value, payload);
    });
    return ch;
}
function _check(fn, params) {
    const ch = new $ZodCheck({
        check: "custom",
        ...normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
}

const ZodISODateTime = /*@__PURE__*/ $constructor("ZodISODateTime", (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function datetime(params) {
    return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /*@__PURE__*/ $constructor("ZodISODate", (inst, def) => {
    $ZodISODate.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function date(params) {
    return _isoDate(ZodISODate, params);
}
const ZodISOTime = /*@__PURE__*/ $constructor("ZodISOTime", (inst, def) => {
    $ZodISOTime.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function time(params) {
    return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /*@__PURE__*/ $constructor("ZodISODuration", (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function duration(params) {
    return _isoDuration(ZodISODuration, params);
}

const initializer = (inst, issues) => {
    $ZodError.init(inst, issues);
    inst.name = "ZodError";
    Object.defineProperties(inst, {
        format: {
            value: (mapper) => formatError(inst, mapper),
            // enumerable: false,
        },
        flatten: {
            value: (mapper) => flattenError(inst, mapper),
            // enumerable: false,
        },
        addIssue: {
            value: (issue) => {
                inst.issues.push(issue);
                inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
            },
            // enumerable: false,
        },
        addIssues: {
            value: (issues) => {
                inst.issues.push(...issues);
                inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
            },
            // enumerable: false,
        },
        isEmpty: {
            get() {
                return inst.issues.length === 0;
            },
            // enumerable: false,
        },
    });
    // Object.defineProperty(inst, "isEmpty", {
    //   get() {
    //     return inst.issues.length === 0;
    //   },
    // });
};
const ZodError = $constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, {
    Parent: Error,
});
// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */
// export type ErrorMapCtx = core.$ZodErrorMapCtx;

const parse = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
// Codec functions
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

const ZodType = /*@__PURE__*/ $constructor("ZodType", (inst, def) => {
    $ZodType.init(inst, def);
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    // base methods
    inst.check = (...checks) => {
        return inst.clone(mergeDefs(def, {
            checks: [
                ...(def.checks ?? []),
                ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch),
            ],
        }));
    };
    inst.clone = (def, params) => clone(inst, def, params);
    inst.brand = () => inst;
    inst.register = ((reg, meta) => {
        reg.add(inst, meta);
        return inst;
    });
    // parsing
    inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
    inst.spa = inst.safeParseAsync;
    // encoding/decoding
    inst.encode = (data, params) => encode(inst, data, params);
    inst.decode = (data, params) => decode(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
    // refinements
    inst.refine = (check, params) => inst.check(refine(check, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite(fn));
    // wrappers
    inst.optional = () => optional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def) => _default(inst, def);
    inst.prefault = (def) => prefault(inst, def);
    // inst.coalesce = (def, params) => coalesce(inst, def, params);
    inst.catch = (params) => _catch(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    // meta
    inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
    };
    Object.defineProperty(inst, "description", {
        get() {
            return globalRegistry.get(inst)?.description;
        },
        configurable: true,
    });
    inst.meta = (...args) => {
        if (args.length === 0) {
            return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
    };
    // helpers
    inst.isOptional = () => inst.safeParse(undefined).success;
    inst.isNullable = () => inst.safeParse(null).success;
    return inst;
});
/** @internal */
const _ZodString = /*@__PURE__*/ $constructor("_ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    ZodType.init(inst, def);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    // validations
    inst.regex = (...args) => inst.check(_regex(...args));
    inst.includes = (...args) => inst.check(_includes(...args));
    inst.startsWith = (...args) => inst.check(_startsWith(...args));
    inst.endsWith = (...args) => inst.check(_endsWith(...args));
    inst.min = (...args) => inst.check(_minLength(...args));
    inst.max = (...args) => inst.check(_maxLength(...args));
    inst.length = (...args) => inst.check(_length(...args));
    inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase(params));
    inst.uppercase = (params) => inst.check(_uppercase(params));
    // transforms
    inst.trim = () => inst.check(_trim());
    inst.normalize = (...args) => inst.check(_normalize(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase());
    inst.toUpperCase = () => inst.check(_toUpperCase());
});
const ZodString = /*@__PURE__*/ $constructor("ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_email(ZodEmail, params));
    inst.url = (params) => inst.check(_url(ZodURL, params));
    inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_e164(ZodE164, params));
    // iso
    inst.datetime = (params) => inst.check(datetime(params));
    inst.date = (params) => inst.check(date(params));
    inst.time = (params) => inst.check(time(params));
    inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
    return _string(ZodString, params);
}
const ZodStringFormat = /*@__PURE__*/ $constructor("ZodStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
});
const ZodEmail = /*@__PURE__*/ $constructor("ZodEmail", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodGUID = /*@__PURE__*/ $constructor("ZodGUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodUUID = /*@__PURE__*/ $constructor("ZodUUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodURL = /*@__PURE__*/ $constructor("ZodURL", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodEmoji = /*@__PURE__*/ $constructor("ZodEmoji", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodNanoID = /*@__PURE__*/ $constructor("ZodNanoID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodCUID = /*@__PURE__*/ $constructor("ZodCUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /*@__PURE__*/ $constructor("ZodCUID2", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodULID = /*@__PURE__*/ $constructor("ZodULID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodXID = /*@__PURE__*/ $constructor("ZodXID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodKSUID = /*@__PURE__*/ $constructor("ZodKSUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /*@__PURE__*/ $constructor("ZodIPv4", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /*@__PURE__*/ $constructor("ZodIPv6", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /*@__PURE__*/ $constructor("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /*@__PURE__*/ $constructor("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodBase64 = /*@__PURE__*/ $constructor("ZodBase64", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /*@__PURE__*/ $constructor("ZodBase64URL", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodE164 = /*@__PURE__*/ $constructor("ZodE164", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodJWT = /*@__PURE__*/ $constructor("ZodJWT", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodNumber = /*@__PURE__*/ $constructor("ZodNumber", (inst, def) => {
    $ZodNumber.init(inst, def);
    ZodType.init(inst, def);
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_gt(0, params));
    inst.nonnegative = (params) => inst.check(_gte(0, params));
    inst.negative = (params) => inst.check(_lt(0, params));
    inst.nonpositive = (params) => inst.check(_lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    inst.step = (value, params) => inst.check(_multipleOf(value, params));
    // inst.finite = (params) => inst.check(core.finite(params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue =
        Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue =
        Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
});
function number(params) {
    return _number(ZodNumber, params);
}
const ZodNumberFormat = /*@__PURE__*/ $constructor("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
});
function int(params) {
    return _int(ZodNumberFormat, params);
}
const ZodBoolean = /*@__PURE__*/ $constructor("ZodBoolean", (inst, def) => {
    $ZodBoolean.init(inst, def);
    ZodType.init(inst, def);
});
function boolean(params) {
    return _boolean(ZodBoolean, params);
}
const ZodUnknown = /*@__PURE__*/ $constructor("ZodUnknown", (inst, def) => {
    $ZodUnknown.init(inst, def);
    ZodType.init(inst, def);
});
function unknown() {
    return _unknown(ZodUnknown);
}
const ZodNever = /*@__PURE__*/ $constructor("ZodNever", (inst, def) => {
    $ZodNever.init(inst, def);
    ZodType.init(inst, def);
});
function never(params) {
    return _never(ZodNever, params);
}
const ZodArray = /*@__PURE__*/ $constructor("ZodArray", (inst, def) => {
    $ZodArray.init(inst, def);
    ZodType.init(inst, def);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_length(len, params));
    inst.unwrap = () => inst.element;
});
function array(element, params) {
    return _array(ZodArray, element, params);
}
const ZodObject = /*@__PURE__*/ $constructor("ZodObject", (inst, def) => {
    $ZodObjectJIT.init(inst, def);
    ZodType.init(inst, def);
    defineLazy(inst, "shape", () => {
        return def.shape;
    });
    inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
    inst.extend = (incoming) => {
        return extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
        return safeExtend(inst, incoming);
    };
    inst.merge = (other) => merge(inst, other);
    inst.pick = (mask) => pick(inst, mask);
    inst.omit = (mask) => omit(inst, mask);
    inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
    inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
    const def = {
        type: "object",
        shape: shape ?? {},
        ...normalizeParams(params),
    };
    return new ZodObject(def);
}
const ZodUnion = /*@__PURE__*/ $constructor("ZodUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    ZodType.init(inst, def);
    inst.options = def.options;
});
function union(options, params) {
    return new ZodUnion({
        type: "union",
        options: options,
        ...normalizeParams(params),
    });
}
const ZodIntersection = /*@__PURE__*/ $constructor("ZodIntersection", (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
});
function intersection(left, right) {
    return new ZodIntersection({
        type: "intersection",
        left: left,
        right: right,
    });
}
const ZodRecord = /*@__PURE__*/ $constructor("ZodRecord", (inst, def) => {
    $ZodRecord.init(inst, def);
    ZodType.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
    return new ZodRecord({
        type: "record",
        keyType,
        valueType: valueType,
        ...normalizeParams(params),
    });
}
const ZodEnum = /*@__PURE__*/ $constructor("ZodEnum", (inst, def) => {
    $ZodEnum.init(inst, def);
    ZodType.init(inst, def);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
            if (keys.has(value)) {
                newEntries[value] = def.entries[value];
            }
            else
                throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
            ...def,
            checks: [],
            ...normalizeParams(params),
            entries: newEntries,
        });
    };
    inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
            if (keys.has(value)) {
                delete newEntries[value];
            }
            else
                throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
            ...def,
            checks: [],
            ...normalizeParams(params),
            entries: newEntries,
        });
    };
});
function _enum(values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new ZodEnum({
        type: "enum",
        entries,
        ...normalizeParams(params),
    });
}
const ZodTransform = /*@__PURE__*/ $constructor("ZodTransform", (inst, def) => {
    $ZodTransform.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
            throw new $ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue$1) => {
            if (typeof issue$1 === "string") {
                payload.issues.push(issue(issue$1, payload.value, def));
            }
            else {
                // for Zod 3 backwards compatibility
                const _issue = issue$1;
                if (_issue.fatal)
                    _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = inst);
                // _issue.continue ??= true;
                payload.issues.push(issue(_issue));
            }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
            return output.then((output) => {
                payload.value = output;
                return payload;
            });
        }
        payload.value = output;
        return payload;
    };
});
function transform(fn) {
    return new ZodTransform({
        type: "transform",
        transform: fn,
    });
}
const ZodOptional = /*@__PURE__*/ $constructor("ZodOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
    return new ZodOptional({
        type: "optional",
        innerType: innerType,
    });
}
const ZodNullable = /*@__PURE__*/ $constructor("ZodNullable", (inst, def) => {
    $ZodNullable.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
    return new ZodNullable({
        type: "nullable",
        innerType: innerType,
    });
}
const ZodDefault = /*@__PURE__*/ $constructor("ZodDefault", (inst, def) => {
    $ZodDefault.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
    return new ZodDefault({
        type: "default",
        innerType: innerType,
        get defaultValue() {
            return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
        },
    });
}
const ZodPrefault = /*@__PURE__*/ $constructor("ZodPrefault", (inst, def) => {
    $ZodPrefault.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
    return new ZodPrefault({
        type: "prefault",
        innerType: innerType,
        get defaultValue() {
            return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
        },
    });
}
const ZodNonOptional = /*@__PURE__*/ $constructor("ZodNonOptional", (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
    return new ZodNonOptional({
        type: "nonoptional",
        innerType: innerType,
        ...normalizeParams(params),
    });
}
const ZodCatch = /*@__PURE__*/ $constructor("ZodCatch", (inst, def) => {
    $ZodCatch.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
    return new ZodCatch({
        type: "catch",
        innerType: innerType,
        catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
    });
}
const ZodPipe = /*@__PURE__*/ $constructor("ZodPipe", (inst, def) => {
    $ZodPipe.init(inst, def);
    ZodType.init(inst, def);
    inst.in = def.in;
    inst.out = def.out;
});
function pipe(in_, out) {
    return new ZodPipe({
        type: "pipe",
        in: in_,
        out: out,
        // ...util.normalizeParams(params),
    });
}
const ZodReadonly = /*@__PURE__*/ $constructor("ZodReadonly", (inst, def) => {
    $ZodReadonly.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
    return new ZodReadonly({
        type: "readonly",
        innerType: innerType,
    });
}
const ZodCustom = /*@__PURE__*/ $constructor("ZodCustom", (inst, def) => {
    $ZodCustom.init(inst, def);
    ZodType.init(inst, def);
});
function refine(fn, _params = {}) {
    return _refine(ZodCustom, fn, _params);
}
// superRefine
function superRefine(fn) {
    return _superRefine(fn);
}

// lib/v4/isZodErrorLike.ts
function isZodErrorLike(err) {
  return err instanceof Object && "name" in err && (err.name === "ZodError" || err.name === "$ZodError") && "issues" in err && Array.isArray(err.issues);
}

// lib/v4/ValidationError.ts
var ZOD_VALIDATION_ERROR_NAME = "ZodValidationError";
var ValidationError = class extends Error {
  name;
  details;
  constructor(message, options) {
    super(message, options);
    this.name = ZOD_VALIDATION_ERROR_NAME;
    this.details = getIssuesFromErrorOptions(options);
  }
  toString() {
    return this.message;
  }
};
function getIssuesFromErrorOptions(options) {
  if (options) {
    const cause = options.cause;
    if (isZodErrorLike(cause)) {
      return cause.issues;
    }
  }
  return [];
}

// lib/utils/stringify.ts
function stringifySymbol(symbol) {
  return symbol.description ?? "";
}

// lib/utils/NonEmptyArray.ts
function isNonEmptyArray(value) {
  return value.length !== 0;
}

// lib/utils/joinPath.ts
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path) {
  if (path.length === 1) {
    let propertyKey = path[0];
    if (typeof propertyKey === "symbol") {
      propertyKey = stringifySymbol(propertyKey);
    }
    return propertyKey.toString() || '""';
  }
  return path.reduce((acc, propertyKey) => {
    if (typeof propertyKey === "number") {
      return acc + "[" + propertyKey.toString() + "]";
    }
    if (typeof propertyKey === "symbol") {
      propertyKey = stringifySymbol(propertyKey);
    }
    if (propertyKey.includes('"')) {
      return acc + '["' + escapeQuotes(propertyKey) + '"]';
    }
    if (!identifierRegex.test(propertyKey)) {
      return acc + '["' + propertyKey + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + propertyKey;
  }, "");
}
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}

// lib/utils/titleCase.ts
function titleCase(value) {
  if (value.length === 0) {
    return value;
  }
  return value.charAt(0).toUpperCase() + value.slice(1);
}

// lib/v4/MessageBuilder.ts
var defaultMessageBuilderOptions = {
  prefix: "Validation error",
  prefixSeparator: ": ",
  maxIssuesInMessage: 99,
  // I've got 99 problems but the b$tch ain't one
  unionSeparator: " or ",
  issueSeparator: "; ",
  includePath: true,
  forceTitleCase: true
};
function createMessageBuilder(partialOptions = {}) {
  const options = {
    ...defaultMessageBuilderOptions,
    ...partialOptions
  };
  return function messageBuilder(issues) {
    const message = issues.slice(0, options.maxIssuesInMessage).map((issue) => mapIssue(issue, options)).join(options.issueSeparator);
    return conditionallyPrefixMessage(message, options);
  };
}
function mapIssue(issue, options) {
  if (issue.code === "invalid_union" && isNonEmptyArray(issue.errors)) {
    const individualMessages = issue.errors.map(
      (issues) => issues.map(
        (subIssue) => mapIssue(
          {
            ...subIssue,
            path: issue.path.concat(subIssue.path)
          },
          options
        )
      ).join(options.issueSeparator)
    );
    return Array.from(new Set(individualMessages)).join(options.unionSeparator);
  }
  const buf = [];
  if (options.forceTitleCase) {
    buf.push(titleCase(issue.message));
  } else {
    buf.push(issue.message);
  }
  pathCondition: if (options.includePath && issue.path !== void 0 && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier = issue.path[0];
      if (typeof identifier === "number") {
        buf.push(` at index ${identifier}`);
        break pathCondition;
      }
    }
    buf.push(` at "${joinPath(issue.path)}"`);
  }
  return buf.join("");
}
function conditionallyPrefixMessage(message, options) {
  if (options.prefix != null) {
    if (message.length > 0) {
      return [options.prefix, message].join(options.prefixSeparator);
    }
    return options.prefix;
  }
  if (message.length > 0) {
    return message;
  }
  return defaultMessageBuilderOptions.prefix;
}

// lib/v4/fromZodError.ts
function fromZodError(zodError, options = {}) {
  if (!isZodErrorLike(zodError)) {
    throw new TypeError(
      `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
    );
  }
  return fromZodErrorWithoutRuntimeCheck(zodError, options);
}
function fromZodErrorWithoutRuntimeCheck(zodError, options = {}) {
  const zodIssues = zodError.issues;
  let message;
  if (isNonEmptyArray(zodIssues)) {
    const messageBuilder = createMessageBuilderFromOptions(options);
    message = messageBuilder(zodIssues);
  } else {
    message = zodError.message;
  }
  return new ValidationError(message, { cause: zodError });
}
function createMessageBuilderFromOptions(options) {
  if ("messageBuilder" in options) {
    return options.messageBuilder;
  }
  return createMessageBuilder(options);
}

// lib/v4/toValidationError.ts
var toValidationError = (options = {}) => (err) => {
  if (isZodErrorLike(err)) {
    return fromZodErrorWithoutRuntimeCheck(err, options);
  }
  if (err instanceof Error) {
    return new ValidationError(err.message, { cause: err });
  }
  return new ValidationError("Unknown error");
};

// lib/v4/fromError.ts
function fromError(err, options = {}) {
  return toValidationError(options)(err);
}

const balanced = (a, b, str) => {
    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
    const r = ma !== null && mb != null && range(ma, mb, str);
    return (r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + ma.length, r[1]),
        post: str.slice(r[1] + mb.length),
    });
};
const maybeMatch = (reg, str) => {
    const m = str.match(reg);
    return m ? m[0] : null;
};
const range = (a, b, str) => {
    let begs, beg, left, right = undefined, result;
    let ai = str.indexOf(a);
    let bi = str.indexOf(b, ai + 1);
    let i = ai;
    if (ai >= 0 && bi > 0) {
        if (a === b) {
            return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
            if (i === ai) {
                begs.push(i);
                ai = str.indexOf(a, i + 1);
            }
            else if (begs.length === 1) {
                const r = begs.pop();
                if (r !== undefined)
                    result = [r, bi];
            }
            else {
                beg = begs.pop();
                if (beg !== undefined && beg < left) {
                    left = beg;
                    right = bi;
                }
                bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length && right !== undefined) {
            result = [left, right];
        }
    }
    return result;
};

const escSlash = '\0SLASH' + Math.random() + '\0';
const escOpen = '\0OPEN' + Math.random() + '\0';
const escClose = '\0CLOSE' + Math.random() + '\0';
const escComma = '\0COMMA' + Math.random() + '\0';
const escPeriod = '\0PERIOD' + Math.random() + '\0';
const escSlashPattern = new RegExp(escSlash, 'g');
const escOpenPattern = new RegExp(escOpen, 'g');
const escClosePattern = new RegExp(escClose, 'g');
const escCommaPattern = new RegExp(escComma, 'g');
const escPeriodPattern = new RegExp(escPeriod, 'g');
const slashPattern = /\\\\/g;
const openPattern = /\\{/g;
const closePattern = /\\}/g;
const commaPattern = /\\,/g;
const periodPattern = /\\./g;
function numeric(str) {
    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
    return str
        .replace(slashPattern, escSlash)
        .replace(openPattern, escOpen)
        .replace(closePattern, escClose)
        .replace(commaPattern, escComma)
        .replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
    return str
        .replace(escSlashPattern, '\\')
        .replace(escOpenPattern, '{')
        .replace(escClosePattern, '}')
        .replace(escCommaPattern, ',')
        .replace(escPeriodPattern, '.');
}
/**
 * Basically just str.split(","), but handling cases
 * where we have nested braced sections, which should be
 * treated as individual members, like {a,{b,c},d}
 */
function parseCommaParts(str) {
    if (!str) {
        return [''];
    }
    const parts = [];
    const m = balanced('{', '}', str);
    if (!m) {
        return str.split(',');
    }
    const { pre, body, post } = m;
    const p = pre.split(',');
    p[p.length - 1] += '{' + body + '}';
    const postParts = parseCommaParts(post);
    if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
}
function expand(str) {
    if (!str) {
        return [];
    }
    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.slice(0, 2) === '{}') {
        str = '\\{\\}' + str.slice(2);
    }
    return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
    return '{' + str + '}';
}
function isPadded(el) {
    return /^-?0\d/.test(el);
}
function lte(i, y) {
    return i <= y;
}
function gte(i, y) {
    return i >= y;
}
function expand_(str, isTop) {
    /** @type {string[]} */
    const expansions = [];
    const m = balanced('{', '}', str);
    if (!m)
        return [str];
    // no need to expand pre, since it is guaranteed to be free of brace-sets
    const pre = m.pre;
    const post = m.post.length ? expand_(m.post, false) : [''];
    if (/\$$/.test(m.pre)) {
        for (let k = 0; k < post.length; k++) {
            const expansion = pre + '{' + m.body + '}' + post[k];
            expansions.push(expansion);
        }
    }
    else {
        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        const isSequence = isNumericSequence || isAlphaSequence;
        const isOptions = m.body.indexOf(',') >= 0;
        if (!isSequence && !isOptions) {
            // {a},b}
            if (m.post.match(/,(?!,).*\}/)) {
                str = m.pre + '{' + m.body + escClose + m.post;
                return expand_(str);
            }
            return [str];
        }
        let n;
        if (isSequence) {
            n = m.body.split(/\.\./);
        }
        else {
            n = parseCommaParts(m.body);
            if (n.length === 1 && n[0] !== undefined) {
                // x{{a,b}}y ==> x{a}y x{b}y
                n = expand_(n[0], false).map(embrace);
                //XXX is this necessary? Can't seem to hit it in tests.
                /* c8 ignore start */
                if (n.length === 1) {
                    return post.map(p => m.pre + n[0] + p);
                }
                /* c8 ignore stop */
            }
        }
        // at this point, n is the parts, and we know it's not a comma set
        // with a single entry.
        let N;
        if (isSequence && n[0] !== undefined && n[1] !== undefined) {
            const x = numeric(n[0]);
            const y = numeric(n[1]);
            const width = Math.max(n[0].length, n[1].length);
            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;
            let test = lte;
            const reverse = y < x;
            if (reverse) {
                incr *= -1;
                test = gte;
            }
            const pad = n.some(isPadded);
            N = [];
            for (let i = x; test(i, y); i += incr) {
                let c;
                if (isAlphaSequence) {
                    c = String.fromCharCode(i);
                    if (c === '\\') {
                        c = '';
                    }
                }
                else {
                    c = String(i);
                    if (pad) {
                        const need = width - c.length;
                        if (need > 0) {
                            const z = new Array(need + 1).join('0');
                            if (i < 0) {
                                c = '-' + z + c.slice(1);
                            }
                            else {
                                c = z + c;
                            }
                        }
                    }
                }
                N.push(c);
            }
        }
        else {
            N = [];
            for (let j = 0; j < n.length; j++) {
                N.push.apply(N, expand_(n[j], false));
            }
        }
        for (let j = 0; j < N.length; j++) {
            for (let k = 0; k < post.length; k++) {
                const expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion) {
                    expansions.push(expansion);
                }
            }
        }
    }
    return expansions;
}

const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};

// translate the various posix character classes into unicode properties
// this works across all unicode locales
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};

/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link MinimatchOptions.windowsPathsNoEscape} option is used, then
 * square-bracket escapes are removed, but not backslash escapes.
 *
 * For example, it will turn the string `'[*]'` into `*`, but it will not
 * turn `'\\*'` into `'*'`, because `\` is a path separator in
 * `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both square-bracket escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 *
 * When `magicalBraces` is not set, escapes of braces (`{` and `}`) will not be
 * unescaped.
 */
const unescape = (s, { windowsPathsNoEscape = false, magicalBraces = true, } = {}) => {
    if (magicalBraces) {
        return windowsPathsNoEscape
            ? s.replace(/\[([^\/\\])\]/g, '$1')
            : s
                .replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2')
                .replace(/\\([^\/])/g, '$1');
    }
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\{}])\]/g, '$1')
        : s
            .replace(/((?!\\).|^)\[([^\/\\{}])\]/g, '$1$2')
            .replace(/\\([^\/{}])/g, '$1');
};

// parse a single path portion
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark$1 = '[^/]';
// * => any number of characters
const star$1 = qmark$1 + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark$1 + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() &&
                this.isEnd() &&
                !this.#parts.some(s => typeof s !== 'string');
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                unescape(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, unescape(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star$1 +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = parseClass(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                re += noEmpty && glob === '*' ? starNoEmpty : star$1;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark$1;
                hasMagic = true;
                continue;
            }
            re += regExpEscape$1(c);
        }
        return [re, unescape(glob), !!hasMagic, uflag];
    }
}

/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link MinimatchOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 *
 * If the {@link MinimatchOptions.magicalBraces} option is used,
 * then braces (`{` and `}`) will be escaped.
 */
const escape = (s, { windowsPathsNoEscape = false, magicalBraces = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    if (magicalBraces) {
        return windowsPathsNoEscape
            ? s.replace(/[?*()[\]{}]/g, '[$&]')
            : s.replace(/[?*()[\]\\{}]/g, '\\$&');
    }
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};

const minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform$2 = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
const sep = defaultPlatform$2 === 'win32' ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol('globstar **');
minimatch.GLOBSTAR = GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR,
    });
};
minimatch.defaults = defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return expand(pattern);
};
minimatch.braceExpand = braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform$2;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // don't need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === GLOBSTAR
                        ? GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR || prev === GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + ')?';
                }
                else if (next !== GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = GLOBSTAR;
                }
            });
            const filtered = pp.filter(p => p !== GLOBSTAR);
            // For partial matches, we need to make the pattern match
            // any prefix of the full path. We do this by generating
            // alternative patterns that match progressively longer prefixes.
            if (this.partial && filtered.length >= 1) {
                const prefixes = [];
                for (let i = 1; i <= filtered.length; i++) {
                    prefixes.push(filtered.slice(0, i).join('/'));
                }
                return '(?:' + prefixes.join('|') + ')';
            }
            return filtered.join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // In partial mode, '/' should always match as it's a valid prefix for any pattern
        if (this.partial) {
            re = '^(?:\\/|' + open + re.slice(1, -1) + close + ')$';
        }
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
/* c8 ignore stop */
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */
    get onInsert() {
        return this.#onInsert;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof onInsert === 'function') {
            this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
            if (this.#hasOnInsert) {
                this.#onInsert?.(v, k, 'add');
            }
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
            if (this.#hasOnInsert) {
                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}

const proc = typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
    };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
const isStream = (s) => !!s &&
    typeof s === 'object' &&
    (s instanceof Minipass ||
        s instanceof Stream ||
        isReadable(s) ||
        isWritable(s));
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
const isReadable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof node_events.EventEmitter &&
    typeof s.pipe === 'function' &&
    // node core Writable streams have a pipe() method, but it throws
    s.pipe !== Stream.Writable.prototype.pipe;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
const isWritable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof node_events.EventEmitter &&
    typeof s.write === 'function' &&
    typeof s.end === 'function';
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED = Symbol('aborted');
const SIGNAL = Symbol('signal');
const DATALISTENERS = Symbol('dataListeners');
const DISCARDED = Symbol('discarded');
const defer = (fn) => Promise.resolve().then(fn);
const nodefer = (fn) => fn();
const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
    (!!b &&
        typeof b === 'object' &&
        b.constructor &&
        b.constructor.name === 'ArrayBuffer' &&
        b.byteLength >= 0);
const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) { }
    /* c8 ignore stop */
    end() {
        this.unpipe();
        if (this.opts.end)
            this.dest.end();
    }
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = er => dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
const isObjectModeOptions = (o) => !!o.objectMode;
const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
class Minipass extends node_events.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
        const options = (args[0] ||
            {});
        super();
        if (options.objectMode && typeof options.encoding === 'string') {
            throw new TypeError('Encoding and objectMode may not be used together');
        }
        if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
        }
        else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
        }
        else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING]
            ? new node_string_decoder.StringDecoder(this[ENCODING])
            : null;
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
        }
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
                this[ABORT]();
            }
            else {
                signal.addEventListener('abort', () => this[ABORT]());
            }
        }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
        return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
        return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
        throw new Error('objectMode must be set at instantiation time');
    }
    /**
     * true if this is an async stream
     */
    get ['async']() {
        return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit('abort', this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED])
            return false;
        if (this[EOF])
            throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC] ? defer : nodefer;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                this[FLUSH](true);
            /* c8 ignore stop */
            if (this[FLOWING])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
        if (this[FLOWING])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED])
            return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE])
            n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER] = [
                (this[ENCODING]
                    ? this[BUFFER].join('')
                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (this[OBJECTMODE])
            this[BUFFERSHIFT]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT]();
            else if (typeof c === 'string') {
                this[BUFFER][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH] -= n;
            }
            else {
                this[BUFFER][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER].length && !this[EOF])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING] || !this[PAUSED])
            this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED])
            return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER].length)
            this[FLUSH]();
        else if (this[EOF])
            this[MAYBE_EMIT_END]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
        return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] += 1;
        else
            this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
        else
            this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
            this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        this.emit('data', chunk);
        return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
        if (this[DESTROYED])
            return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
            opts.end = false;
        else
            opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end)
                dest.end();
        }
        else {
            // "as" here just ignores the WType, which pipes don't care about,
            // since they're only consuming from us, and writing to the dest
            this[PIPES].push(!opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC])
                defer(() => this[RESUME]());
            else
                this[RESUME]();
        }
        return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
        const p = this[PIPES].find(p => p.dest === dest);
        if (p) {
            if (this[PIPES].length === 1) {
                if (this[FLOWING] && this[DATALISTENERS] === 0) {
                    this[FLOWING] = false;
                }
                this[PIPES] = [];
            }
            else
                this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
        return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === 'data') {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
                this[RESUME]();
            }
        }
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
            super.emit('readable');
        }
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        }
        else if (ev === 'error' && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC])
                defer(() => h.call(this, this[EMITTED_ERROR]));
            else
                h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
        return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
        const ret = super.off(ev, handler);
        // if we previously had listeners, and now we don't, and we don't
        // have any pipes, then stop the flow, unless it's been explicitly
        // put in a discarded flowing state via stream.resume().
        if (ev === 'data') {
            this[DATALISTENERS] = this.listeners('data').length;
            if (this[DATALISTENERS] === 0 &&
                !this[DISCARDED] &&
                !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === 'data' || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER].length === 0 &&
            this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED])
                this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
        const data = args[0];
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' &&
            ev !== 'close' &&
            ev !== DESTROYED &&
            this[DESTROYED]) {
            return false;
        }
        else if (ev === 'data') {
            return !this[OBJECTMODE] && !data
                ? false
                : this[ASYNC]
                    ? (defer(() => this[EMITDATA](data)), true)
                    : this[EMITDATA](data);
        }
        else if (ev === 'end') {
            return this[EMITEND]();
        }
        else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED])
                return false;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        }
        else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners('error').length
                ? super.emit('error', data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]) {
            if (p.dest.write(data) === false)
                this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END])
            return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]) {
                    p.dest.write(data);
                }
                if (!this[DISCARDED])
                    super.emit('data', data);
            }
        }
        for (const p of this[PIPES]) {
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
        const buf = Object.assign([], {
            dataLength: 0,
        });
        if (!this[OBJECTMODE])
            buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', c => {
            buf.push(c);
            if (!this[OBJECTMODE])
                buf.dataLength += c.length;
        });
        await p;
        return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
        if (this[OBJECTMODE]) {
            throw new Error('cannot concat in objectMode');
        }
        const buf = await this.collect();
        return (this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength));
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
        return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
            this.on('error', er => reject(er));
            this.on('end', () => resolve());
        });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED])
            wc.close();
        if (er)
            this.emit('error', er);
        // if no error to emit, still reject pending promises
        else
            this.emit(DESTROYED);
        return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
        return isStream;
    }
}

const realpathSync = fs.realpathSync.native;
const defaultFS = {
    lstatSync: fs.lstatSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync,
    readlinkSync: fs.readlinkSync,
    realpathSync,
    promises: {
        lstat: promises.lstat,
        readdir: promises.readdir,
        readlink: promises.readlink,
        realpath: promises.realpath,
    },
};
// if they just gave us require('fs') then use our default
const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS__namespace ?
    defaultFS
    : {
        ...defaultFS,
        ...fsOption,
        promises: {
            ...defaultFS.promises,
            ...(fsOption.promises || {}),
        },
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
// windows paths are separated by either / or \
const eitherSep = /[\\\/]/;
const UNKNOWN = 0; // may not even exist, for all we know
const IFIFO = 0b0001;
const IFCHR = 0b0010;
const IFDIR = 0b0100;
const IFBLK = 0b0110;
const IFREG = 0b1000;
const IFLNK = 0b1010;
const IFSOCK = 0b1100;
const IFMT = 0b1111;
// mask to unset low 4 bits
const IFMT_UNKNOWN = ~IFMT;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED = 0b0000_0001_0000;
// set after a successful lstat()
const LSTAT_CALLED = 0b0000_0010_0000;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR = 0b0000_0100_0000;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT = 0b0000_1000_0000;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK = 0b0001_0000_0000;
// set if we know realpath() will fail
const ENOREALPATH = 0b0010_0000_0000;
const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
const TYPEMASK = 0b0011_1111_1111;
const entToType = (s) => s.isFile() ? IFREG
    : s.isDirectory() ? IFDIR
        : s.isSymbolicLink() ? IFLNK
            : s.isCharacterDevice() ? IFCHR
                : s.isBlockDevice() ? IFBLK
                    : s.isSocket() ? IFSOCK
                        : s.isFIFO() ? IFIFO
                            : UNKNOWN;
// normalize unicode path names
const normalizeCache = new Map();
const normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
        return c;
    const n = s.normalize('NFKD');
    normalizeCache.set(s, n);
    return n;
};
const normalizeNocaseCache = new Map();
const normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
        return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
class ResolveCache extends LRUCache {
    constructor() {
        super({ max: 256 });
    }
}
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */
class ChildrenCache extends LRUCache {
    constructor(maxSize = 16 * 1024) {
        super({
            maxSize,
            // parent + children
            sizeCalculation: a => a.length + 1,
        });
    }
}
const setAsCwd = Symbol('PathScurry setAsCwd');
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
class PathBase {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    /**
     * boolean indicating that this path is the current working directory
     * of the PathScurry collection that contains it.
     */
    isCWD = false;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['parentPath'] refers to the path of the
     * directory that was passed to readdir. For root entries, it's the path
     * to the entry itself.
     */
    get parentPath() {
        return (this.parent || this).fullpath();
    }
    /**
     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
     * this property refers to the *parent* path, not the path object itself.
     *
     * @deprecated
     */
    get path() {
        return this.parentPath;
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        }
        else {
            this.#fs = fsFromOption(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
        if (this.#depth !== undefined)
            return this.#depth;
        if (!this.parent)
            return (this.#depth = 0);
        return (this.#depth = this.parent.depth() + 1);
    }
    /**
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ?
            this.getRoot(rootPath).#resolveParts(dirParts)
            : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
        if (pathPart === '' || pathPart === '.') {
            return this;
        }
        if (pathPart === '..') {
            return this.parent || this;
        }
        // find the child
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
            if (p.#matchName === name) {
                return p;
            }
        }
        // didn't find it, create provisional child, since it might not
        // actually exist.  If we know the parent isn't a dir, then
        // in fact it CAN'T exist.
        const s = this.parent ? this.sep : '';
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
        const pchild = this.newChild(pathPart, UNKNOWN, {
            ...opts,
            parent: this,
            fullpath,
        });
        if (!this.canReaddir()) {
            pchild.#type |= ENOENT;
        }
        // don't have to update provisional, because if we have real children,
        // then provisional is set to children.length, otherwise a lower number
        children.push(pchild);
        return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
        if (this.isCWD)
            return '';
        if (this.#relative !== undefined) {
            return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relative = this.name);
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? '' : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
        if (this.sep === '/')
            return this.relative();
        if (this.isCWD)
            return '';
        if (this.#relativePosix !== undefined)
            return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relativePosix = this.fullpathPosix());
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? '' : '/') + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
        if (this.#fullpath !== undefined) {
            return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#fullpath = this.name);
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? '' : this.sep) + name;
        return (this.#fullpath = fp);
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
        if (this.#fullpathPosix !== undefined)
            return this.#fullpathPosix;
        if (this.sep === '/')
            return (this.#fullpathPosix = this.fullpath());
        if (!this.parent) {
            const p = this.fullpath().replace(/\\/g, '/');
            if (/^[a-z]:\//i.test(p)) {
                return (this.#fullpathPosix = `//?/${p}`);
            }
            else {
                return (this.#fullpathPosix = p);
            }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
        return (this.#fullpathPosix = fpp);
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
        return this[`is${type}`]();
    }
    getType() {
        return (this.isUnknown() ? 'Unknown'
            : this.isDirectory() ? 'Directory'
                : this.isFile() ? 'File'
                    : this.isSymbolicLink() ? 'SymbolicLink'
                        : this.isFIFO() ? 'FIFO'
                            : this.isCharacterDevice() ? 'CharacterDevice'
                                : this.isBlockDevice() ? 'BlockDevice'
                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'
                                        : 'Unknown');
        /* c8 ignore stop */
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
        return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
        return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
        return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
        return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
        return this.#type & LSTAT_CALLED ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
        if (this.#linkTarget)
            return true;
        if (!this.parent)
            return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT;
        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
            this.#type & ENOREADLINK ||
            this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
        return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
        return !this.nocase ?
            this.#matchName === normalize(n)
            : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = (await this.parent.realpath())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = this.parent.realpathSync()?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED;
        // mark all remaining provisional children as ENOENT
        for (let p = children.provisional; p < children.length; p++) {
            const c = children[p];
            if (c)
                c.#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT)
            return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children can't exist.
        // this *should* be impossible, since any children created
        // after it's been marked ENOTDIR should be marked ENOENT,
        // so it won't even get to this point.
        /* c8 ignore start */
        if (this.#type & ENOTDIR)
            return;
        /* c8 ignore stop */
        let t = this.#type;
        // this could happen if we stat a dir, then delete it,
        // then try to read it or one of its children.
        if ((t & IFMT) === IFDIR)
            t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
    }
    #readdirFail(code = '') {
        // markENOTDIR and markENOENT also set provisional=0
        if (code === 'ENOTDIR' || code === 'EPERM') {
            this.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            this.#markENOENT();
        }
        else {
            this.children().provisional = 0;
        }
    }
    #lstatFail(code = '') {
        // Windows just raises ENOENT in this case, disable for win CI
        /* c8 ignore start */
        if (code === 'ENOTDIR') {
            // already know it has a parent by this point
            const p = this.parent;
            p.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            /* c8 ignore stop */
            this.#markENOENT();
        }
    }
    #readlinkFail(code = '') {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === 'ENOENT')
            ter |= ENOENT;
        // windows gets a weird error when you try to readlink a file
        if (code === 'EINVAL' || code === 'UNKNOWN') {
            // exists, but not a symlink, we don't know WHAT it is, so remove
            // all IFMT bits.
            ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        // windows just gets ENOENT in this case.  We do cover the case,
        // just disabled because it's impossible on Windows CI
        /* c8 ignore start */
        if (code === 'ENOTDIR' && this.parent) {
            this.parent.#markENOTDIR();
        }
        /* c8 ignore stop */
    }
    #readdirAddChild(e, c) {
        return (this.#readdirMaybePromoteChild(e, c) ||
            this.#readdirAddNewChild(e, c));
    }
    #readdirAddNewChild(e, c) {
        // alloc new entry at head, so it's never provisional
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
            child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
    }
    #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
            const pchild = c[p];
            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
            if (name !== pchild.#matchName) {
                continue;
            }
            return this.#readdirPromoteChild(e, pchild, p, c);
        }
    }
    #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        // retain any other flags, but set ifmt from dirent
        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);
        // case sensitivity fixing when we learn the true name.
        if (v !== e.name)
            p.name = e.name;
        // just advance provisional index (potentially off the list),
        // otherwise we have to splice/pop it out and re-insert at head
        if (index !== c.provisional) {
            if (index === c.length - 1)
                c.pop();
            else
                c.splice(index, 1);
            c.unshift(p);
        }
        c.provisional++;
        return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        // retain any other flags, but set the ifmt
        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
            this.#type |= ENOTDIR;
        }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach(cb => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo)
                cb(null, []);
            else
                queueMicrotask(() => cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo)
                cb(null, c);
            else
                queueMicrotask(() => cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        }
        else {
            /* c8 ignore start */
            let resolve = () => { };
            /* c8 ignore stop */
            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
            try {
                for (const e of await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true,
                })) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true,
            })) {
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        }
        catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD)
            return false;
        const ifmt = IFMT & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
            return false;
        }
        /* c8 ignore stop */
        return true;
    }
    shouldWalk(dirs, walkFilter) {
        return ((this.#type & IFDIR) === IFDIR &&
            !(this.#type & ENOCHILD) &&
            !dirs.has(this) &&
            (!walkFilter || walkFilter(this)));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
        if (oldCwd === this)
            return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join('/');
            p = p.parent;
            rp.push('..');
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return node_path.win32.parse(path).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
            return this.root;
        }
        // ok, not that one, check if it matches another we know about
        for (const [compare, root] of Object.entries(this.roots)) {
            if (this.sameRoot(rootPath, compare)) {
                return (this.roots[rootPath] = root);
            }
        }
        // otherwise, have to create a new one.
        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
        // windows can (rarely) have case-sensitive filesystem, but
        // UNC and drive letters are always case-insensitive, and canonically
        // represented uppercase.
        rootPath = rootPath
            .toUpperCase()
            .replace(/\//g, '\\')
            .replace(uncDriveRegexp, '$1\\');
        return rootPath === compare;
    }
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = '/';
    /**
     * separator for generating path strings
     */
    sep = '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path.startsWith('/') ? '/' : '';
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
        return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
class PathScurryBase {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {
        this.#fs = fsFromOption(fs);
        if (cwd instanceof URL || cwd.startsWith('file://')) {
            cwd = node_url.fileURLToPath(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */
        if (nocase === undefined) {
            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
        }
        /* c8 ignore stop */
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill('..').join(joinSep),
                relativePosix: new Array(l).fill('..').join('/'),
                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path = this.cwd) {
        if (typeof path === 'string') {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else {
            const p = await entry.readdir();
            return withFileTypes ? p : p.map(e => e.name);
        }
    }
    readdirSync(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else if (withFileTypes) {
            return entry.readdirSync();
        }
        else {
            return entry.readdirSync().map(e => e.name);
        }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const walk = (dir, cb) => {
            dirs.add(dir);
            dir.readdirCB((er, entries) => {
                /* c8 ignore start */
                if (er) {
                    return cb(er);
                }
                /* c8 ignore stop */
                let len = entries.length;
                if (!len)
                    return cb();
                const next = () => {
                    if (--len === 0) {
                        cb();
                    }
                };
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        results.push(withFileTypes ? e : e.fullpath());
                    }
                    if (follow && e.isSymbolicLink()) {
                        e.realpath()
                            .then(r => (r?.isUnknown() ? r.lstat() : r))
                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    }
                    else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        }
                        else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej) => {
            walk(start, er => {
                /* c8 ignore start */
                if (er)
                    return rej(er);
                /* c8 ignore stop */
                res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false) => {
                    /* c8 ignore start */
                    if (er)
                        return results.emit('error', er);
                    /* c8 ignore stop */
                    if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries) {
                            if (e.isSymbolicLink()) {
                                promises.push(e
                                    .realpath()
                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(() => onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries) {
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries) {
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once('drain', process);
                    }
                    else if (!sync) {
                        process();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries) {
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync())))
                            continue;
                        if (r.isUnknown())
                            r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing)
                results.once('drain', process);
        };
        process();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
    }
}
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '\\';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path.win32, '\\', { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return node_path.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
    }
}
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '/';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path.posix, '/', { ...opts, nocase });
        this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
        return '/';
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return p.startsWith('/');
    }
}
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
    }
}
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
process.platform === 'win32' ? PathWin32 : PathPosix;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
const PathScurry = process.platform === 'win32' ? PathScurryWin32
    : process.platform === 'darwin' ? PathScurryDarwin
        : PathScurryPosix;

// this is just a very light wrapper around 2 arrays with an offset index
const isPatternList = (pl) => pl.length >= 1;
const isGlobList = (gl) => gl.length >= 1;
/**
 * An immutable-ish view on an array of glob parts and their parsed
 * results
 */
class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
            throw new TypeError('empty pattern list');
        }
        if (!isGlobList(globList)) {
            throw new TypeError('empty glob list');
        }
        if (globList.length !== patternList.length) {
            throw new TypeError('mismatched pattern list and glob list lengths');
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
            throw new TypeError('index out of range');
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        // normalize root entries of absolute patterns on initial creation.
        if (this.#index === 0) {
            // c: => ['c:/']
            // C:/ => ['C:/']
            // C:/x => ['C:/', 'x']
            // //host/share => ['//host/share/']
            // //host/share/ => ['//host/share/']
            // //host/share/x => ['//host/share/', 'x']
            // /etc => ['/', 'etc']
            // / => ['/']
            if (this.isUNC()) {
                // '' / '' / 'host' / 'share'
                const [p0, p1, p2, p3, ...prest] = this.#patternList;
                const [g0, g1, g2, g3, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = [p0, p1, p2, p3, ''].join('/');
                const g = [g0, g1, g2, g3, ''].join('/');
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
            else if (this.isDrive() || this.isAbsolute()) {
                const [p1, ...prest] = this.#patternList;
                const [g1, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = p1 + '/';
                const g = g1 + '/';
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
        }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
        return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
        return typeof this.#patternList[this.#index] === 'string';
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
        return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
        return (this.#globString =
            this.#globString ||
                (this.#index === 0 ?
                    this.isAbsolute() ?
                        this.#globList[0] + this.#globList.slice(1).join('/')
                        : this.#globList.join('/')
                    : this.#globList.slice(this.#index).join('/')));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
        return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
        if (this.#rest !== undefined)
            return this.#rest;
        if (!this.hasMore())
            return (this.#rest = null);
        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== undefined ?
            this.#isUNC
            : (this.#isUNC =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    pl[0] === '' &&
                    pl[1] === '' &&
                    typeof pl[2] === 'string' &&
                    !!pl[2] &&
                    typeof pl[3] === 'string' &&
                    !!pl[3]);
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== undefined ?
            this.#isDrive
            : (this.#isDrive =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    this.length > 1 &&
                    typeof pl[0] === 'string' &&
                    /^[a-z]:$/i.test(pl[0]));
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== undefined ?
            this.#isAbsolute
            : (this.#isAbsolute =
                (pl[0] === '' && pl.length > 1) ||
                    this.isDrive() ||
                    this.isUNC());
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
        const p = this.#patternList[0];
        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?
            p
            : '';
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
        return !(this.#index === 0 ||
            !this.isGlobstar() ||
            !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
            return false;
        this.#followGlobstar = false;
        return true;
    }
}

// give it a pattern, and it'll be able to tell you if
// a given path should be ignored.
// Ignoring a path ignores its children if the pattern ends in /**
// Ignores are always parsed in dot:true mode
const defaultPlatform$1 = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * Class used to process ignored patterns
 */
class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform$1, }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
            dot: true,
            nobrace,
            nocase,
            noext,
            noglobstar,
            optimizationLevel: 2,
            platform,
            nocomment: true,
            nonegate: true,
        };
        for (const ign of ignored)
            this.add(ign);
    }
    add(ign) {
        // this is a little weird, but it gives us a clean set of optimized
        // minimatch matchers, without getting tripped up if one of them
        // ends in /** inside a brace section, and it's only inefficient at
        // the start of the walk, not along it.
        // It'd be nice if the Pattern class just had a .test() method, but
        // handling globstars is a bit of a pita, and that code already lives
        // in minimatch anyway.
        // Another way would be if maybe Minimatch could take its set/globParts
        // as an option, and then we could at least just use Pattern to test
        // for absolute-ness.
        // Yet another way, Minimatch could take an array of glob strings, and
        // a cwd option, and do the right thing.
        const mm = new Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
            const parsed = mm.set[i];
            const globParts = mm.globParts[i];
            /* c8 ignore start */
            if (!parsed || !globParts) {
                throw new Error('invalid pattern object');
            }
            // strip off leading ./ portions
            // https://github.com/isaacs/node-glob/issues/570
            while (parsed[0] === '.' && globParts[0] === '.') {
                parsed.shift();
                globParts.shift();
            }
            /* c8 ignore stop */
            const p = new Pattern(parsed, globParts, 0, this.platform);
            const m = new Minimatch(p.globString(), this.mmopts);
            const children = globParts[globParts.length - 1] === '**';
            const absolute = p.isAbsolute();
            if (absolute)
                this.absolute.push(m);
            else
                this.relative.push(m);
            if (children) {
                if (absolute)
                    this.absoluteChildren.push(m);
                else
                    this.relativeChildren.push(m);
            }
        }
    }
    ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || '.';
        const relatives = `${relative}/`;
        for (const m of this.relative) {
            if (m.match(relative) || m.match(relatives))
                return true;
        }
        for (const m of this.absolute) {
            if (m.match(fullpath) || m.match(fullpaths))
                return true;
        }
        return false;
    }
    childrenIgnored(p) {
        const fullpath = p.fullpath() + '/';
        const relative = (p.relative() || '.') + '/';
        for (const m of this.relativeChildren) {
            if (m.match(relative))
                return true;
        }
        for (const m of this.absoluteChildren) {
            if (m.match(fullpath))
                return true;
        }
        return false;
    }
}

// synchronous utility for filtering entries and calculating subwalks
/**
 * A cache of which patterns have been processed for a given Path
 */
class HasWalkedCache {
    store;
    constructor(store = new Map()) {
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
            cached.add(pattern.globString());
        else
            this.store.set(fullpath, new Set([pattern.globString()]));
    }
}
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */
class MatchRecord {
    store = new Map();
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [...this.store.entries()].map(([path, n]) => [
            path,
            !!(n & 2),
            !!(n & 1),
        ]);
    }
}
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */
class SubWalks {
    store = new Map();
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find(p => p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        }
        else
            this.store.set(target, [pattern]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */
        if (!subs) {
            throw new Error('attempting to walk unknown path');
        }
        /* c8 ignore stop */
        return subs;
    }
    entries() {
        return this.keys().map(k => [k, this.store.get(k)]);
    }
    keys() {
        return [...this.store.keys()].filter(t => t.canReaddir());
    }
}
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */
class Processor {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache =
            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map(p => [target, p]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet) {
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === '/' && this.opts.root !== undefined ?
                    this.opts.root
                    : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                }
                else {
                    pattern = rest;
                }
            }
            if (t.isENOENT())
                continue;
            let p;
            let rest;
            let changed = false;
            while (typeof (p = pattern.pattern()) === 'string' &&
                (rest = pattern.rest())) {
                const c = t.resolve(p);
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                    continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === 'string') {
                // must not be final entry, otherwise we would have
                // concatenated it earlier.
                const ifDir = p === '..' || p === '' || p === '.';
                this.matches.add(t.resolve(p), absolute, ifDir);
                continue;
            }
            else if (p === GLOBSTAR) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() ||
                    this.follow ||
                    pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === '' || rp === '.');
                }
                else {
                    if (rp === '..') {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */
                        const tp = t.parent || t;
                        /* c8 ignore stop */
                        if (!rrest)
                            this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            }
            else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries) {
            for (const pattern of patterns) {
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === GLOBSTAR) {
                    results.testGlobstar(e, pattern, rest, absolute);
                }
                else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                }
                else {
                    results.testString(e, p, rest, absolute);
                }
            }
        }
        return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith('.')) {
            if (!pattern.hasMore()) {
                this.matches.add(e, absolute, false);
            }
            if (e.canReaddir()) {
                // if we're in follow mode or it's not a symlink, just keep
                // testing the same pattern. If there's more after the globstar,
                // then this symlink consumes the globstar. If not, then we can
                // follow at most ONE symlink along the way, so we mark it, which
                // also checks to ensure that it wasn't already marked.
                if (this.follow || !e.isSymbolicLink()) {
                    this.subwalks.add(e, pattern);
                }
                else if (e.isSymbolicLink()) {
                    if (rest && pattern.checkFollowGlobstar()) {
                        this.subwalks.add(e, rest);
                    }
                    else if (pattern.markFollowGlobstar()) {
                        this.subwalks.add(e, pattern);
                    }
                }
            }
        }
        // if the NEXT thing matches this entry, then also add
        // the rest.
        if (rest) {
            const rp = rest.pattern();
            if (typeof rp === 'string' &&
                // dots and empty were handled already
                rp !== '..' &&
                rp !== '' &&
                rp !== '.') {
                this.testString(e, rp, rest.rest(), absolute);
            }
            else if (rp === '..') {
                /* c8 ignore start */
                const ep = e.parent || e;
                /* c8 ignore stop */
                this.subwalks.add(ep, rest);
            }
            else if (rp instanceof RegExp) {
                this.testRegExp(e, rp, rest.rest(), absolute);
            }
        }
    }
    testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
    testString(e, p, rest, absolute) {
        // should never happen?
        if (!e.isNamed(p))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
}

/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
const makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new Ignore([ignore], opts)
    : Array.isArray(ignore) ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
            this.#ignore = makeIgnore(opts.ignore ?? [], opts);
            if (!this.includeChildMatches &&
                typeof this.#ignore.add !== 'function') {
                const m = 'cannot ignore child matches, ignore lacks add() method.';
                throw new Error(m);
            }
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return (e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)) ?
            e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        // we know we have an ignore if this is false, but TS doesn't
        if (!this.includeChildMatches && this.#ignore?.add) {
            const ign = `${e.relativePosix()}/**`;
            this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?
                '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const children = t.readdirSync();
            this.walkCB3Sync(t, children, processor, next);
        }
        next();
    }
    walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2Sync(target, patterns, processor.child(), next);
        }
        next();
    }
}
class GlobWalker extends GlobUtil {
    matches = new Set();
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
    }
    matchEmit(e) {
        this.matches.add(e);
    }
    async walk() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            await this.path.lstat();
        }
        await new Promise((res, rej) => {
            this.walkCB(this.path, this.patterns, () => {
                if (this.signal?.aborted) {
                    rej(this.signal.reason);
                }
                else {
                    res(this.matches);
                }
            });
        });
        return this.matches;
    }
    walkSync() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        // nothing for the callback to do, because this never pauses
        this.walkCBSync(this.path, this.patterns, () => {
            if (this.signal?.aborted)
                throw this.signal.reason;
        });
        return this.matches;
    }
}
class GlobStream extends GlobUtil {
    results;
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
        this.results = new Minipass({
            signal: this.signal,
            objectMode: true,
        });
        this.results.on('drain', () => this.resume());
        this.results.on('resume', () => this.resume());
    }
    matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
            this.pause();
    }
    stream() {
        const target = this.path;
        if (target.isUnknown()) {
            target.lstat().then(() => {
                this.walkCB(target, this.patterns, () => this.results.end());
            });
        }
        else {
            this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
    }
    streamSync() {
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
    }
}

// if no process global, just call it linux.
// so we default to case-sensitive, / separators
const defaultPlatform = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * An object that can perform glob pattern traversals.
 */
class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
        /* c8 ignore start */
        if (!opts)
            throw new TypeError('glob options required');
        /* c8 ignore stop */
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
            this.cwd = '';
        }
        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
            opts.cwd = node_url.fileURLToPath(opts.cwd);
        }
        this.cwd = opts.cwd || '';
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth =
            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== undefined) {
            throw new Error('cannot set absolute and withFileTypes:true');
        }
        if (typeof pattern === 'string') {
            pattern = [pattern];
        }
        this.windowsPathsNoEscape =
            !!opts.windowsPathsNoEscape ||
                opts.allowWindowsEscape ===
                    false;
        if (this.windowsPathsNoEscape) {
            pattern = pattern.map(p => p.replace(/\\/g, '/'));
        }
        if (this.matchBase) {
            if (opts.noglobstar) {
                throw new TypeError('base matching requires globstar');
            }
            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
            this.scurry = opts.scurry;
            if (opts.nocase !== undefined &&
                opts.nocase !== opts.scurry.nocase) {
                throw new Error('nocase option contradicts provided scurry option');
            }
        }
        else {
            const Scurry = opts.platform === 'win32' ? PathScurryWin32
                : opts.platform === 'darwin' ? PathScurryDarwin
                    : opts.platform ? PathScurryPosix
                        : PathScurry;
            this.scurry = new Scurry(this.cwd, {
                nocase: opts.nocase,
                fs: opts.fs,
            });
        }
        this.nocase = this.scurry.nocase;
        // If you do nocase:true on a case-sensitive file system, then
        // we need to use regexps instead of strings for non-magic
        // path portions, because statting `aBc` won't return results
        // for the file `AbC` for example.
        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
        const mmo = {
            // default nocase based on platform
            ...opts,
            dot: this.dot,
            matchBase: this.matchBase,
            nobrace: this.nobrace,
            nocase: this.nocase,
            nocaseMagicOnly,
            nocomment: true,
            noext: this.noext,
            nonegate: true,
            optimizationLevel: 2,
            platform: this.platform,
            windowsPathsNoEscape: this.windowsPathsNoEscape,
            debug: !!this.opts.debug,
        };
        const mms = this.pattern.map(p => new Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
            set[0].push(...m.set);
            set[1].push(...m.globParts);
            return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
            const g = globParts[i];
            /* c8 ignore start */
            if (!g)
                throw new Error('invalid pattern object');
            /* c8 ignore stop */
            return new Pattern(set, g, 0, this.platform);
        });
    }
    async walk() {
        // Walkers always return array of Path objects, so we just have to
        // coerce them into the right shape.  It will have already called
        // realpath() if the option was set to do so, so we know that's cached.
        // start out knowing the cwd, at least
        return [
            ...(await new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walk()),
        ];
    }
    walkSync() {
        return [
            ...new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walkSync(),
        ];
    }
    stream() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).stream();
    }
    streamSync() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
        return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
        return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}

/**
 * Return true if the patterns provided contain any magic glob characters,
 * given the options provided.
 *
 * Brace expansion is not considered "magic" unless the `magicalBraces` option
 * is set, as brace expansion just turns one string into an array of strings.
 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
 * `'xby'` both do not contain any magic glob characters, and it's treated the
 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
 * is in the options, brace expansion _is_ treated as a pattern having magic.
 */
const hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
        pattern = [pattern];
    }
    for (const p of pattern) {
        if (new Minimatch(p, options).hasMagic())
            return true;
    }
    return false;
};

function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
}
// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
const streamSync = globStreamSync;
const stream = Object.assign(globStream, { sync: globStreamSync });
const iterateSync = globIterateSync;
const iterate = Object.assign(globIterate, {
    sync: globIterateSync,
});
const sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync,
});
const glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob,
    hasMagic,
    escape,
    unescape,
});
glob.glob = glob;

const SeveritySchema = _enum(["error", "warning", "info", "hint"]);
const FilesConfigSchema = object({
    include: array(string()).optional().describe("Additional glob patterns to include beyond defaults (e.g., ['**/*.xml.erb', 'custom/**/*.html'])"),
    exclude: array(string()).optional().describe("Glob patterns to exclude (e.g., ['node_modules/**/*', 'vendor/**/*', '**/*.html.erb'])"),
}).strict().optional();
const RuleConfigBaseSchema = object({
    enabled: boolean().optional().describe("Whether the rule is enabled"),
    severity: SeveritySchema.optional().describe("Severity level for the rule"),
    include: array(string()).optional().describe("Additional glob patterns to include for this rule (additive, ignored when 'only' is present)"),
    only: array(string()).optional().describe("Only apply this rule to files matching these glob patterns (overrides all 'include' patterns)"),
    exclude: array(string()).optional().describe("Don't apply this rule to files matching these glob patterns"),
});
RuleConfigBaseSchema.optional();
const LinterConfigSchema = object({
    enabled: boolean().optional().describe("Whether the linter is enabled"),
    include: array(string()).optional().describe("Additional glob patterns to include beyond defaults (e.g., ['**/*.xml.erb', 'custom/**/*.html'])"),
    exclude: array(string()).optional().describe("Glob patterns to exclude from linting"),
    rules: record(string(), RuleConfigBaseSchema).optional().describe("Per-rule configuration"),
}).strict().optional();
const RewriterConfigSchema = object({
    pre: array(string()).optional().describe("Pre-format rewriters to run (in order) before formatting the AST"),
    post: array(string()).optional().describe("Post-format rewriters to run (in order) after formatting the document"),
}).strict().optional();
const FormatterConfigSchema = object({
    enabled: boolean().optional().describe("Whether the formatter is enabled"),
    include: array(string()).optional().describe("Additional glob patterns to include beyond defaults (e.g., ['**/*.xml.erb', 'custom/**/*.html'])"),
    exclude: array(string()).optional().describe("Glob patterns to exclude from formatting"),
    indentWidth: number().int().positive().optional().describe("Number of spaces per indentation level"),
    maxLineLength: number().int().positive().optional().describe("Maximum line length before wrapping"),
    rewriter: RewriterConfigSchema.describe("Rewriter configuration for pre and post-format transformations"),
}).strict().optional();
const HerbConfigSchema = object({
    version: string().describe("Configuration file version"),
    files: FilesConfigSchema.describe("Top-level file configuration"),
    linter: LinterConfigSchema,
    formatter: FormatterConfigSchema,
}).strict();

function isObject(item) {
    return item !== null && typeof item === 'object' && !Array.isArray(item);
}
/**
 * Deep merge two objects
 * @param target - The base object (defaults)
 * @param source - The object to merge in (user config)
 * @returns Merged object
 */
function deepMerge(target, source) {
    const output = { ...target };
    for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            const sourceValue = source[key];
            const targetValue = target[key];
            if (sourceValue === undefined) {
                continue;
            }
            if (Array.isArray(sourceValue)) {
                if (key === 'include' && Array.isArray(targetValue)) {
                    output[key] = [...targetValue, ...sourceValue];
                }
                else {
                    output[key] = [...sourceValue];
                }
                continue;
            }
            if (isObject(sourceValue) && isObject(targetValue)) {
                output[key] = deepMerge(targetValue, sourceValue);
                continue;
            }
            output[key] = sourceValue;
        }
    }
    return output;
}

var version$2 = "0.8.2";
var packageJson = {
	version: version$2};

var configTemplate = "# This file configures Herb for your project and team.\n# Settings here take precedence over individual editor preferences.\n#\n# Herb is a suite of tools for HTML+ERB templates including:\n# - Linter: Validates templates and enforces best practices\n# - Formatter: Auto-formats templates with intelligent indentation\n# - Language Server: Provides IDE support (VS Code, Zed, Neovim, etc.)\n#\n# Website: https://herb-tools.dev\n# Configuration: https://herb-tools.dev/configuration\n# GitHub Repo: https://github.com/marcoroth/herb\n#\n\nversion: 0.8.2\n\n# files:\n#   # Additional patterns beyond the defaults (**.html, **.rhtml, **.html.erb, etc.)\n#   include:\n#     - '**/*.xml.erb'\n#     - 'custom/**/*.html'\n#\n#   # Patterns to exclude (can exclude defaults too)\n#   exclude:\n#     - 'public/**/*'\n#     - 'tmp/**/*'\n\nlinter:\n  enabled: true\n\n  # # Additional patterns beyond the defaults for linting\n  # include:\n  #   - '**/*.xml.erb'\n  #\n  # # Patterns to exclude from linting\n  # exclude:\n  #   - 'app/views/admin/**/*'\n\n  # rules:\n  #   erb-no-extra-newline:\n  #     enabled: false\n  #\n  #   # Rules can have 'include', 'only', and 'exclude' patterns\n  #   some-rule:\n  #     # Additional patterns to check (additive, ignored when 'only' is present)\n  #     include:\n  #       - 'app/components/**/*'\n  #     # Don't apply this rule to files matching these patterns\n  #     exclude:\n  #       - 'app/views/admin/**/*'\n  #\n  #   another-rule:\n  #     # Only apply this rule to files matching these patterns (overrides all 'include')\n  #     only:\n  #       - 'app/views/**/*'\n  #     # Exclude still applies even with 'only'\n  #     exclude:\n  #       - 'app/views/admin/**/*'\n\nformatter:\n  enabled: false\n  indentWidth: 2\n  maxLineLength: 80\n\n  # # Additional patterns beyond the defaults for formatting\n  # include:\n  #   - '**/*.xml.erb'\n  #\n  # # Patterns to exclude from formatting\n  # exclude:\n  #   - 'app/views/admin/**/*'\n\n  # # Rewriters modify templates during formatting\n  # rewriter:\n  #   # Pre-format rewriters (modify AST before formatting)\n  #   pre:\n  #     - tailwind-class-sorter\n  #   # Post-format rewriters (modify formatted output string)\n  #   post: []\n";

const DEFAULT_VERSION = packageJson.version;
class Config {
    static configPath = ".herb.yml";
    static PROJECT_INDICATORS = [
        '.git',
        'Gemfile',
        'package.json',
        'Rakefile',
        'README.md',
        '*.gemspec',
        'config/application.rb'
    ];
    path;
    config;
    constructor(projectPath, config) {
        this.path = Config.configPathFromProjectPath(projectPath);
        this.config = config;
    }
    get projectPath() {
        return path$1$1.dirname(this.path);
    }
    get version() {
        return this.config.version;
    }
    get options() {
        return {
            files: this.config.files,
            linter: this.config.linter,
            formatter: this.config.formatter
        };
    }
    get linter() {
        return this.config.linter;
    }
    get formatter() {
        return this.config.formatter;
    }
    toJSON() {
        return JSON.stringify(this.config, null, "  ");
    }
    /**
     * Check if the linter is enabled.
     * @returns true if linter is enabled (default), false if explicitly disabled
     */
    get isLinterEnabled() {
        return this.config.linter?.enabled ?? Config.getDefaultConfig().linter?.enabled ?? true;
    }
    /**
     * Check if the formatter is enabled.
     * @returns true if formatter is enabled (default), false if explicitly disabled
     */
    get isFormatterEnabled() {
        return this.config.formatter?.enabled ?? Config.getDefaultConfig().formatter?.enabled ?? true;
    }
    /**
     * Check if a specific rule is disabled.
     * @param ruleName - The name of the rule to check
     * @returns true if the rule is explicitly disabled, false otherwise
     */
    isRuleDisabled(ruleName) {
        return this.config.linter?.rules?.[ruleName]?.enabled === false;
    }
    /**
     * Check if a specific rule is enabled.
     * @param ruleName - The name of the rule to check
     * @returns true if the rule is enabled, false otherwise
     */
    isRuleEnabled(ruleName) {
        return !this.isRuleDisabled(ruleName);
    }
    /**
     * Get the files configuration for a specific tool.
     * Tool-specific file config takes precedence over top-level config.
     * Include patterns are additive (defaults are already merged in this.config).
     * @param tool - The tool to get files config for ('linter' or 'formatter')
     * @returns The merged files configuration
     */
    getFilesConfigForTool(tool) {
        const toolConfig = tool === 'linter' ? this.config.linter : this.config.formatter;
        const topLevelFiles = this.config.files || {};
        const topLevelInclude = topLevelFiles.include || [];
        const toolInclude = toolConfig?.include || [];
        const include = [...topLevelInclude, ...toolInclude];
        const exclude = toolConfig?.exclude || topLevelFiles.exclude || [];
        return {
            include,
            exclude
        };
    }
    /**
     * Get the files configuration for the linter.
     * Linter-specific file config takes precedence over top-level config.
     * @returns The merged files configuration for linter
     */
    get filesConfigForLinter() {
        return this.getFilesConfigForTool('linter');
    }
    /**
     * Get the files configuration for the formatter.
     * Formatter-specific file config takes precedence over top-level config.
     * @returns The merged files configuration for formatter
     */
    get filesConfigForFormatter() {
        return this.getFilesConfigForTool('formatter');
    }
    /**
     * Find files for a specific tool based on its configuration.
     * Uses include patterns from config, applies exclude patterns.
     * @param tool - The tool to find files for ('linter' or 'formatter')
     * @param cwd - The directory to search from (defaults to project path)
     * @returns Promise resolving to array of absolute file paths
     */
    async findFilesForTool(tool, cwd) {
        const searchDir = cwd || path$1$1.dirname(this.path);
        const filesConfig = this.getFilesConfigForTool(tool);
        const patterns = filesConfig.include || [];
        if (patterns.length === 0) {
            return [];
        }
        return await glob(patterns, {
            cwd: searchDir,
            absolute: true,
            nodir: true,
            ignore: filesConfig.exclude || []
        });
    }
    /**
     * Find files for the linter based on linter configuration.
     * @param cwd - The directory to search from (defaults to project path)
     * @returns Promise resolving to array of absolute file paths
     */
    async findFilesForLinter(cwd) {
        return this.findFilesForTool('linter', cwd);
    }
    /**
     * Find files for the formatter based on formatter configuration.
     * @param cwd - The directory to search from (defaults to project path)
     * @returns Promise resolving to array of absolute file paths
     */
    async findFilesForFormatter(cwd) {
        return this.findFilesForTool('formatter', cwd);
    }
    /**
     * Check if a file path is excluded by glob patterns.
     * @param filePath - The file path to check
     * @param excludePatterns - Array of glob patterns to check against
     * @returns true if the path matches any exclude pattern
     */
    isPathExcluded(filePath, excludePatterns) {
        if (!excludePatterns || excludePatterns.length === 0) {
            return false;
        }
        return excludePatterns.some(pattern => minimatch(filePath, pattern));
    }
    /**
     * Check if a file path matches any of the include patterns.
     * @param filePath - The file path to check
     * @param includePatterns - Array of glob patterns to check against
     * @returns true if the path matches any include pattern, or true if no patterns specified
     */
    isPathIncluded(filePath, includePatterns) {
        if (!includePatterns || includePatterns.length === 0) {
            return true;
        }
        return includePatterns.some(pattern => minimatch(filePath, pattern));
    }
    /**
     * Check if a tool (linter or formatter) is enabled for a specific file path.
     * Respects both the tool's enabled state and its exclude patterns.
     * @param filePath - The file path to check
     * @param tool - The tool to check ('linter' or 'formatter')
     * @returns true if the tool is enabled for this path
     */
    isEnabledForPath(filePath, tool) {
        const isEnabled = tool === 'linter' ? this.isLinterEnabled : this.isFormatterEnabled;
        if (!isEnabled) {
            return false;
        }
        const toolConfig = tool === 'linter' ? this.config.linter : this.config.formatter;
        const excludePatterns = toolConfig?.exclude || [];
        return !this.isPathExcluded(filePath, excludePatterns);
    }
    /**
     * Check if the linter is enabled for a specific file path.
     * Respects both linter.enabled and linter.exclude patterns.
     * @param filePath - The file path to check
     * @returns true if the linter is enabled for this path
     */
    isLinterEnabledForPath(filePath) {
        return this.isEnabledForPath(filePath, 'linter');
    }
    /**
     * Check if the formatter is enabled for a specific file path.
     * Respects both formatter.enabled and formatter.exclude patterns.
     * @param filePath - The file path to check
     * @returns true if the formatter is enabled for this path
     */
    isFormatterEnabledForPath(filePath) {
        return this.isEnabledForPath(filePath, 'formatter');
    }
    /**
     * Check if a specific rule is enabled for a specific file path.
     * Respects linter.enabled, linter.exclude, rule.enabled, rule.include, rule.only, and rule.exclude patterns.
     *
     * Pattern precedence:
     * - If rule.only is specified: Only files matching 'only' patterns (ignores all 'include' patterns)
     * - If rule.only is NOT specified: Files matching 'include' patterns (if specified, additive)
     * - rule.exclude is always applied regardless of 'only' or 'include'
     *
     * @param ruleName - The name of the rule to check
     * @param filePath - The file path to check
     * @returns true if the rule is enabled for this path
     */
    isRuleEnabledForPath(ruleName, filePath) {
        if (!this.isLinterEnabledForPath(filePath)) {
            return false;
        }
        if (this.isRuleDisabled(ruleName)) {
            return false;
        }
        const ruleConfig = this.config.linter?.rules?.[ruleName];
        const ruleOnlyPatterns = ruleConfig?.only || [];
        const ruleIncludePatterns = ruleConfig?.include || [];
        const ruleExcludePatterns = ruleConfig?.exclude || [];
        if (ruleOnlyPatterns.length > 0) {
            if (!this.isPathIncluded(filePath, ruleOnlyPatterns)) {
                return false;
            }
        }
        else if (ruleIncludePatterns.length > 0) {
            if (!this.isPathIncluded(filePath, ruleIncludePatterns)) {
                return false;
            }
        }
        return !this.isPathExcluded(filePath, ruleExcludePatterns);
    }
    /**
     * Apply configured severity overrides to a lint offense.
     * Returns the configured severity if set, otherwise returns the original severity.
     */
    getConfiguredSeverity(ruleName, defaultSeverity) {
        const ruleConfig = this.config.linter?.rules?.[ruleName];
        if (ruleConfig && ruleConfig.severity) {
            return ruleConfig.severity;
        }
        return defaultSeverity;
    }
    /**
     * Apply severity overrides from config to an array of offenses.
     * Each offense must have a `rule` and `severity` property.
     */
    applySeverityOverrides(offenses) {
        if (!this.config.linter?.rules) {
            return offenses;
        }
        return offenses.map(offense => {
            const ruleConfig = this.config.linter?.rules?.[offense.rule];
            if (ruleConfig && ruleConfig.severity) {
                return { ...offense, severity: ruleConfig.severity };
            }
            return offense;
        });
    }
    static configPathFromProjectPath(projectPath) {
        return path$1$1.join(projectPath, this.configPath);
    }
    /**
     * Get the default file patterns that Herb recognizes.
     * These are the default extensions/patterns used when no custom patterns are specified.
     * @returns Array of glob patterns for HTML+ERB files
     */
    static getDefaultFilePatterns() {
        return this.getDefaultConfig().files?.include || [];
    }
    /**
     * Check if a .herb.yml config file exists at the given path.
     *
     * @param pathOrFile - Path to directory or explicit config file path
     * @returns True if .herb.yml exists at the location, false otherwise
     */
    static exists(pathOrFile) {
        try {
            let configPath;
            if (pathOrFile.endsWith(this.configPath)) {
                configPath = pathOrFile;
            }
            else {
                configPath = this.configPathFromProjectPath(pathOrFile);
            }
            require('fs').statSync(configPath);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Read raw YAML content from a config file.
     * Handles both explicit .herb.yml paths and directory paths.
     *
     * @param pathOrFile - Path to .herb.yml file or directory containing it
     * @returns string - The raw YAML content
     */
    static readRawYaml(pathOrFile) {
        const configPath = pathOrFile.endsWith(this.configPath)
            ? pathOrFile
            : this.configPathFromProjectPath(pathOrFile);
        return require('fs').readFileSync(configPath, 'utf-8');
    }
    /**
     * Load Herb configuration from a file or directory
     *
     * This is the main entry point for loading configuration. It:
     * 1. Discovers the config file by walking up the directory tree
     * 2. Reads and validates the config
     * 3. Merges with defaults for a fully resolved config
     * 4. Auto-creates default config if createIfMissing option is true
     * 5. Prints informative messages to console
     *
     * @param pathOrFile - File path, directory path, or any path to start search from
     * @param options - Loading options
     * @returns Promise<Config> - Fully resolved config instance
     */
    static async load(pathOrFile, options = {}) {
        const { silent = false, version = DEFAULT_VERSION, createIfMissing = false, exitOnError = false } = options;
        try {
            if (pathOrFile.endsWith(this.configPath)) {
                return await this.loadFromExplicitPath(pathOrFile, silent, version, exitOnError);
            }
            const { configPath, projectRoot } = await this.findConfigFile(pathOrFile);
            if (configPath) {
                return await this.loadFromPath(configPath, projectRoot, silent, version, exitOnError);
            }
            else if (createIfMissing) {
                return await this.createDefaultConfig(projectRoot, silent, version);
            }
            else {
                const defaults = this.getDefaultConfig(version);
                return new Config(projectRoot, defaults);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                throw error;
            }
            throw new Error(`Failed to load Herb configuration: ${error}`);
        }
    }
    /**
     * Load config for editor/language server use (silent mode, no file creation).
     * This is a convenience method for the common pattern used in editors.
     *
     * @param pathOrFile - Directory path or explicit .herb.yml file path
     * @param version - Optional version string (defaults to package version)
     * @returns Config instance or throws on errors
     */
    static async loadForEditor(pathOrFile, version) {
        return await this.load(pathOrFile, {
            silent: true,
            version,
            createIfMissing: false,
            exitOnError: false
        });
    }
    /**
     * Load config for CLI use (may create file, show errors).
     * This is a convenience method for the common pattern used in CLI tools.
     *
     * @param pathOrFile - Directory path or explicit .herb.yml file path
     * @param version - Optional version string (defaults to package version)
     * @param createIfMissing - Whether to create config if missing (default: false)
     * @returns Config instance or throws on errors
     */
    static async loadForCLI(pathOrFile, version, createIfMissing = false) {
        return await this.load(pathOrFile, {
            silent: false,
            version,
            createIfMissing,
            exitOnError: false
        });
    }
    /**
     * Mutate an existing config file by reading it, validating, merging with a mutation, and writing back.
     * This preserves the user's YAML file structure and only writes what's explicitly configured.
     *
     * @param configPath - Path to the .herb.yml file
     * @param mutation - Partial config to merge (e.g., { linter: { rules: { "rule-name": { enabled: false } } } })
     * @returns Promise<void>
     *
     * @example
     * // Disable a rule in .herb.yml
     * await Config.mutateConfigFile('/path/to/.herb.yml', {
     *   linter: {
     *     rules: {
     *       'html-img-require-alt': { enabled: false }
     *     }
     *   }
     * })
     */
    static async mutateConfigFile(configPath, mutation) {
        let yamlContent;
        try {
            const existingContent = await fs.promises.readFile(configPath, 'utf-8');
            if (Object.keys(mutation).length > 0) {
                const document = parseDocument(existingContent);
                const validation = HerbConfigSchema.safeParse(document.toJSON());
                if (!validation.success) {
                    const readableError = fromZodError(validation.error);
                    throw new Error(`Invalid config file at ${configPath}: ${readableError.message}`);
                }
                if (document.contents) {
                    this.applyMutationToDocument(document.contents, mutation);
                    if (!document.get('version')) {
                        document.set('version', DEFAULT_VERSION);
                    }
                }
                yamlContent = document.toString();
            }
            else {
                yamlContent = existingContent;
            }
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
            if (Object.keys(mutation).length === 0) {
                yamlContent = configTemplate.replace(/^version:\s*[\d.]+$/m, `version: ${DEFAULT_VERSION}`);
            }
            else {
                const defaults = this.getDefaultConfig(DEFAULT_VERSION);
                const updated = deepMerge(defaults, mutation);
                yamlContent = stringify(updated, {
                    indent: 2,
                    lineWidth: 0,
                    blockQuote: 'literal'
                });
                yamlContent = this.addYamlSpacing(yamlContent);
            }
        }
        await fs.promises.writeFile(configPath, yamlContent, 'utf-8');
    }
    /**
     * Apply mutation to YAML content and return the mutated string (synchronous)
     * Useful for code actions and other scenarios where you need the mutated content
     * without writing to disk.
     *
     * @param yamlContent - The original YAML content (with comments)
     * @param mutation - The mutation to apply
     * @returns The mutated YAML content (with comments preserved)
     */
    static applyMutationToYamlString(yamlContent, mutation) {
        const document = parseDocument(yamlContent);
        if (document.contents) {
            this.applyMutationToDocument(document.contents, mutation);
        }
        return document.toString();
    }
    /**
     * Create a new config file content with a mutation applied
     * Uses the default template with comments and applies the mutation
     *
     * @param mutation - The mutation to apply to the default config
     * @param version - The version to use (defaults to package version)
     * @returns The config file content as a YAML string
     */
    static createConfigYamlString(mutation, version = DEFAULT_VERSION) {
        let yamlContent = configTemplate.replace(/^version:\s*[\d.]+$/m, `version: ${version}`);
        if (Object.keys(mutation).length > 0) {
            yamlContent = this.applyMutationToYamlString(yamlContent, mutation);
        }
        return yamlContent;
    }
    /**
     * Apply mutation to a YAML document while preserving comments
     * Works recursively to handle nested objects
     */
    static applyMutationToDocument(node, mutation) {
        for (const key in mutation) {
            const value = mutation[key];
            if (value && typeof value === 'object' && !Array.isArray(value)) {
                let nestedNode = node.get(key);
                if (!nestedNode || !isMap(nestedNode)) {
                    node.set(key, {});
                    nestedNode = node.get(key);
                }
                if (isMap(nestedNode)) {
                    this.applyMutationToDocument(nestedNode, value);
                }
                else {
                    node.set(key, value);
                }
            }
            else {
                node.set(key, value);
            }
        }
    }
    /**
     * Add spacing between top-level keys and nested rule keys in YAML
     */
    static addYamlSpacing(yaml) {
        const lines = yaml.split('\n');
        const result = [];
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const prevLine = lines[i - 1];
            if (i > 0 && /^[a-z][\w-]*:/.test(line) && prevLine !== undefined) {
                if (!prevLine.trim().startsWith('version:') && prevLine.trim() !== '') {
                    result.push('');
                }
            }
            if (/^    [a-z][\w-]*:/.test(line) && prevLine && /^      /.test(prevLine)) {
                result.push('');
            }
            result.push(line);
        }
        return result.join('\n');
    }
    /**
     * Create a Config instance from a partial config object
     *
     * Useful for testing and programmatic config creation.
     * Deep merges the partial config with defaults.
     *
     * @param partial - Partial config object
     * @param options - Options including projectPath and version
     * @returns Config instance with fully resolved config
     */
    static fromObject(partial, options = {}) {
        const { projectPath = process.cwd(), version = DEFAULT_VERSION } = options;
        const defaults = this.getDefaultConfig(version);
        const merged = deepMerge(defaults, partial);
        try {
            HerbConfigSchema.parse(merged);
        }
        catch (error) {
            if (error instanceof ZodError) {
                const validationError = fromZodError(error, {
                    prefix: "Configuration validation error",
                });
                throw new Error(validationError.toString());
            }
            throw error;
        }
        return new Config(projectPath, merged);
    }
    /**
     * Find config file by walking up directory tree
     *
     * @param startPath - Path to start searching from (file or directory)
     * @returns Object with configPath (if found) and projectRoot
     */
    static async findConfigFile(startPath) {
        let currentPath = path$1$1.resolve(startPath);
        try {
            const stats = await fs.promises.stat(currentPath);
            if (stats.isFile()) {
                currentPath = path$1$1.dirname(currentPath);
            }
        }
        catch {
            currentPath = path$1$1.resolve(process.cwd());
        }
        while (true) {
            const configPath = path$1$1.join(currentPath, this.configPath);
            try {
                await fs.promises.access(configPath);
                return { configPath, projectRoot: currentPath };
            }
            catch {
                // Config not in this directory, continue
            }
            const isProjectRoot = await this.isProjectRoot(currentPath);
            if (isProjectRoot) {
                return { configPath: null, projectRoot: currentPath };
            }
            const parentPath = path$1$1.dirname(currentPath);
            if (parentPath === currentPath) {
                return { configPath: null, projectRoot: process.cwd() };
            }
            currentPath = parentPath;
        }
    }
    /**
     * Check if a directory is a project root
     */
    static async isProjectRoot(dirPath) {
        for (const indicator of this.PROJECT_INDICATORS) {
            try {
                await fs.promises.access(path$1$1.join(dirPath, indicator));
                return true;
            }
            catch {
                // Indicator not found, continue checking
            }
        }
        return false;
    }
    /**
     * Load config from explicit path (from --config-file argument)
     */
    static async loadFromExplicitPath(configPath, silent, version, exitOnError) {
        const resolvedPath = path$1$1.resolve(configPath);
        try {
            const stats = await fs.promises.stat(resolvedPath);
            if (!stats.isFile()) {
                if (exitOnError) {
                    console.error(`\n Config path is not a file: ${resolvedPath}\n`);
                    process.exit(1);
                }
                else {
                    throw new Error(`Config path is not a file: ${resolvedPath}`);
                }
            }
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                if (exitOnError) {
                    console.error(`\n Config file not found: ${resolvedPath}\n`);
                    process.exit(1);
                }
                else {
                    throw new Error(`Config file not found: ${resolvedPath}`);
                }
            }
            throw error;
        }
        const projectRoot = path$1$1.dirname(resolvedPath);
        const config = await this.readAndValidateConfig(resolvedPath, projectRoot, version, exitOnError);
        if (!silent) {
            console.error(` Using Herb config file at ${resolvedPath}`);
        }
        return config;
    }
    /**
     * Load config from discovered path
     */
    static async loadFromPath(configPath, projectRoot, silent, version, exitOnError) {
        const config = await this.readAndValidateConfig(configPath, projectRoot, version, exitOnError);
        if (!silent) {
            console.error(` Using Herb config file at ${configPath}`);
        }
        return config;
    }
    /**
     * Create default config at project root
     */
    static async createDefaultConfig(projectRoot, silent, version) {
        const yamlPath = path$1$1.join(projectRoot, '.herb.yaml');
        try {
            await fs.promises.access(yamlPath);
            console.error(`\n Found \`.herb.yaml\` file at ${yamlPath}`);
            console.error(`  Please rename it to \`.herb.yml\`\n`);
            process.exit(1);
        }
        catch {
            // File doesn't exist
        }
        const configPath = this.configPathFromProjectPath(projectRoot);
        try {
            await this.mutateConfigFile(configPath, {});
            if (!silent) {
                console.error(` Created default configuration at ${configPath}`);
            }
        }
        catch (error) {
            if (!silent) {
                console.error(` Could not create config file at ${configPath}, using defaults in-memory`);
            }
        }
        const defaults = this.getDefaultConfig(version);
        return new Config(projectRoot, defaults);
    }
    /**
     * Validate config text without loading or exiting process
     * Used by language servers to show diagnostics
     * Returns empty array if valid, array of errors/warnings if invalid
     */
    static async validateConfigText(text, options) {
        const errors = [];
        const version = options?.version;
        const projectPath = options?.projectPath;
        if (projectPath) {
            try {
                const yamlPath = path$1$1.join(projectPath, '.herb.yaml');
                await fs.promises.access(yamlPath);
                errors.push({
                    message: 'Found .herb.yaml file. Please rename to .herb.yml',
                    path: [],
                    code: 'wrong_file_extension',
                    severity: 'warning',
                    line: 0,
                    column: 0
                });
            }
            catch {
                // .herb.yaml doesn't exist
            }
        }
        let parsed;
        try {
            parsed = parse$1(text);
        }
        catch (error) {
            let line;
            let column;
            const errorMatch = error.message?.match(/at line (\d+), column (\d+)/);
            if (errorMatch) {
                line = parseInt(errorMatch[1]) - 1;
                column = parseInt(errorMatch[2]) - 1;
            }
            errors.push({
                message: error.message || 'Invalid YAML syntax',
                path: [],
                code: 'yaml_syntax_error',
                severity: 'error',
                line,
                column
            });
            return errors;
        }
        if (parsed === null || parsed === undefined) {
            parsed = {};
        }
        if (version && parsed.version && parsed.version !== version) {
            errors.push({
                message: `Configuration version (${parsed.version}) doesn't match current version (${version}). Consider updating your configuration.`,
                path: ['version'],
                code: 'version_mismatch',
                severity: 'warning'
            });
        }
        if (!parsed.version) {
            parsed.version = version || '0.0.0';
        }
        try {
            HerbConfigSchema.parse(parsed);
        }
        catch (error) {
            if (error instanceof ZodError) {
                errors.push(...error.issues.map(issue => ({
                    message: issue.message,
                    path: issue.path,
                    code: issue.code,
                    severity: 'error'
                })));
            }
        }
        return errors;
    }
    /**
     * Read, parse, and validate config file
     */
    static async readAndValidateConfig(configPath, projectRoot, version, exitOnError = false) {
        try {
            const content = await fs.promises.readFile(configPath, "utf8");
            let parsed;
            try {
                parsed = parse$1(content);
            }
            catch (error) {
                if (exitOnError) {
                    console.error(`\n Invalid YAML syntax in ${configPath}`);
                    if (error instanceof Error) {
                        console.error(`  ${error.message}\n`);
                    }
                    process.exit(1);
                }
                else {
                    throw new Error(`Invalid YAML syntax in ${configPath}: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            if (parsed === null || parsed === undefined) {
                parsed = {};
            }
            if (!parsed.version) {
                parsed.version = version;
            }
            try {
                HerbConfigSchema.parse(parsed);
            }
            catch (error) {
                if (error instanceof ZodError) {
                    const validationError = fromZodError(error, {
                        prefix: `Configuration errors in ${configPath}`,
                    });
                    if (exitOnError) {
                        console.error(`\n ${validationError.toString()}\n`);
                        process.exit(1);
                    }
                    else {
                        throw new Error(validationError.toString());
                    }
                }
                throw error;
            }
            if (parsed.version && parsed.version !== version) {
                console.error(`\n Configuration version mismatch in ${configPath}`);
                console.error(`   Config version: ${parsed.version}`);
                console.error(`   Current version: ${version}`);
                console.error(`   Consider updating your .herb.yml file.\n`);
            }
            const defaults = this.getDefaultConfig(version);
            const resolved = deepMerge(defaults, parsed);
            resolved.version = version;
            return new Config(projectRoot, resolved);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Get default configuration object
     */
    static getDefaultConfig(version = DEFAULT_VERSION) {
        return {
            version,
            files: {
                include: [
                    '**/*.html',
                    '**/*.rhtml',
                    '**/*.html.erb',
                    '**/*.html+*.erb',
                    '**/*.turbo_stream.erb'
                ],
                exclude: [
                    'node_modules/**/*',
                    'vendor/bundle/**/*',
                    'coverage/**/*',
                ]
            },
            linter: {
                enabled: true,
                rules: {}
            },
            formatter: {
                enabled: true,
                indentWidth: 2,
                maxLineLength: 80
            }
        };
    }
}

const HERB_EXTENSION_ID = "marcoroth.herb-lsp";
const VSCODE_DIR = ".vscode";
const EXTENSIONS_FILE = "extensions.json";
/**
 * Ensures the .vscode directory exists in the project
 */
function ensureVSCodeDirectory(projectPath) {
    const vscodeDir = path$1$1.join(projectPath, VSCODE_DIR);
    if (!fs.existsSync(vscodeDir)) {
        fs.mkdirSync(vscodeDir, { recursive: true });
    }
    return vscodeDir;
}
/**
 * Gets the path to the VSCode extensions.json file
 */
function getExtensionsJsonPath(projectPath) {
    const vscodeDir = ensureVSCodeDirectory(projectPath);
    return path$1$1.join(vscodeDir, EXTENSIONS_FILE);
}
/**
 * Reads the current extensions.json file, or returns an empty structure
 */
function readExtensionsJson(filePath) {
    if (!fs.existsSync(filePath)) {
        return { recommendations: [] };
    }
    try {
        const content = fs.readFileSync(filePath, "utf-8");
        const parsed = JSON.parse(content);
        if (!Array.isArray(parsed.recommendations)) {
            parsed.recommendations = [];
        }
        return parsed;
    }
    catch (error) {
        console.warn(`Warning: Could not parse ${filePath}, creating new file`);
        return { recommendations: [] };
    }
}
/**
 * Writes the extensions.json file with proper formatting
 */
function writeExtensionsJson(filePath, data) {
    const content = JSON.stringify(data, null, 2) + "\n";
    fs.writeFileSync(filePath, content, "utf-8");
}
/**
 * Adds the Herb VSCode extension to the recommended extensions list
 * Returns true if the extension was added, false if it was already present
 */
function addHerbExtensionRecommendation(projectPath) {
    const extensionsPath = getExtensionsJsonPath(projectPath);
    const extensions = readExtensionsJson(extensionsPath);
    if (extensions.recommendations?.includes(HERB_EXTENSION_ID)) {
        return false;
    }
    if (!extensions.recommendations) {
        extensions.recommendations = [];
    }
    extensions.recommendations.push(HERB_EXTENSION_ID);
    writeExtensionsJson(extensionsPath, extensions);
    return true;
}
/**
 * Gets the relative path to the extensions.json file from the project root
 */
function getExtensionsJsonRelativePath() {
    return path$1$1.join(VSCODE_DIR, EXTENSIONS_FILE);
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const dedent = createDedent({});
function createDedent(options) {
  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      alignValues = false,
      escapeSpecialCharacters = Array.isArray(strings),
      trimWhitespace = true
    } = options;

    // first, perform interpolation
    let result = "";
    for (let i = 0; i < raw.length; i++) {
      let next = raw[i];
      if (escapeSpecialCharacters) {
        // handle escaped newlines, backticks, and interpolation characters
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
      }
      result += next;
      if (i < values.length) {
        const value = alignValues ? alignValue(values[i], result) : values[i];

        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        result += value;
      }
    }

    // now strip indentation
    const lines = result.split("\n");
    let mindent = null;
    for (const l of lines) {
      const m = l.match(/^(\s+)\S+/);
      if (m) {
        const indent = m[1].length;
        if (!mindent) {
          // this is the first indented line
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m = mindent; // appease TypeScript
      result = lines
      // https://github.com/typescript-eslint/typescript-eslint/issues/7140
      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      .map(l => l[0] === " " || l[0] === "\t" ? l.slice(m) : l).join("\n");
    }

    // dedent eats leading and trailing whitespace too
    if (trimWhitespace) {
      result = result.trim();
    }

    // handle escaped newlines at the end to ensure they don't get stripped too
    if (escapeSpecialCharacters) {
      result = result.replace(/\\n/g, "\n");
    }
    return result;
  }
}

/**
 * Adjusts the indentation of a multi-line interpolated value to match the current line.
 */
function alignValue(value, precedingText) {
  if (typeof value !== "string" || !value.includes("\n")) {
    return value;
  }
  const currentLine = precedingText.slice(precedingText.lastIndexOf("\n") + 1);
  const indentMatch = currentLine.match(/^(\s+)/);
  if (indentMatch) {
    const indent = indentMatch[1];
    return value.replace(/\n/g, `\n${indent}`);
  }
  return value;
}

const colors = {
    reset: "\x1b[0m",
    bold: "\x1b[1m",
    dim: "\x1b[2m",
    black: "\x1b[30m",
    red: "\x1b[31m",
    green: "\x1b[32m",
    yellow: "\x1b[33m",
    blue: "\x1b[34m",
    magenta: "\x1b[35m",
    cyan: "\x1b[36m",
    white: "\x1b[37m",
    gray: "\x1b[90m",
    brightRed: "\x1b[91m",
    brightGreen: "\x1b[92m",
    brightYellow: "\x1b[93m",
    brightBlue: "\x1b[94m",
    brightMagenta: "\x1b[95m",
    brightCyan: "\x1b[96m",
    bgBlack: "\x1b[40m",
    bgRed: "\x1b[41m",
    bgGreen: "\x1b[42m",
    bgYellow: "\x1b[43m",
    bgBlue: "\x1b[44m",
    bgMagenta: "\x1b[45m",
    bgCyan: "\x1b[46m",
    bgWhite: "\x1b[47m",
    bgGray: "\x1b[100m",
};
const hexToAnsi = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `\x1b[38;2;${r};${g};${b}m`;
};
const colorize = (text, color, backgroundColor) => {
    if (process.env.NO_COLOR === undefined) {
        let foreground;
        let background = "";
        if (typeof color === "string" && color.startsWith("#")) {
            foreground = hexToAnsi(color);
        }
        else {
            foreground = colors[color];
        }
        return `${background}${foreground}${text}${colors.reset}`;
    }
    return text;
};
const severityColor = (severity) => {
    switch (severity) {
        case "error": return "brightRed";
        case "warning": return "brightYellow";
        case "info": return "cyan";
        case "hint": return "gray";
        default: return "brightYellow";
    }
};

function applyDimToStyledText(text) {
    const isColorEnabled = process.env.NO_COLOR === undefined;
    if (!isColorEnabled)
        return text;
    const parts = text.split(/(\x1b\[[0-9;]*m)/g);
    let result = "";
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (part.match(/^\x1b\[[0-9;]*m$/)) {
            if (part === "\x1b[0m") {
                result += part;
            }
            else {
                const codes = part.match(/\x1b\[([0-9;]*)m/)?.[1];
                if (codes && codes !== "0" && codes !== "") {
                    result += `\x1b[2;${codes}m`;
                }
                else {
                    result += part;
                }
            }
        }
        else if (part.length > 0) {
            result += `\x1b[2m${part}\x1b[22m`;
        }
    }
    return result;
}

class LineWrapper {
    static wrapLine(line, maxWidth, indent = "") {
        if (maxWidth <= 0)
            return [line];
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return [line];
        }
        const wrappedLines = [];
        let currentLine = line;
        let currentPlain = plainLine;
        while (currentPlain.length > maxWidth) {
            let breakPoint = maxWidth;
            // First pass: look for whitespace (ideal breaks)
            for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 40); i--) {
                const char = currentPlain[i];
                if (char === " " || char === "\t") {
                    breakPoint = i + 1;
                    break;
                }
            }
            // Second pass: if no whitespace found, look for punctuation but not within quoted strings
            if (breakPoint === maxWidth) {
                for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 30); i--) {
                    const char = currentPlain[i];
                    const prevChar = i > 0 ? currentPlain[i - 1] : "";
                    const nextChar = i < currentPlain.length - 1 ? currentPlain[i + 1] : "";
                    if ((char === ">" || char === "," || char === ";") &&
                        prevChar !== "=" && nextChar !== "\"" && nextChar !== "'") {
                        breakPoint = i + 1;
                        break;
                    }
                }
            }
            if (breakPoint === maxWidth) {
                for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 10); i--) {
                    const char = currentPlain[i];
                    if (char !== "=" && char !== "\"" && char !== "'") {
                        breakPoint = i;
                        break;
                    }
                }
            }
            const wrapPortion = this.extractPortionWithAnsi(currentLine, breakPoint);
            wrappedLines.push(wrapPortion);
            currentLine = this.extractRemainingWithAnsi(currentLine, currentPlain, breakPoint);
            currentPlain = currentPlain.slice(breakPoint).trimStart();
            if (currentPlain.length > 0) {
                currentLine = indent + currentLine.trimStart();
            }
        }
        if (currentPlain.length > 0) {
            wrappedLines.push(currentLine);
        }
        return wrappedLines;
    }
    static extractPortionWithAnsi(styledLine, endIndex) {
        let styledIndex = 0;
        let plainIndex = 0;
        let result = "";
        while (plainIndex < endIndex && styledIndex < styledLine.length) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    result += ansiMatch[0];
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            result += char;
            styledIndex++;
            plainIndex++;
        }
        return result;
    }
    static extractRemainingWithAnsi(styledLine, _plainLine, startIndex) {
        let styledIndex = 0;
        let plainIndex = 0;
        while (plainIndex < startIndex && styledIndex < styledLine.length) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            styledIndex++;
            plainIndex++;
        }
        return styledLine.slice(styledIndex);
    }
    static truncateLine(line, maxWidth) {
        if (maxWidth <= 0)
            return line;
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return line;
        }
        const ellipsisChar = "";
        const ellipsis = colorize(ellipsisChar, "dim");
        const rightPadding = 2;
        const availableWidth = maxWidth - ellipsisChar.length - rightPadding;
        if (availableWidth <= 0) {
            return ellipsis;
        }
        const truncatedPortion = this.extractPortionWithAnsi(line, availableWidth);
        return truncatedPortion + ellipsis;
    }
    static getTerminalWidth() {
        if (process.stdout.isTTY && process.stdout.columns) {
            return process.stdout.columns;
        }
        return 80;
    }
}

/**
 * Configuration for gutter formatting in the highlighter
 */
// Calculate the gutter width based on the format: "    123  "
// - 4 spaces for indentation
// - 3 characters for line number (supports up to 999 lines)
// - 1 space after line number
// - 1 character for separator ()
// - 1 space after separator
const GUTTER_WIDTH = 4 + 3 + 1 + 1 + 1; // = 10
// Minimum content width to ensure readability
const MIN_CONTENT_WIDTH = 40;

class DiagnosticRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    highlightBackticks(text) {
        if (process.stdout.isTTY && process.env.NO_COLOR === undefined) {
            const boldWhite = "\x1b[1m\x1b[37m";
            const reset = "\x1b[0m";
            return text.replace(/`([^`]+)`/g, `${boldWhite}$1${reset}`);
        }
        return text;
    }
    truncateLineForDiagnostic(line, diagnosticStart, diagnosticEnd, maxWidth) {
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return { line, adjustedStart: diagnosticStart, adjustedEnd: diagnosticEnd };
        }
        const ellipsisChar = "";
        const ellipsis = colorize(ellipsisChar, "dim");
        const rightPadding = 2;
        const ellipsisCharLength = ellipsisChar.length;
        const ellipsisLength = ellipsisCharLength + rightPadding;
        if (diagnosticStart < maxWidth / 3) {
            const availableWidth = maxWidth - ellipsisLength;
            const truncated = LineWrapper.truncateLine(line, availableWidth);
            return {
                line: truncated,
                adjustedStart: diagnosticStart,
                adjustedEnd: Math.min(diagnosticEnd, availableWidth)
            };
        }
        if (diagnosticStart > plainLine.length - maxWidth / 3) {
            const availableWidth = maxWidth - ellipsisLength;
            const startPos = Math.max(0, plainLine.length - availableWidth);
            const visiblePortion = this.extractPortionFromPosition(line, startPos, plainLine.length);
            const truncated = ellipsis + visiblePortion;
            return {
                line: truncated,
                adjustedStart: Math.max(0, diagnosticStart - startPos + ellipsisCharLength),
                adjustedEnd: Math.max(0, diagnosticEnd - startPos + ellipsisCharLength)
            };
        }
        const contextWidth = maxWidth - (ellipsisLength * 2);
        const contextStart = Math.max(0, diagnosticStart - contextWidth / 3);
        const contextEnd = Math.min(plainLine.length, contextStart + contextWidth);
        const visiblePortion = this.extractPortionFromPosition(line, contextStart, contextEnd);
        const truncated = ellipsis + visiblePortion + ellipsis;
        return {
            line: truncated,
            adjustedStart: diagnosticStart - contextStart + ellipsisCharLength,
            adjustedEnd: diagnosticEnd - contextStart + ellipsisCharLength
        };
    }
    extractPortionFromPosition(styledLine, startPos, endPos) {
        let styledIndex = 0;
        let plainIndex = 0;
        let result = "";
        let inRange = false;
        while (styledIndex < styledLine.length && plainIndex <= endPos) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    if (inRange || plainIndex >= startPos) {
                        result += ansiMatch[0];
                    }
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            if (plainIndex >= startPos && !inRange) {
                inRange = true;
            }
            if (inRange) {
                result += char;
            }
            styledIndex++;
            plainIndex++;
        }
        return result;
    }
    renderSingle(path, diagnostic, content, options = {}) {
        const { contextLines = 2, showLineNumbers: _showLineNumbers = true, optimizeHighlighting = true, wrapLines = true, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false, } = options;
        const shouldWrap = wrapLines && !truncateLines;
        const shouldTruncate = truncateLines;
        const fileHeader = `${colorize(path, "cyan")}:${colorize(`${diagnostic.location.start.line}:${diagnostic.location.start.column}`, "cyan")}`;
        const text = diagnostic.severity;
        const color = severityColor(diagnostic.severity);
        const diagnosticId = colorize(diagnostic.code || "-", "gray");
        const originalLines = content.split("\n");
        const targetLineNumber = diagnostic.location.start.line;
        const column = diagnostic.location.start.column - 1;
        const startLine = Math.max(1, targetLineNumber - contextLines);
        const endLine = Math.min(originalLines.length, targetLineNumber + contextLines);
        let lines;
        let lineOffset = 0;
        if (optimizeHighlighting) {
            const relevantLines = [];
            for (let i = startLine; i <= endLine; i++) {
                relevantLines.push(originalLines[i - 1] || "");
            }
            const relevantContent = relevantLines.join("\n");
            const highlightedContent = this.syntaxRenderer.highlight(relevantContent);
            lines = highlightedContent.split("\n");
            lineOffset = startLine - 1;
        }
        else {
            const highlightedContent = this.syntaxRenderer.highlight(content);
            lines = highlightedContent.split("\n");
            lineOffset = 0;
        }
        let contextOutput = "";
        let adjustedColumn = column;
        let adjustedPointerLength = Math.max(1, diagnostic.location.end.column - diagnostic.location.start.column);
        for (let i = startLine; i <= endLine; i++) {
            const line = lines[i - 1 - lineOffset] || "";
            const isTargetLine = i === targetLineNumber;
            const lineNumber = isTargetLine
                ? colorize(i.toString().padStart(3, " "), "bold")
                : colorize(i.toString().padStart(3, " "), "gray");
            const prefix = isTargetLine
                ? colorize("   ", color)
                : "    ";
            const separator = colorize("", "gray");
            let displayLine = line;
            if (isTargetLine) {
                displayLine = line;
            }
            else {
                displayLine = applyDimToStyledText(line);
            }
            if (shouldWrap) {
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        contextOutput += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        contextOutput += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (shouldTruncate) {
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                let truncatedLine;
                if (isTargetLine) {
                    const diagnosticEnd = diagnostic.location.end.column - 1;
                    const result = this.truncateLineForDiagnostic(displayLine, column, diagnosticEnd, availableWidth);
                    truncatedLine = result.line;
                    adjustedColumn = result.adjustedStart;
                    adjustedPointerLength = Math.max(1, result.adjustedEnd - result.adjustedStart);
                }
                else {
                    truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                }
                contextOutput += `${linePrefix}${truncatedLine}\n`;
            }
            else {
                contextOutput += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
            }
            if (isTargetLine) {
                const pointerPrefix = `        ${colorize("", "gray")}`;
                const pointerSpacing = " ".repeat(adjustedColumn + 2);
                const adjustedPointer = colorize("~".repeat(adjustedPointerLength), color);
                contextOutput += `${pointerPrefix}${pointerSpacing}${adjustedPointer}\n`;
            }
        }
        const highlightedMessage = this.highlightBackticks(diagnostic.message);
        return `[${text}] ${highlightedMessage} (${diagnosticId})

${fileHeader}

${contextOutput.trimEnd()}
`;
    }
}

class FileRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    renderWithLineNumbers(path, content, wrapLines = false, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const lines = highlightedContent.split("\n");
        let output = `${colorize(path, "cyan")}\n\n`;
        for (let i = 1; i <= lines.length; i++) {
            const line = lines[i - 1] || "";
            const lineNumber = colorize(i.toString().padStart(3, " "), "gray");
            const separator = colorize("", "gray");
            if (wrapLines) {
                const linePrefix = `    ${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(line, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        output += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        output += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (truncateLines) {
                const linePrefix = `    ${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const truncatedLine = LineWrapper.truncateLine(line, availableWidth);
                output += `${linePrefix}${truncatedLine}\n`;
            }
            else {
                output += `    ${lineNumber} ${separator} ${line}\n`;
            }
        }
        return output.trimEnd();
    }
    renderWithFocusLine(path, content, focusLine, contextLines, showLineNumbers = true, maxWidth = LineWrapper.getTerminalWidth(), wrapLines = false, truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const lines = highlightedContent.split("\n");
        const startLine = Math.max(1, focusLine - contextLines);
        const endLine = Math.min(lines.length, focusLine + contextLines);
        let output = showLineNumbers ? `${colorize(path, "cyan")}\n\n` : "";
        for (let i = startLine; i <= endLine; i++) {
            const line = lines[i - 1] || "";
            const isFocusLine = i === focusLine;
            if (showLineNumbers) {
                const lineNumber = isFocusLine
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = isFocusLine ? colorize("   ", "cyan") : "    ";
                const separator = colorize("", "gray");
                let displayLine = line;
                if (!isFocusLine) {
                    displayLine = applyDimToStyledText(line);
                }
                if (wrapLines) {
                    const linePrefix = `${prefix}${lineNumber} ${separator} `;
                    const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                    const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                    for (let j = 0; j < wrappedLines.length; j++) {
                        if (j === 0) {
                            output += `${linePrefix}${wrappedLines[j]}\n`;
                        }
                        else {
                            output += `        ${separator} ${wrappedLines[j]}\n`;
                        }
                    }
                }
                else if (truncateLines) {
                    const linePrefix = `${prefix}${lineNumber} ${separator} `;
                    const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                    const truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                    output += `${linePrefix}${truncatedLine}\n`;
                }
                else {
                    output += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
                }
            }
            else {
                let displayLine = line;
                if (!isFocusLine) {
                    displayLine = applyDimToStyledText(line);
                }
                if (wrapLines) {
                    const wrappedLines = LineWrapper.wrapLine(displayLine, maxWidth);
                    for (const wrappedLine of wrappedLines) {
                        output += `${wrappedLine}\n`;
                    }
                }
                else if (truncateLines) {
                    const truncatedLine = LineWrapper.truncateLine(displayLine, maxWidth);
                    output += `${truncatedLine}\n`;
                }
                else {
                    output += `${displayLine}\n`;
                }
            }
        }
        return output.trimEnd();
    }
    renderPlain(content, maxWidth = LineWrapper.getTerminalWidth(), wrapLines = false, truncateLines = false) {
        const highlighted = this.syntaxRenderer.highlight(content);
        if (wrapLines) {
            const lines = highlighted.split("\n");
            const wrappedLines = [];
            for (const line of lines) {
                const wrapped = LineWrapper.wrapLine(line, maxWidth);
                wrappedLines.push(...wrapped);
            }
            return wrappedLines.join("\n");
        }
        else if (truncateLines) {
            const lines = highlighted.split("\n");
            const truncatedLines = [];
            for (const line of lines) {
                const truncated = LineWrapper.truncateLine(line, maxWidth);
                truncatedLines.push(truncated);
            }
            return truncatedLines.join("\n");
        }
        return highlighted;
    }
}

class SyntaxRenderer {
    colors;
    isColorEnabled;
    herb;
    constructor(colors, herb) {
        this.colors = colors;
        this.isColorEnabled = process.env.NO_COLOR === undefined;
        this.herb = herb || Herb;
    }
    async initialize() {
        if (this.herb.isLoaded) {
            return;
        }
        await this.herb.load();
    }
    get initialized() {
        return this.herb.isLoaded;
    }
    highlight(content) {
        if (!this.initialized || !this.herb) {
            throw new Error("SyntaxRenderer must be initialized before use. Call await initialize() first.");
        }
        const lexResult = this.herb.lex(content);
        if (lexResult.errors.length > 0) {
            return content;
        }
        const tokens = [...lexResult.value];
        return this.highlightTokens(tokens, content);
    }
    applyColor(text, color) {
        if (!this.isColorEnabled || !color)
            return text;
        return colorize(text, color);
    }
    // TODO: in the future we should leverage Prism tokens here
    highlightRubyCode(code) {
        if (!this.isColorEnabled)
            return code;
        const words = code.split(/(\s+|[^\w\s]+)/);
        const keywords = [
            "if",
            "unless",
            "else",
            "elsif",
            "end",
            "def",
            "class",
            "module",
            "return",
            "yield",
            "break",
            "next",
            "case",
            "when",
            "then",
            "while",
            "until",
            "for",
            "in",
            "do",
            "begin",
            "rescue",
            "ensure",
            "retry",
            "raise",
            "super",
            "self",
            "nil",
            "true",
            "false",
            "and",
            "or",
            "not",
        ];
        return words
            .map((word) => {
            if (keywords.includes(word)) {
                return this.applyColor(word, this.colors.RUBY_KEYWORD);
            }
            return word;
        }).join("");
    }
    highlightTokens(tokens, content) {
        if (!tokens || tokens.length === 0) {
            return content;
        }
        let highlighted = "";
        let lastEnd = 0;
        let state = {
            inTag: false,
            inQuotes: false,
            quoteChar: "",
            tagName: "",
            isClosingTag: false,
            expectingAttributeName: false,
            expectingAttributeValue: false,
            inComment: false,
        };
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const nextToken = tokens[i + 1];
            const prevToken = tokens[i - 1];
            if (token.range.start > lastEnd) {
                highlighted += content.slice(lastEnd, token.range.start);
            }
            const tokenText = content.slice(token.range.start, token.range.end);
            this.updateState(state, token, tokenText, nextToken, prevToken);
            const color = this.getContextualColor(state, token, tokenText);
            if (token.type === "TOKEN_ERB_CONTENT") {
                const highlightedRuby = this.highlightRubyCode(tokenText);
                highlighted += highlightedRuby;
            }
            else if (color !== undefined) {
                highlighted += this.applyColor(tokenText, color);
            }
            else {
                highlighted += tokenText;
            }
            lastEnd = token.range.end;
        }
        if (lastEnd < content.length) {
            highlighted += content.slice(lastEnd);
        }
        return highlighted;
    }
    updateState(state, token, tokenText, _nextToken, _prevToken) {
        switch (token.type) {
            case "TOKEN_HTML_TAG_START":
                state.inTag = true;
                state.isClosingTag = false;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_HTML_TAG_START_CLOSE":
                state.inTag = true;
                state.isClosingTag = true;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_HTML_TAG_END":
            case "TOKEN_HTML_TAG_SELF_CLOSE":
                state.inTag = false;
                state.tagName = "";
                state.isClosingTag = false;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_IDENTIFIER":
                if (state.inTag && !state.tagName) {
                    state.tagName = tokenText;
                    state.expectingAttributeName = !state.isClosingTag;
                }
                else if (state.inTag && state.expectingAttributeName) {
                    state.expectingAttributeName = false;
                    state.expectingAttributeValue = true;
                }
                break;
            case "TOKEN_EQUALS":
                if (state.inTag) {
                    state.expectingAttributeValue = true;
                }
                break;
            case "TOKEN_QUOTE":
                if (state.inTag) {
                    if (!state.inQuotes) {
                        state.inQuotes = true;
                        state.quoteChar = tokenText;
                    }
                    else if (tokenText === state.quoteChar) {
                        state.inQuotes = false;
                        state.quoteChar = "";
                        state.expectingAttributeName = true;
                        state.expectingAttributeValue = false;
                    }
                }
                break;
            case "TOKEN_WHITESPACE":
                if (state.inTag && !state.inQuotes && state.tagName) {
                    state.expectingAttributeName = true;
                    state.expectingAttributeValue = false;
                }
                break;
            case "TOKEN_HTML_COMMENT_START":
                state.inComment = true;
                break;
            case "TOKEN_HTML_COMMENT_END":
                state.inComment = false;
                break;
        }
    }
    getContextualColor(state, token, tokenText) {
        if (state.inComment &&
            token.type !== "TOKEN_HTML_COMMENT_START" &&
            token.type !== "TOKEN_HTML_COMMENT_END" &&
            token.type !== "TOKEN_ERB_START" &&
            token.type !== "TOKEN_ERB_CONTENT" &&
            token.type !== "TOKEN_ERB_END") {
            return this.colors.TOKEN_HTML_COMMENT_START;
        }
        switch (token.type) {
            case "TOKEN_IDENTIFIER":
                if (state.inTag && tokenText === state.tagName) {
                    return this.colors.TOKEN_HTML_TAG_START;
                }
                else if (state.inTag &&
                    state.expectingAttributeValue &&
                    !state.inQuotes) {
                    return "#D19A66";
                }
                else if (state.inTag && state.expectingAttributeName) {
                    return "#D19A66";
                }
                else if (state.inTag && state.inQuotes) {
                    return "#98C379";
                }
                break;
            case "TOKEN_QUOTE":
                if (state.inTag) {
                    return "#98C379";
                }
                break;
        }
        if (!this.colors) {
            return null;
        }
        const color = this.colors[token.type];
        return color !== undefined ? color : null;
    }
}

class InitializationManager {
    _initialized = false;
    herb;
    constructor(herb) {
        this.herb = herb;
    }
    async initialize() {
        if (this.herb) {
            await this.herb.load();
        }
        this._initialized = true;
    }
    get initialized() {
        return this._initialized;
    }
    requireInitialized() {
        if (!this._initialized) {
            throw new Error("Highlighter must be initialized before use. Call await highlighter.initialize() first.");
        }
    }
}

class TextFormatter {
    static applyDimToStyledText(text) {
        const isColorEnabled = process.env.NO_COLOR === undefined;
        if (!isColorEnabled)
            return text;
        return text.replace(/\x1b\[([0-9;]*)m/g, (match, codes) => {
            if (codes === "0" || codes === "") {
                return match;
            }
            return `\x1b[2;${codes}m`;
        });
    }
    static highlightBackticks(text) {
        if (process.stdout.isTTY && process.env.NO_COLOR === undefined) {
            const boldWhite = "\x1b[1m\x1b[37m";
            const reset = "\x1b[0m";
            return text.replace(/`([^`]+)`/g, `${boldWhite}$1${reset}`);
        }
        return text;
    }
}

class InlineDiagnosticRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    getSeverityText(severity) {
        return colorize(severity, severityColor(severity));
    }
    getHighestSeverity(diagnostics) {
        const severityOrder = ["error", "warning", "info", "hint"];
        for (const severity of severityOrder) {
            if (diagnostics.some(diagnostic => diagnostic.severity === severity)) {
                return severity;
            }
        }
        return "warning";
    }
    render(path, content, diagnostics, _contextLines, showLineNumbers = true, wrapLines = false, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const diagnosticsByLine = new Map();
        for (const diagnostic of diagnostics) {
            const lineNumber = diagnostic.location.start.line;
            if (!diagnosticsByLine.has(lineNumber)) {
                diagnosticsByLine.set(lineNumber, []);
            }
            diagnosticsByLine.get(lineNumber).push(diagnostic);
        }
        const severityOrder = {
            "error": 0,
            "warning": 1,
            "info": 2,
            "hint": 3
        };
        for (const lineDiagnostics of diagnosticsByLine.values()) {
            lineDiagnostics.sort((a, b) => {
                const orderA = severityOrder[a.severity] ?? 99;
                const orderB = severityOrder[b.severity] ?? 99;
                return orderA - orderB;
            });
        }
        const lines = highlightedContent.split("\n");
        let output = showLineNumbers ? `${colorize(path, "cyan")}\n\n` : "";
        let previousLineHadDiagnostics = false;
        for (let i = 1; i <= lines.length; i++) {
            const line = lines[i - 1] || "";
            const lineDiagnostics = diagnosticsByLine.get(i) || [];
            const hasDiagnostics = lineDiagnostics.length > 0;
            if (hasDiagnostics && previousLineHadDiagnostics) {
                output += "\n";
            }
            const highestSeverity = this.getHighestSeverity(lineDiagnostics);
            const lineColor = severityColor(highestSeverity);
            let displayLine = line;
            let availableWidth = maxWidth;
            if (wrapLines && showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("   ", lineColor)
                    : "    ";
                const separator = colorize("", "gray");
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        output += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        output += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (truncateLines && showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("   ", lineColor)
                    : "    ";
                const separator = colorize("", "gray");
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                output += `${linePrefix}${truncatedLine}\n`;
            }
            else if (showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("   ", lineColor)
                    : "    ";
                const separator = colorize("", "gray");
                output += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
            }
            else if (wrapLines) {
                availableWidth = maxWidth;
                const wrappedLines = LineWrapper.wrapLine(displayLine, maxWidth);
                for (const wrappedLine of wrappedLines) {
                    output += `${wrappedLine}\n`;
                }
            }
            else if (truncateLines) {
                const truncatedLine = LineWrapper.truncateLine(displayLine, maxWidth);
                output += `${truncatedLine}\n`;
            }
            else {
                output += `${displayLine}\n`;
            }
            if (hasDiagnostics) {
                for (const diagnostic of lineDiagnostics) {
                    const column = diagnostic.location.start.column - 1;
                    const pointerLength = Math.max(1, diagnostic.location.end.column - diagnostic.location.start.column);
                    if (showLineNumbers) {
                        const pointerPrefix = `        ${colorize("", "gray")}`;
                        const pointerSpacing = " ".repeat(column + 2);
                        const pointer = colorize("~".repeat(pointerLength), severityColor(diagnostic.severity));
                        output += `${pointerPrefix}${pointerSpacing}${pointer}\n`;
                        const severityText = this.getSeverityText(diagnostic.severity);
                        const diagnosticId = colorize(diagnostic.code || "-", "gray");
                        const highlightedMessage = TextFormatter.highlightBackticks(diagnostic.message);
                        const diagnosticText = `[${severityText}] ${highlightedMessage} (${diagnosticId})`;
                        const dimmedDiagnosticText = TextFormatter.applyDimToStyledText(diagnosticText);
                        output += `${pointerPrefix}${pointerSpacing}${dimmedDiagnosticText}\n`;
                    }
                    else {
                        const pointerSpacing = " ".repeat(column);
                        const pointer = colorize("~".repeat(pointerLength), severityColor(diagnostic.severity));
                        output += `${pointerSpacing}${pointer}\n`;
                        const severityText = this.getSeverityText(diagnostic.severity);
                        const diagnosticId = colorize(diagnostic.code || "-", "gray");
                        const highlightedMessage = TextFormatter.highlightBackticks(diagnostic.message);
                        const diagnosticText = `[${severityText}] ${highlightedMessage} (${diagnosticId})`;
                        const dimmedDiagnosticText = TextFormatter.applyDimToStyledText(diagnosticText);
                        output += `${dimmedDiagnosticText}\n`;
                    }
                }
                output += "\n";
            }
            previousLineHadDiagnostics = hasDiagnostics;
        }
        return output.trimEnd();
    }
}

class FileReader {
    highlighter;
    constructor(highlighter) {
        this.highlighter = highlighter;
    }
    highlightFromPath(filePath, options = {}) {
        this.highlighter.requireInitialized();
        try {
            const content = fs.readFileSync(filePath, "utf8");
            return this.highlighter.highlight(filePath, content, options);
        }
        catch (error) {
            throw new Error(`Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    highlightDiagnosticFromPath(filePath, diagnostic, options = {}) {
        this.highlighter.requireInitialized();
        try {
            const content = fs.readFileSync(filePath, "utf8");
            return this.highlighter.highlightDiagnostic(filePath, diagnostic, content, options);
        }
        catch (error) {
            throw new Error(`Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}

var TOKEN_WHITESPACE$4 = null;
var TOKEN_NBSP$4 = "#5C6370";
var TOKEN_NEWLINE$4 = null;
var TOKEN_IDENTIFIER$4 = "#ABB2BF";
var RUBY_KEYWORD$4 = "#C678DD";
var TOKEN_HTML_DOCTYPE$4 = "#61AFEF";
var TOKEN_HTML_TAG_START$4 = "#E06C75";
var TOKEN_HTML_TAG_START_CLOSE$4 = "#E06C75";
var TOKEN_HTML_TAG_END$4 = "#E06C75";
var TOKEN_HTML_TAG_SELF_CLOSE$4 = "#E06C75";
var TOKEN_HTML_COMMENT_START$4 = "#5C6370";
var TOKEN_HTML_COMMENT_END$4 = "#5C6370";
var TOKEN_ERB_START$4 = "#BE5046";
var TOKEN_ERB_CONTENT$4 = "#E5C07B";
var TOKEN_ERB_END$4 = "#BE5046";
var TOKEN_LT$4 = "#E06C75";
var TOKEN_SLASH$4 = "#E06C75";
var TOKEN_EQUALS$4 = "#56B6C2";
var TOKEN_QUOTE$4 = "#98C379";
var TOKEN_DASH$4 = "#ABB2BF";
var TOKEN_UNDERSCORE$4 = "#ABB2BF";
var TOKEN_EXCLAMATION$4 = "#C678DD";
var TOKEN_SEMICOLON$4 = "#ABB2BF";
var TOKEN_COLON$4 = "#ABB2BF";
var TOKEN_PERCENT$4 = "#BE5046";
var TOKEN_AMPERSAND$4 = "#D19A66";
var TOKEN_CHARACTER$4 = "#ABB2BF";
var TOKEN_ERROR$4 = "#E05252";
var TOKEN_EOF$4 = null;
var onedarkTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$4,
	TOKEN_NBSP: TOKEN_NBSP$4,
	TOKEN_NEWLINE: TOKEN_NEWLINE$4,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$4,
	RUBY_KEYWORD: RUBY_KEYWORD$4,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$4,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$4,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$4,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$4,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$4,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$4,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$4,
	TOKEN_ERB_START: TOKEN_ERB_START$4,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$4,
	TOKEN_ERB_END: TOKEN_ERB_END$4,
	TOKEN_LT: TOKEN_LT$4,
	TOKEN_SLASH: TOKEN_SLASH$4,
	TOKEN_EQUALS: TOKEN_EQUALS$4,
	TOKEN_QUOTE: TOKEN_QUOTE$4,
	TOKEN_DASH: TOKEN_DASH$4,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$4,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$4,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$4,
	TOKEN_COLON: TOKEN_COLON$4,
	TOKEN_PERCENT: TOKEN_PERCENT$4,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$4,
	TOKEN_CHARACTER: TOKEN_CHARACTER$4,
	TOKEN_ERROR: TOKEN_ERROR$4,
	TOKEN_EOF: TOKEN_EOF$4
};

var TOKEN_WHITESPACE$3 = null;
var TOKEN_NBSP$3 = "#6a737d";
var TOKEN_NEWLINE$3 = null;
var TOKEN_IDENTIFIER$3 = "#24292e";
var RUBY_KEYWORD$3 = "#d73a49";
var TOKEN_HTML_DOCTYPE$3 = "#005cc5";
var TOKEN_HTML_TAG_START$3 = "#22863a";
var TOKEN_HTML_TAG_START_CLOSE$3 = "#22863a";
var TOKEN_HTML_TAG_END$3 = "#22863a";
var TOKEN_HTML_TAG_SELF_CLOSE$3 = "#22863a";
var TOKEN_HTML_COMMENT_START$3 = "#6a737d";
var TOKEN_HTML_COMMENT_END$3 = "#6a737d";
var TOKEN_ERB_START$3 = "#e36209";
var TOKEN_ERB_CONTENT$3 = "#6f42c1";
var TOKEN_ERB_END$3 = "#e36209";
var TOKEN_LT$3 = "#22863a";
var TOKEN_SLASH$3 = "#22863a";
var TOKEN_EQUALS$3 = "#d73a49";
var TOKEN_QUOTE$3 = "#032f62";
var TOKEN_DASH$3 = "#24292e";
var TOKEN_UNDERSCORE$3 = "#24292e";
var TOKEN_EXCLAMATION$3 = "#d73a49";
var TOKEN_SEMICOLON$3 = "#24292e";
var TOKEN_COLON$3 = "#24292e";
var TOKEN_PERCENT$3 = "#e36209";
var TOKEN_AMPERSAND$3 = "#005cc5";
var TOKEN_CHARACTER$3 = "#24292e";
var TOKEN_ERROR$3 = "#cb2431";
var TOKEN_EOF$3 = null;
var githubLightTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$3,
	TOKEN_NBSP: TOKEN_NBSP$3,
	TOKEN_NEWLINE: TOKEN_NEWLINE$3,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$3,
	RUBY_KEYWORD: RUBY_KEYWORD$3,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$3,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$3,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$3,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$3,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$3,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$3,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$3,
	TOKEN_ERB_START: TOKEN_ERB_START$3,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$3,
	TOKEN_ERB_END: TOKEN_ERB_END$3,
	TOKEN_LT: TOKEN_LT$3,
	TOKEN_SLASH: TOKEN_SLASH$3,
	TOKEN_EQUALS: TOKEN_EQUALS$3,
	TOKEN_QUOTE: TOKEN_QUOTE$3,
	TOKEN_DASH: TOKEN_DASH$3,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$3,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$3,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$3,
	TOKEN_COLON: TOKEN_COLON$3,
	TOKEN_PERCENT: TOKEN_PERCENT$3,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$3,
	TOKEN_CHARACTER: TOKEN_CHARACTER$3,
	TOKEN_ERROR: TOKEN_ERROR$3,
	TOKEN_EOF: TOKEN_EOF$3
};

var TOKEN_WHITESPACE$2 = null;
var TOKEN_NBSP$2 = "#6272a4";
var TOKEN_NEWLINE$2 = null;
var TOKEN_IDENTIFIER$2 = "#f8f8f2";
var RUBY_KEYWORD$2 = "#ff79c6";
var TOKEN_HTML_DOCTYPE$2 = "#8be9fd";
var TOKEN_HTML_TAG_START$2 = "#50fa7b";
var TOKEN_HTML_TAG_START_CLOSE$2 = "#50fa7b";
var TOKEN_HTML_TAG_END$2 = "#50fa7b";
var TOKEN_HTML_TAG_SELF_CLOSE$2 = "#50fa7b";
var TOKEN_HTML_COMMENT_START$2 = "#6272a4";
var TOKEN_HTML_COMMENT_END$2 = "#6272a4";
var TOKEN_ERB_START$2 = "#ffb86c";
var TOKEN_ERB_CONTENT$2 = "#bd93f9";
var TOKEN_ERB_END$2 = "#ffb86c";
var TOKEN_LT$2 = "#50fa7b";
var TOKEN_SLASH$2 = "#50fa7b";
var TOKEN_EQUALS$2 = "#ff79c6";
var TOKEN_QUOTE$2 = "#f1fa8c";
var TOKEN_DASH$2 = "#f8f8f2";
var TOKEN_UNDERSCORE$2 = "#f8f8f2";
var TOKEN_EXCLAMATION$2 = "#ff79c6";
var TOKEN_SEMICOLON$2 = "#f8f8f2";
var TOKEN_COLON$2 = "#f8f8f2";
var TOKEN_PERCENT$2 = "#ffb86c";
var TOKEN_AMPERSAND$2 = "#8be9fd";
var TOKEN_CHARACTER$2 = "#f8f8f2";
var TOKEN_ERROR$2 = "#ff5555";
var TOKEN_EOF$2 = null;
var draculaTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$2,
	TOKEN_NBSP: TOKEN_NBSP$2,
	TOKEN_NEWLINE: TOKEN_NEWLINE$2,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$2,
	RUBY_KEYWORD: RUBY_KEYWORD$2,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$2,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$2,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$2,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$2,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$2,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$2,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$2,
	TOKEN_ERB_START: TOKEN_ERB_START$2,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$2,
	TOKEN_ERB_END: TOKEN_ERB_END$2,
	TOKEN_LT: TOKEN_LT$2,
	TOKEN_SLASH: TOKEN_SLASH$2,
	TOKEN_EQUALS: TOKEN_EQUALS$2,
	TOKEN_QUOTE: TOKEN_QUOTE$2,
	TOKEN_DASH: TOKEN_DASH$2,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$2,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$2,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$2,
	TOKEN_COLON: TOKEN_COLON$2,
	TOKEN_PERCENT: TOKEN_PERCENT$2,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$2,
	TOKEN_CHARACTER: TOKEN_CHARACTER$2,
	TOKEN_ERROR: TOKEN_ERROR$2,
	TOKEN_EOF: TOKEN_EOF$2
};

var TOKEN_WHITESPACE$1 = null;
var TOKEN_NBSP$1 = "#646e9c";
var TOKEN_NEWLINE$1 = null;
var TOKEN_IDENTIFIER$1 = "#c0caf5";
var RUBY_KEYWORD$1 = "#bb9af7";
var TOKEN_HTML_DOCTYPE$1 = "#7aa2f7";
var TOKEN_HTML_TAG_START$1 = "#f7768e";
var TOKEN_HTML_TAG_START_CLOSE$1 = "#f7768e";
var TOKEN_HTML_TAG_END$1 = "#f7768e";
var TOKEN_HTML_TAG_SELF_CLOSE$1 = "#f7768e";
var TOKEN_HTML_COMMENT_START$1 = "#51597d";
var TOKEN_HTML_COMMENT_END$1 = "#51597d";
var TOKEN_ERB_START$1 = "#7dcfff";
var TOKEN_ERB_CONTENT$1 = "#bb9af7";
var TOKEN_ERB_END$1 = "#7dcfff";
var TOKEN_LT$1 = "#f7768e";
var TOKEN_SLASH$1 = "#f7768e";
var TOKEN_EQUALS$1 = "#89ddff";
var TOKEN_QUOTE$1 = "#9ece6a";
var TOKEN_DASH$1 = "#c0caf5";
var TOKEN_UNDERSCORE$1 = "#c0caf5";
var TOKEN_EXCLAMATION$1 = "#bb9af7";
var TOKEN_SEMICOLON$1 = "#c0caf5";
var TOKEN_COLON$1 = "#c0caf5";
var TOKEN_PERCENT$1 = "#7dcfff";
var TOKEN_AMPERSAND$1 = "#e0af68";
var TOKEN_CHARACTER$1 = "#c0caf5";
var TOKEN_ERROR$1 = "#f7768e";
var TOKEN_EOF$1 = null;
var tokyoNightTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$1,
	TOKEN_NBSP: TOKEN_NBSP$1,
	TOKEN_NEWLINE: TOKEN_NEWLINE$1,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$1,
	RUBY_KEYWORD: RUBY_KEYWORD$1,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$1,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$1,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$1,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$1,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$1,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$1,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$1,
	TOKEN_ERB_START: TOKEN_ERB_START$1,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$1,
	TOKEN_ERB_END: TOKEN_ERB_END$1,
	TOKEN_LT: TOKEN_LT$1,
	TOKEN_SLASH: TOKEN_SLASH$1,
	TOKEN_EQUALS: TOKEN_EQUALS$1,
	TOKEN_QUOTE: TOKEN_QUOTE$1,
	TOKEN_DASH: TOKEN_DASH$1,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$1,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$1,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$1,
	TOKEN_COLON: TOKEN_COLON$1,
	TOKEN_PERCENT: TOKEN_PERCENT$1,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$1,
	TOKEN_CHARACTER: TOKEN_CHARACTER$1,
	TOKEN_ERROR: TOKEN_ERROR$1,
	TOKEN_EOF: TOKEN_EOF$1
};

var TOKEN_WHITESPACE = null;
var TOKEN_NBSP = "gray";
var TOKEN_NEWLINE = null;
var TOKEN_IDENTIFIER = "white";
var RUBY_KEYWORD = "magenta";
var TOKEN_HTML_DOCTYPE = "blue";
var TOKEN_HTML_TAG_START = "red";
var TOKEN_HTML_TAG_START_CLOSE = "red";
var TOKEN_HTML_TAG_END = "red";
var TOKEN_HTML_TAG_SELF_CLOSE = "red";
var TOKEN_HTML_COMMENT_START = "gray";
var TOKEN_HTML_COMMENT_END = "gray";
var TOKEN_ERB_START = "yellow";
var TOKEN_ERB_CONTENT = "magenta";
var TOKEN_ERB_END = "yellow";
var TOKEN_LT = "red";
var TOKEN_SLASH = "red";
var TOKEN_EQUALS = "blue";
var TOKEN_QUOTE = "green";
var TOKEN_DASH = "white";
var TOKEN_UNDERSCORE = "white";
var TOKEN_EXCLAMATION = "magenta";
var TOKEN_SEMICOLON = "white";
var TOKEN_COLON = "white";
var TOKEN_PERCENT = "yellow";
var TOKEN_AMPERSAND = "yellow";
var TOKEN_CHARACTER = "white";
var TOKEN_ERROR = "red";
var TOKEN_EOF = null;
var simpleTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE,
	TOKEN_NBSP: TOKEN_NBSP,
	TOKEN_NEWLINE: TOKEN_NEWLINE,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER,
	RUBY_KEYWORD: RUBY_KEYWORD,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END,
	TOKEN_ERB_START: TOKEN_ERB_START,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT,
	TOKEN_ERB_END: TOKEN_ERB_END,
	TOKEN_LT: TOKEN_LT,
	TOKEN_SLASH: TOKEN_SLASH,
	TOKEN_EQUALS: TOKEN_EQUALS,
	TOKEN_QUOTE: TOKEN_QUOTE,
	TOKEN_DASH: TOKEN_DASH,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON,
	TOKEN_COLON: TOKEN_COLON,
	TOKEN_PERCENT: TOKEN_PERCENT,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND,
	TOKEN_CHARACTER: TOKEN_CHARACTER,
	TOKEN_ERROR: TOKEN_ERROR,
	TOKEN_EOF: TOKEN_EOF
};

const THEME_NAMES = ["onedark", "github-light", "dracula", "tokyo-night", "simple"];
const DEFAULT_THEME = "onedark";
// Built-in themes are now bundled directly
const themes = {
    onedark: onedarkTheme,
    "github-light": githubLightTheme,
    dracula: draculaTheme,
    "tokyo-night": tokyoNightTheme,
    simple: simpleTheme
};
function isValidTheme(theme) {
    return THEME_NAMES.includes(theme);
}
function getTheme(theme) {
    return themes[theme];
}
function loadCustomTheme(themePath) {
    try {
        const absolutePath = path$1$1.resolve(themePath);
        const themeContent = fs.readFileSync(absolutePath, 'utf-8');
        const customTheme = JSON.parse(themeContent);
        const requiredKeys = Object.keys(themes.onedark);
        const customKeys = Object.keys(customTheme);
        const missingKeys = requiredKeys.filter(key => !customKeys.includes(key));
        if (missingKeys.length > 0) {
            throw new Error(`Custom theme is missing required properties: ${missingKeys.join(', ')}`);
        }
        return customTheme;
    }
    catch (error) {
        if (error instanceof Error) {
            throw new Error(`Failed to load custom theme from ${themePath}: ${error.message}`);
        }
        throw new Error(`Failed to load custom theme from ${themePath}`);
    }
}
function resolveTheme(themeInput) {
    if (isValidTheme(themeInput)) {
        return getTheme(themeInput);
    }
    return loadCustomTheme(themeInput);
}

class Highlighter {
    syntaxRenderer;
    diagnosticRenderer;
    fileRenderer;
    initManager;
    inlineDiagnosticRenderer;
    fileReader;
    constructor(theme = "onedark", herb) {
        const colors = resolveTheme(theme);
        this.syntaxRenderer = new SyntaxRenderer(colors, herb);
        this.diagnosticRenderer = new DiagnosticRenderer(this.syntaxRenderer);
        this.fileRenderer = new FileRenderer(this.syntaxRenderer);
        this.initManager = new InitializationManager(herb);
        this.inlineDiagnosticRenderer = new InlineDiagnosticRenderer(this.syntaxRenderer);
        this.fileReader = new FileReader(this);
    }
    /**
     * Initialize the highlighter with the Herb backend
     * This must be called before using highlight() or highlightDiagnostic()
     */
    async initialize() {
        await this.initManager.initialize();
        await this.syntaxRenderer.initialize();
    }
    /**
     * Check if the highlighter has been initialized
     */
    get initialized() {
        return this.initManager.initialized;
    }
    requireInitialized() {
        this.initManager.requireInitialized();
    }
    /**
     * Main highlighting method with flexible rendering options
     * @param path - File path for annotation (display only, not used for reading)
     * @param content - The content to highlight
     * @param options - Configuration options
     *   - diagnostics: Array of diagnostics to display inline or split
     *   - splitDiagnostics: When true with diagnostics, render each diagnostic individually
     *   - contextLines: Number of context lines around focus/diagnostics
     *   - focusLine: Line number to focus on (shows only that line with dimmed context)
     *   - showLineNumbers: Whether to show line numbers (default: true)
     * @returns The highlighted content with optional diagnostics or focused view
     */
    highlight(path, content, options = {}) {
        this.requireInitialized();
        const { diagnostics = [], splitDiagnostics = false, contextLines = 0, focusLine, showLineNumbers = true, wrapLines = true, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false, } = options;
        // Case 1: Split diagnostics - render each diagnostic individually
        if (diagnostics.length > 0 && splitDiagnostics) {
            const results = [];
            for (let i = 0; i < diagnostics.length; i++) {
                const diagnostic = diagnostics[i];
                const result = this.highlightDiagnostic(path, diagnostic, content, {
                    contextLines,
                    showLineNumbers,
                    wrapLines,
                    maxWidth,
                    truncateLines,
                });
                results.push(result);
                if (i < diagnostics.length - 1) {
                    const width = LineWrapper.getTerminalWidth();
                    const progressText = `[${i + 1}/${diagnostics.length}]`;
                    const rightPadding = 16;
                    const separatorLength = Math.max(0, width - progressText.length - 1 - rightPadding);
                    const separator = '';
                    const leftSeparator = separator.repeat(separatorLength);
                    const rightSeparator = separator.repeat(4);
                    const progress = progressText;
                    results.push(`${leftSeparator}  ${progress} ${rightSeparator}`);
                }
            }
            return results.join("\n\n");
        }
        // Case 2: Inline diagnostics - show whole file with diagnostics inline
        if (diagnostics.length > 0) {
            return this.inlineDiagnosticRenderer.render(path, content, diagnostics, contextLines, showLineNumbers, wrapLines, maxWidth, truncateLines);
        }
        // Case 3: Focus line - show only specific line with context
        if (focusLine) {
            return this.fileRenderer.renderWithFocusLine(path, content, focusLine, contextLines, showLineNumbers, maxWidth, wrapLines, truncateLines);
        }
        // Case 4: Default - just highlight the whole file
        if (showLineNumbers) {
            return this.fileRenderer.renderWithLineNumbers(path, content, wrapLines, maxWidth, truncateLines);
        }
        else {
            return this.fileRenderer.renderPlain(content, maxWidth, wrapLines, truncateLines);
        }
    }
    /**
     * Render a single diagnostic with context lines and syntax highlighting
     * @param path - The file path to display in the diagnostic (display only)
     * @param diagnostic - The diagnostic message to render
     * @param content - The content to highlight and render
     * @param options - Optional configuration
     * @returns The rendered diagnostic output with syntax highlighting
     */
    highlightDiagnostic(path, diagnostic, content, options = {}) {
        this.requireInitialized();
        return this.diagnosticRenderer.renderSingle(path, diagnostic, content, options);
    }
    // File reading wrapper functions
    /**
     * Convenience method that reads a file and highlights it
     * @param filePath - Path to the file to read and highlight
     * @param options - Configuration options
     * @returns The highlighted file content with optional diagnostics
     */
    highlightFileFromPath(filePath, options = {}) {
        return this.fileReader.highlightFromPath(filePath, options);
    }
    /**
     * Convenience method that reads a file and renders a diagnostic
     * @param filePath - Path to the file to read
     * @param diagnostic - The diagnostic message to render
     * @param options - Optional configuration
     * @returns The highlighted diagnostic output
     */
    highlightDiagnosticFromPath(filePath, diagnostic, options = {}) {
        return this.fileReader.highlightDiagnosticFromPath(filePath, diagnostic, options);
    }
}

var name = "@herb-tools/linter";
var version = "0.8.2";
var dependencies = {
	"@herb-tools/printer": "0.8.2"};

class ArgumentParser {
    usage = dedent `
    Usage: herb-lint [files|directories|glob-patterns...] [options]

    Arguments:
      files            Files, directories, or glob patterns to lint (defaults to configured extensions in .herb.yml)
                       Multiple arguments are supported (e.g., herb-lint file1.erb file2.erb dir/ "**/*.erb")

    Options:
      -h, --help                    show help
      -v, --version                 show version
      --init                        create a .herb.yml configuration file in the current directory
      -c, --config-file <path>      explicitly specify path to .herb.yml config file
      --force                       force linting even if disabled in .herb.yml
      --fix                         automatically fix auto-correctable offenses
      --ignore-disable-comments     report offenses even when suppressed with <%# herb:disable %> comments
      --format                      output format (simple|detailed|json) [default: detailed]
      --simple                      use simple output format (shortcut for --format simple)
      --json                        use JSON output format (shortcut for --format json)
      --github                      enable GitHub Actions annotations (combines with --format)
      --no-github                   disable GitHub Actions annotations (even in GitHub Actions environment)
      --no-custom-rules             disable loading custom rules from project (custom rules are loaded by default from .herb/rules/**/*.{mjs,js})
      --theme                       syntax highlighting theme (${THEME_NAMES.join("|")}) or path to custom theme file [default: ${DEFAULT_THEME}]
      --no-color                    disable colored output
      --no-timing                   hide timing information
      --no-wrap-lines               disable line wrapping
      --truncate-lines              enable line truncation (mutually exclusive with line wrapping)
  `;
    parse(argv) {
        const { values, positionals } = util.parseArgs({
            args: argv.slice(2),
            options: {
                help: { type: "boolean", short: "h" },
                version: { type: "boolean", short: "v" },
                init: { type: "boolean" },
                "config-file": { type: "string", short: "c" },
                force: { type: "boolean" },
                fix: { type: "boolean" },
                "ignore-disable-comments": { type: "boolean" },
                format: { type: "string" },
                simple: { type: "boolean" },
                json: { type: "boolean" },
                github: { type: "boolean" },
                "no-github": { type: "boolean" },
                theme: { type: "string" },
                "no-color": { type: "boolean" },
                "no-timing": { type: "boolean" },
                "no-wrap-lines": { type: "boolean" },
                "truncate-lines": { type: "boolean" },
                "no-custom-rules": { type: "boolean" }
            },
            allowPositionals: true
        });
        if (values.help) {
            console.log(this.usage);
            process.exit(0);
        }
        if (values.version) {
            console.log("Versions:");
            console.log(`  ${name}@${version}`);
            console.log(`  @herb-tools/printer@${dependencies["@herb-tools/printer"]}`);
            console.log(`  ${Herb.version}`.split(", ").join("\n  "));
            process.exit(0);
        }
        const isGitHubActions = process.env.GITHUB_ACTIONS === "true";
        let formatOption = "detailed";
        if (values.format && (values.format === "detailed" || values.format === "simple" || values.format === "json")) {
            formatOption = values.format;
        }
        if (values.simple) {
            formatOption = "simple";
        }
        if (values.json) {
            formatOption = "json";
        }
        const useGitHubActions = (values.github || isGitHubActions) && !values["no-github"];
        if (useGitHubActions && formatOption === "json") {
            console.error("Error: --github cannot be used with --json format. JSON format is already structured for programmatic consumption.");
            process.exit(1);
        }
        if (values["no-color"]) {
            process.env.NO_COLOR = "1";
        }
        const showTiming = !values["no-timing"];
        let wrapLines = !values["no-wrap-lines"];
        let truncateLines = false;
        if (values["truncate-lines"]) {
            truncateLines = true;
            wrapLines = false;
        }
        if (!values["no-wrap-lines"] && values["truncate-lines"]) {
            console.error("Error: Line wrapping and --truncate-lines cannot be used together. Use --no-wrap-lines with --truncate-lines.");
            process.exit(1);
        }
        const theme = values.theme || DEFAULT_THEME;
        const patterns = this.getFilePatterns(positionals);
        const fix = values.fix || false;
        const force = !!values.force;
        const ignoreDisableComments = values["ignore-disable-comments"] || false;
        const configFile = values["config-file"];
        const init = values.init || false;
        const loadCustomRules = !values["no-custom-rules"];
        return { patterns, configFile, formatOption, showTiming, theme, wrapLines, truncateLines, useGitHubActions, fix, ignoreDisableComments, force, init, loadCustomRules };
    }
    getFilePatterns(positionals) {
        return positionals;
    }
}

class Position {
    line;
    column;
    static from(positionOrLine, column) {
        if (typeof positionOrLine === "number") {
            return new Position(positionOrLine, column);
        }
        else {
            return new Position(positionOrLine.line, positionOrLine.column);
        }
    }
    static get zero() {
        return new Position(0, 0);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Location {
    start;
    end;
    static from(locationOrLine, column, endLine, endColumn) {
        if (typeof locationOrLine === "number") {
            const start = Position.from(locationOrLine, column);
            const end = Position.from(endLine, endColumn);
            return new Location(start, end);
        }
        else {
            const start = Position.from(locationOrLine.start);
            const end = Position.from(locationOrLine.end);
            return new Location(start, end);
        }
    }
    static get zero() {
        return new Location(Position.zero, Position.zero);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Range {
    start;
    end;
    static from(rangeOrStart, end) {
        if (typeof rangeOrStart === "number") {
            return new Range(rangeOrStart, end);
        }
        else {
            return new Range(rangeOrStart[0], rangeOrStart[1]);
        }
    }
    static get zero() {
        return new Range(0, 0);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range.from(token.range), Location.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/errors.ts.erb
class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
}
class UnexpectedError extends HerbError {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` description: ${JSON.stringify(this.description)}\n`;
        output += ` expected: ${JSON.stringify(this.expected)}\n`;
        output += ` found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnexpectedTokenError extends HerbError {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += ` found: ${this.found ? this.found.treeInspect() : ""}\n`;
        return output;
    }
}
class MissingOpeningTagError extends HerbError {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : ""}\n`;
        return output;
    }
}
class MissingClosingTagError extends HerbError {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        return output;
    }
}
class TagNamesMismatchError extends HerbError {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        output += ` closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : ""}\n`;
        return output;
    }
}
class QuotesMismatchError extends HerbError {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_quote: data.opening_quote ? Token.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : ""}\n`;
        output += ` closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : ""}\n`;
        return output;
    }
}
class VoidElementClosingTagError extends HerbError {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` expected: ${JSON.stringify(this.expected)}\n`;
        output += ` found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnclosedElementError extends HerbError {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        return output;
    }
}
class RubyParseError extends HerbError {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` error_message: ${JSON.stringify(this.error_message)}\n`;
        output += ` diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += ` level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
}
class ERBControlFlowScopeError extends HerbError {
    keyword;
    static from(data) {
        return new ERBControlFlowScopeError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            keyword: data.keyword,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.keyword = props.keyword;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "ERB_CONTROL_FLOW_SCOPE_ERROR",
            keyword: this.keyword,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBControlFlowScopeError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` keyword: ${JSON.stringify(this.keyword)}\n`;
        return output;
    }
}
class MissingERBEndTagError extends HerbError {
    keyword;
    static from(data) {
        return new MissingERBEndTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            keyword: data.keyword,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.keyword = props.keyword;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSINGERB_END_TAG_ERROR",
            keyword: this.keyword,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingERBEndTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` keyword: ${JSON.stringify(this.keyword)}\n`;
        return output;
    }
}
function fromSerializedError(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError.from(error);
        case "ERB_CONTROL_FLOW_SCOPE_ERROR": return ERBControlFlowScopeError.from(error);
        case "MISSINGERB_END_TAG_ERROR": return MissingERBEndTagError.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}
function convertToUTF8(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/nodes.ts.erb
class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length === 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "   ", isLast, false);
            }
            else {
                const symbol = isLast ? " " : " ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? " " : " ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index === 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
}
class DocumentNode extends Node {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class LiteralNode extends Node {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` content: ${this.content ? JSON.stringify(this.content) : ""}\n`;
        return output;
    }
}
class HTMLOpenTagNode extends Node {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : ""}\n`;
        return output;
    }
}
class HTMLCloseTagNode extends Node {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class HTMLElementNode extends Node {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    source;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_tag: data.open_tag ? fromSerializedNode((data.open_tag)) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            close_tag: data.close_tag ? fromSerializedNode((data.close_tag)) : null,
            is_void: data.is_void,
            source: data.source,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
        this.source = props.source;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
            source: this.source,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` open_tag: ${this.inspectNode(this.open_tag, "   ")}`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` body: ${this.inspectArray(this.body, "   ")}`;
        output += ` close_tag: ${this.inspectNode(this.close_tag, "   ")}`;
        output += ` is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : ""}\n`;
        output += ` source: ${this.source ? JSON.stringify(this.source) : ""}\n`;
        return output;
    }
}
class HTMLAttributeValueNode extends Node {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_quote: data.open_quote ? Token.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            close_quote: data.close_quote ? Token.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` open_quote: ${this.open_quote ? this.open_quote.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` close_quote: ${this.close_quote ? this.close_quote.treeInspect() : ""}\n`;
        output += ` quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : ""}\n`;
        return output;
    }
}
class HTMLAttributeNameNode extends Node {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class HTMLAttributeNode extends Node {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            name: data.name ? fromSerializedNode((data.name)) : null,
            equals: data.equals ? Token.from(data.equals) : null,
            value: data.value ? fromSerializedNode((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` name: ${this.inspectNode(this.name, "   ")}`;
        output += ` equals: ${this.equals ? this.equals.treeInspect() : ""}\n`;
        output += ` value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
}
class HTMLTextNode extends Node {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` content: ${this.content ? JSON.stringify(this.content) : ""}\n`;
        return output;
    }
}
class HTMLCommentNode extends Node {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            comment_start: data.comment_start ? Token.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            comment_end: data.comment_end ? Token.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` comment_start: ${this.comment_start ? this.comment_start.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` comment_end: ${this.comment_end ? this.comment_end.treeInspect() : ""}\n`;
        return output;
    }
}
class HTMLDoctypeNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class XMLDeclarationNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class CDATANode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class WhitespaceNode extends Node {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            value: data.value ? Token.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` value: ${this.value ? this.value.treeInspect() : ""}\n`;
        return output;
    }
}
class ERBContentNode extends Node {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        // no-op for analyzed_ruby
        output += ` parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : ""}\n`;
        output += ` valid: ${typeof this.valid === 'boolean' ? String(this.valid) : ""}\n`;
        return output;
    }
}
class ERBEndNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class ERBElseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBIfNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` subsequent: ${this.inspectNode(this.subsequent, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBBlockNode extends Node {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` body: ${this.inspectArray(this.body, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhenNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBCaseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` conditions: ${this.inspectArray(this.conditions, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBCaseMatchNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` conditions: ${this.inspectArray(this.conditions, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhileNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUntilNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBForNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBRescueNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
}
class ERBEnsureNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBBeginNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` rescue_clause: ${this.inspectNode(this.rescue_clause, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` ensure_clause: ${this.inspectNode(this.ensure_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUnlessNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBYieldNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class ERBInNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
function fromSerializedNode(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode.from(node);
        case "AST_LITERAL_NODE": return LiteralNode.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode.from(node);
        case "AST_CDATA_NODE": return CDATANode.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
}

class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
}

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
class ParseResult extends Result {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode.from(result.value), result.source, result.warnings.map((warning) => HerbWarning.from(warning)), result.errors.map((error) => HerbError.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/node-type-guards.ts.erb
/**
 * Type guard functions for AST nodes.
 * These functions provide type checking by combining both instanceof
 * checks and type string comparisons for maximum reliability across different
 * runtime scenarios (e.g., serialized/deserialized nodes).
 */
/**
 * Checks if a node is a DocumentNode
 */
function isDocumentNode(node) {
    return node instanceof DocumentNode || node.type === "AST_DOCUMENT_NODE" || node.constructor.type === "AST_DOCUMENT_NODE";
}
/**
 * Checks if a node is a LiteralNode
 */
function isLiteralNode(node) {
    return node instanceof LiteralNode || node.type === "AST_LITERAL_NODE" || node.constructor.type === "AST_LITERAL_NODE";
}
/**
 * Checks if a node is a HTMLOpenTagNode
 */
function isHTMLOpenTagNode(node) {
    return node instanceof HTMLOpenTagNode || node.type === "AST_HTML_OPEN_TAG_NODE" || node.constructor.type === "AST_HTML_OPEN_TAG_NODE";
}
/**
 * Checks if a node is a HTMLCloseTagNode
 */
function isHTMLCloseTagNode(node) {
    return node instanceof HTMLCloseTagNode || node.type === "AST_HTML_CLOSE_TAG_NODE" || node.constructor.type === "AST_HTML_CLOSE_TAG_NODE";
}
/**
 * Checks if a node is a HTMLElementNode
 */
function isHTMLElementNode(node) {
    return node instanceof HTMLElementNode || node.type === "AST_HTML_ELEMENT_NODE" || node.constructor.type === "AST_HTML_ELEMENT_NODE";
}
/**
 * Checks if a node is a HTMLAttributeValueNode
 */
function isHTMLAttributeValueNode(node) {
    return node instanceof HTMLAttributeValueNode || node.type === "AST_HTML_ATTRIBUTE_VALUE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNameNode
 */
function isHTMLAttributeNameNode(node) {
    return node instanceof HTMLAttributeNameNode || node.type === "AST_HTML_ATTRIBUTE_NAME_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NAME_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNode
 */
function isHTMLAttributeNode(node) {
    return node instanceof HTMLAttributeNode || node.type === "AST_HTML_ATTRIBUTE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NODE";
}
/**
 * Checks if a node is a HTMLTextNode
 */
function isHTMLTextNode(node) {
    return node instanceof HTMLTextNode || node.type === "AST_HTML_TEXT_NODE" || node.constructor.type === "AST_HTML_TEXT_NODE";
}
/**
 * Checks if a node is a HTMLCommentNode
 */
function isHTMLCommentNode(node) {
    return node instanceof HTMLCommentNode || node.type === "AST_HTML_COMMENT_NODE" || node.constructor.type === "AST_HTML_COMMENT_NODE";
}
/**
 * Checks if a node is a HTMLDoctypeNode
 */
function isHTMLDoctypeNode(node) {
    return node instanceof HTMLDoctypeNode || node.type === "AST_HTML_DOCTYPE_NODE" || node.constructor.type === "AST_HTML_DOCTYPE_NODE";
}
/**
 * Checks if a node is a XMLDeclarationNode
 */
function isXMLDeclarationNode(node) {
    return node instanceof XMLDeclarationNode || node.type === "AST_XML_DECLARATION_NODE" || node.constructor.type === "AST_XML_DECLARATION_NODE";
}
/**
 * Checks if a node is a CDATANode
 */
function isCDATANode(node) {
    return node instanceof CDATANode || node.type === "AST_CDATA_NODE" || node.constructor.type === "AST_CDATA_NODE";
}
/**
 * Checks if a node is a WhitespaceNode
 */
function isWhitespaceNode(node) {
    return node instanceof WhitespaceNode || node.type === "AST_WHITESPACE_NODE" || node.constructor.type === "AST_WHITESPACE_NODE";
}
/**
 * Checks if a node is a ERBContentNode
 */
function isERBContentNode(node) {
    return node instanceof ERBContentNode || node.type === "AST_ERB_CONTENT_NODE" || node.constructor.type === "AST_ERB_CONTENT_NODE";
}
/**
 * Checks if a node is a ERBEndNode
 */
function isERBEndNode(node) {
    return node instanceof ERBEndNode || node.type === "AST_ERB_END_NODE" || node.constructor.type === "AST_ERB_END_NODE";
}
/**
 * Checks if a node is a ERBElseNode
 */
function isERBElseNode(node) {
    return node instanceof ERBElseNode || node.type === "AST_ERB_ELSE_NODE" || node.constructor.type === "AST_ERB_ELSE_NODE";
}
/**
 * Checks if a node is a ERBIfNode
 */
function isERBIfNode(node) {
    return node instanceof ERBIfNode || node.type === "AST_ERB_IF_NODE" || node.constructor.type === "AST_ERB_IF_NODE";
}
/**
 * Checks if a node is a ERBBlockNode
 */
function isERBBlockNode(node) {
    return node instanceof ERBBlockNode || node.type === "AST_ERB_BLOCK_NODE" || node.constructor.type === "AST_ERB_BLOCK_NODE";
}
/**
 * Checks if a node is a ERBWhenNode
 */
function isERBWhenNode(node) {
    return node instanceof ERBWhenNode || node.type === "AST_ERB_WHEN_NODE" || node.constructor.type === "AST_ERB_WHEN_NODE";
}
/**
 * Checks if a node is a ERBCaseNode
 */
function isERBCaseNode(node) {
    return node instanceof ERBCaseNode || node.type === "AST_ERB_CASE_NODE" || node.constructor.type === "AST_ERB_CASE_NODE";
}
/**
 * Checks if a node is a ERBCaseMatchNode
 */
function isERBCaseMatchNode(node) {
    return node instanceof ERBCaseMatchNode || node.type === "AST_ERB_CASE_MATCH_NODE" || node.constructor.type === "AST_ERB_CASE_MATCH_NODE";
}
/**
 * Checks if a node is a ERBWhileNode
 */
function isERBWhileNode(node) {
    return node instanceof ERBWhileNode || node.type === "AST_ERB_WHILE_NODE" || node.constructor.type === "AST_ERB_WHILE_NODE";
}
/**
 * Checks if a node is a ERBUntilNode
 */
function isERBUntilNode(node) {
    return node instanceof ERBUntilNode || node.type === "AST_ERB_UNTIL_NODE" || node.constructor.type === "AST_ERB_UNTIL_NODE";
}
/**
 * Checks if a node is a ERBForNode
 */
function isERBForNode(node) {
    return node instanceof ERBForNode || node.type === "AST_ERB_FOR_NODE" || node.constructor.type === "AST_ERB_FOR_NODE";
}
/**
 * Checks if a node is a ERBRescueNode
 */
function isERBRescueNode(node) {
    return node instanceof ERBRescueNode || node.type === "AST_ERB_RESCUE_NODE" || node.constructor.type === "AST_ERB_RESCUE_NODE";
}
/**
 * Checks if a node is a ERBEnsureNode
 */
function isERBEnsureNode(node) {
    return node instanceof ERBEnsureNode || node.type === "AST_ERB_ENSURE_NODE" || node.constructor.type === "AST_ERB_ENSURE_NODE";
}
/**
 * Checks if a node is a ERBBeginNode
 */
function isERBBeginNode(node) {
    return node instanceof ERBBeginNode || node.type === "AST_ERB_BEGIN_NODE" || node.constructor.type === "AST_ERB_BEGIN_NODE";
}
/**
 * Checks if a node is a ERBUnlessNode
 */
function isERBUnlessNode(node) {
    return node instanceof ERBUnlessNode || node.type === "AST_ERB_UNLESS_NODE" || node.constructor.type === "AST_ERB_UNLESS_NODE";
}
/**
 * Checks if a node is a ERBYieldNode
 */
function isERBYieldNode(node) {
    return node instanceof ERBYieldNode || node.type === "AST_ERB_YIELD_NODE" || node.constructor.type === "AST_ERB_YIELD_NODE";
}
/**
 * Checks if a node is a ERBInNode
 */
function isERBInNode(node) {
    return node instanceof ERBInNode || node.type === "AST_ERB_IN_NODE" || node.constructor.type === "AST_ERB_IN_NODE";
}
/**
 * Checks if a node is any ERB node type
 */
function isERBNode(node) {
    return isERBContentNode(node) ||
        isERBEndNode(node) ||
        isERBElseNode(node) ||
        isERBIfNode(node) ||
        isERBBlockNode(node) ||
        isERBWhenNode(node) ||
        isERBCaseNode(node) ||
        isERBCaseMatchNode(node) ||
        isERBWhileNode(node) ||
        isERBUntilNode(node) ||
        isERBForNode(node) ||
        isERBRescueNode(node) ||
        isERBEnsureNode(node) ||
        isERBBeginNode(node) ||
        isERBUnlessNode(node) ||
        isERBYieldNode(node) ||
        isERBInNode(node);
}
/**
 * Map of node classes to their corresponding type guard functions
 *
 * @example
 * const guard = NODE_TYPE_GUARDS[HTMLTextNode]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const NODE_TYPE_GUARDS = new Map([
    [DocumentNode, isDocumentNode],
    [LiteralNode, isLiteralNode],
    [HTMLOpenTagNode, isHTMLOpenTagNode],
    [HTMLCloseTagNode, isHTMLCloseTagNode],
    [HTMLElementNode, isHTMLElementNode],
    [HTMLAttributeValueNode, isHTMLAttributeValueNode],
    [HTMLAttributeNameNode, isHTMLAttributeNameNode],
    [HTMLAttributeNode, isHTMLAttributeNode],
    [HTMLTextNode, isHTMLTextNode],
    [HTMLCommentNode, isHTMLCommentNode],
    [HTMLDoctypeNode, isHTMLDoctypeNode],
    [XMLDeclarationNode, isXMLDeclarationNode],
    [CDATANode, isCDATANode],
    [WhitespaceNode, isWhitespaceNode],
    [ERBContentNode, isERBContentNode],
    [ERBEndNode, isERBEndNode],
    [ERBElseNode, isERBElseNode],
    [ERBIfNode, isERBIfNode],
    [ERBBlockNode, isERBBlockNode],
    [ERBWhenNode, isERBWhenNode],
    [ERBCaseNode, isERBCaseNode],
    [ERBCaseMatchNode, isERBCaseMatchNode],
    [ERBWhileNode, isERBWhileNode],
    [ERBUntilNode, isERBUntilNode],
    [ERBForNode, isERBForNode],
    [ERBRescueNode, isERBRescueNode],
    [ERBEnsureNode, isERBEnsureNode],
    [ERBBeginNode, isERBBeginNode],
    [ERBUnlessNode, isERBUnlessNode],
    [ERBYieldNode, isERBYieldNode],
    [ERBInNode, isERBInNode],
]);
/**
 * Map of AST node type strings to their corresponding type guard functions
 *
 * @example
 * const guard = AST_TYPE_GUARDS["AST_HTML_TEXT_NODE"]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const AST_TYPE_GUARDS = new Map([
    ["AST_DOCUMENT_NODE", isDocumentNode],
    ["AST_LITERAL_NODE", isLiteralNode],
    ["AST_HTML_OPEN_TAG_NODE", isHTMLOpenTagNode],
    ["AST_HTML_CLOSE_TAG_NODE", isHTMLCloseTagNode],
    ["AST_HTML_ELEMENT_NODE", isHTMLElementNode],
    ["AST_HTML_ATTRIBUTE_VALUE_NODE", isHTMLAttributeValueNode],
    ["AST_HTML_ATTRIBUTE_NAME_NODE", isHTMLAttributeNameNode],
    ["AST_HTML_ATTRIBUTE_NODE", isHTMLAttributeNode],
    ["AST_HTML_TEXT_NODE", isHTMLTextNode],
    ["AST_HTML_COMMENT_NODE", isHTMLCommentNode],
    ["AST_HTML_DOCTYPE_NODE", isHTMLDoctypeNode],
    ["AST_XML_DECLARATION_NODE", isXMLDeclarationNode],
    ["AST_CDATA_NODE", isCDATANode],
    ["AST_WHITESPACE_NODE", isWhitespaceNode],
    ["AST_ERB_CONTENT_NODE", isERBContentNode],
    ["AST_ERB_END_NODE", isERBEndNode],
    ["AST_ERB_ELSE_NODE", isERBElseNode],
    ["AST_ERB_IF_NODE", isERBIfNode],
    ["AST_ERB_BLOCK_NODE", isERBBlockNode],
    ["AST_ERB_WHEN_NODE", isERBWhenNode],
    ["AST_ERB_CASE_NODE", isERBCaseNode],
    ["AST_ERB_CASE_MATCH_NODE", isERBCaseMatchNode],
    ["AST_ERB_WHILE_NODE", isERBWhileNode],
    ["AST_ERB_UNTIL_NODE", isERBUntilNode],
    ["AST_ERB_FOR_NODE", isERBForNode],
    ["AST_ERB_RESCUE_NODE", isERBRescueNode],
    ["AST_ERB_ENSURE_NODE", isERBEnsureNode],
    ["AST_ERB_BEGIN_NODE", isERBBeginNode],
    ["AST_ERB_UNLESS_NODE", isERBUnlessNode],
    ["AST_ERB_YIELD_NODE", isERBYieldNode],
    ["AST_ERB_IN_NODE", isERBInNode],
]);
/**
 * Checks if a node matches any of the provided type identifiers with proper type narrowing
 * Supports AST type strings, node classes, or type guard functions
 *
 * @example
 * if (isAnyOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 *
 * @example
 * if (isAnyOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 */
function isAnyOf(node, ...types) {
    return types.some(type => {
        if (typeof type === 'string') {
            return isNode(node, type);
        }
        else if (typeof type === 'function' && type.prototype && type.prototype.constructor === type && NODE_TYPE_GUARDS.has(type)) {
            return isNode(node, type);
        }
        else if (typeof type === 'function') {
            return type(node);
        }
        else {
            return false;
        }
    });
}
function areAllOfType(nodes, ...types) {
    return nodes.every(node => isAnyOf(node, ...types));
}
function filterNodes(nodes, ...types) {
    if (!nodes)
        return [];
    return nodes.filter(node => isAnyOf(node, ...types));
}
function isNode(node, type) {
    if (!node)
        return false;
    if (typeof type === 'string') {
        const guard = AST_TYPE_GUARDS.get(type);
        return guard ? guard(node) : false;
    }
    else if (typeof type === 'function') {
        const guard = NODE_TYPE_GUARDS.get(type);
        return guard ? guard(node) : false;
    }
    else {
        return false;
    }
}
function isToken(object) {
    return (object instanceof Token) || (object?.constructor?.name === "Token" && "value" in object) || object.type?.startsWith('TOKEN_');
}
function isParseResult(object) {
    return (object instanceof ParseResult) || (object?.constructor?.name === "ParseResult" && "value" in object);
}
/**
 * Filters an array of nodes to only include LiteralNode nodes
 */
function filterLiteralNodes(nodes) {
    return nodes.filter(isLiteralNode);
}
/**
 * Filters an array of nodes to only include WhitespaceNode nodes
 */
function filterWhitespaceNodes(nodes) {
    return nodes.filter(isWhitespaceNode);
}
/**
 * Filters an array of nodes to only include ERBContentNode nodes
 */
function filterERBContentNodes(nodes) {
    return nodes.filter(isERBContentNode);
}

/**
 * Checks if a node is an ERB output node (generates content: <%= %> or <%== %>)
 */
function isERBOutputNode(node) {
    if (!isERBNode(node))
        return false;
    if (!node.tag_opening?.value)
        return false;
    return ["<%=", "<%=="].includes(node.tag_opening?.value);
}
/**
 * Checks if a node is a ERB comment node (control flow: <%# %>)
 */
function isERBCommentNode(node) {
    if (!isERBNode(node))
        return false;
    if (!node.tag_opening?.value)
        return false;
    return node.tag_opening?.value === "<%#" || (node.tag_opening?.value !== "<%#" && (node.content?.value || "").trimStart().startsWith("#"));
}
/**
 * Checks if an array of nodes contains any ERB content nodes
 */
function hasERBContent(nodes) {
    return nodes.some(isERBContentNode);
}
/**
 * Checks if an array of nodes contains any ERB output nodes (dynamic content)
 */
function hasERBOutput(nodes) {
    return nodes.some(isERBOutputNode);
}
/**
 * Extracts a static string from an array of literal nodes
 * Returns null if any node is not a literal node
 */
function getStaticStringFromNodes(nodes) {
    if (!areAllOfType(nodes, LiteralNode)) {
        return null;
    }
    return nodes.map(node => node.content).join("");
}
/**
 * Extracts static content from nodes, including mixed literal/ERB content
 * Returns the concatenated literal content, or null if no literal nodes exist
 */
function getStaticContentFromNodes(nodes) {
    const literalNodes = filterLiteralNodes(nodes);
    if (literalNodes.length === 0) {
        return null;
    }
    return literalNodes.map(node => node.content).join("");
}
/**
 * Checks if nodes are effectively static (only literals and non-output ERB)
 * Non-output ERB like <% if %> doesn't affect static validation
 */
function isEffectivelyStatic(nodes) {
    return !hasERBOutput(nodes);
}
/**
 * Gets static-validatable content from nodes (ignores control ERB, includes literals)
 * Returns concatenated literal content for validation, or null if contains output ERB
 */
function getValidatableStaticContent(nodes) {
    if (hasERBOutput(nodes)) {
        return null;
    }
    return filterLiteralNodes(nodes).map(node => node.content).join("");
}
/**
 * Extracts a combined string from nodes, including ERB content
 * For ERB nodes, includes the full tag syntax (e.g., "<%= foo %>")
 * This is useful for debugging or displaying the full attribute name
 */
function getCombinedStringFromNodes(nodes) {
    return nodes.map(node => {
        if (isLiteralNode(node)) {
            return node.content;
        }
        else if (isERBContentNode(node)) {
            const opening = node.tag_opening?.value || "";
            const content = node.content?.value || "";
            const closing = node.tag_closing?.value || "";
            return `${opening}${content}${closing}`;
        }
        else {
            // For other node types, return a placeholder or empty string
            return `[${node.type}]`;
        }
    }).join("");
}
/**
 * Checks if an HTML attribute name node has dynamic content (contains ERB)
 */
function hasDynamicAttributeName$1(attributeNameNode) {
    if (!attributeNameNode.children) {
        return false;
    }
    return hasERBContent(attributeNameNode.children);
}
/**
 * Gets the static string value of an HTML attribute name node
 * Returns null if the attribute name contains dynamic content (ERB)
 */
function getStaticAttributeName(attributeNameNode) {
    if (!attributeNameNode.children) {
        return null;
    }
    return getStaticStringFromNodes(attributeNameNode.children);
}
/**
 * Gets the combined string representation of an HTML attribute name node
 * This includes both static and dynamic content, useful for debugging
 */
function getCombinedAttributeName(attributeNameNode) {
    if (!attributeNameNode.children) {
        return "";
    }
    return getCombinedStringFromNodes(attributeNameNode.children);
}
/**
 * Gets the tag name of an HTML element node
 */
function getTagName$1(node) {
    return node.tag_name?.value ?? "";
}
/**
 * Check if a node is a comment (HTML comment or ERB comment)
 */
function isCommentNode(node) {
    return isHTMLCommentNode(node) || isERBCommentNode(node);
}
/**
 * Compares two positions to determine if the first comes before the second
 * Returns true if pos1 comes before pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionBefore(position1, position2, inclusive = false) {
    if (position1.line < position2.line)
        return true;
    if (position1.line > position2.line)
        return false;
    return inclusive ? position1.column <= position2.column : position1.column < position2.column;
}
/**
 * Compares two positions to determine if the first comes after the second
 * Returns true if pos1 comes after pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionAfter(position1, position2, inclusive = false) {
    if (position1.line > position2.line)
        return true;
    if (position1.line < position2.line)
        return false;
    return inclusive ? position1.column >= position2.column : position1.column > position2.column;
}
/**
 * Gets nodes that end before the specified position
 * @param inclusive - If true, includes nodes that end exactly at the position (default: false, matching half-open interval semantics)
 */
function getNodesBeforePosition(nodes, position, inclusive = false) {
    return nodes.filter(node => node.location && isPositionBefore(node.location.end, position, inclusive));
}
/**
 * Gets nodes that start after the specified position
 * @param inclusive - If true, includes nodes that start exactly at the position (default: true, matching typical boundary behavior)
 */
function getNodesAfterPosition(nodes, position, inclusive = true) {
    return nodes.filter(node => node.location && isPositionAfter(node.location.start, position, inclusive));
}

/*
 * The following code is derived from the "js-levenshtein" repository,
 * Copyright (c) 2017 Gustaf Andersson (https://github.com/gustf/js-levenshtein)
 * Licensed under the MIT License (https://github.com/gustf/js-levenshtein/blob/master/LICENSE).
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * https://github.com/marcoroth/stimulus-lsp/blob/52268d4a4d06504dde6cb81f505a23b5db5d5759/server/src/levenshtein.ts
 *
 */
function levenshtein(a, b) {
    function _min(d0, d1, d2, bx, ay) {
        return d0 < d1 || d2 < d1 ? (d0 > d2 ? d2 + 1 : d0 + 1) : bx === ay ? d1 : d1 + 1;
    }
    if (a === b) {
        return 0;
    }
    if (a.length > b.length) {
        const tmp = a;
        a = b;
        b = tmp;
    }
    let la = a.length;
    let lb = b.length;
    while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
        la--;
        lb--;
    }
    let offset = 0;
    while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
        offset++;
    }
    la -= offset;
    lb -= offset;
    if (la === 0 || lb < 3) {
        return lb;
    }
    let x = 0;
    let y;
    let d0;
    let d1;
    let d2;
    let d3;
    let dd;
    let dy;
    let ay;
    let bx0;
    let bx1;
    let bx2;
    let bx3;
    const vector = [];
    for (y = 0; y < la; y++) {
        vector.push(y + 1);
        vector.push(a.charCodeAt(offset + y));
    }
    const len = vector.length - 1;
    for (; x < lb - 3;) {
        bx0 = b.charCodeAt(offset + (d0 = x));
        bx1 = b.charCodeAt(offset + (d1 = x + 1));
        bx2 = b.charCodeAt(offset + (d2 = x + 2));
        bx3 = b.charCodeAt(offset + (d3 = x + 3));
        dd = x += 4;
        for (y = 0; y < len; y += 2) {
            dy = vector[y];
            ay = vector[y + 1];
            d0 = _min(dy, d0, d1, bx0, ay);
            d1 = _min(d0, d1, d2, bx1, ay);
            d2 = _min(d1, d2, d3, bx2, ay);
            dd = _min(d2, d3, dd, bx3, ay);
            vector[y] = dd;
            d3 = d2;
            d2 = d1;
            d1 = d0;
            d0 = dy;
        }
    }
    for (; x < lb;) {
        bx0 = b.charCodeAt(offset + (d0 = x));
        dd = ++x;
        for (y = 0; y < len; y += 2) {
            dy = vector[y];
            vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
            d0 = dy;
        }
    }
    return dd;
}

/**
 * Ranks a list of strings by their Levenshtein distance from the input string.
 * Items are sorted in ascending order by distance, with closer matches first.
 *
 * @param input - The string to compare against
 * @param list - The list of strings to rank
 * @returns An array of objects containing the item and its distance score, sorted by score
 */
function rank(input, list) {
    return list.map(item => {
        const score = levenshtein(input.toLowerCase(), item.toLowerCase());
        return { item, score };
    }).sort((a, b) => a.score - b.score);
}
/**
 * Finds the closest matching string from a list using Levenshtein distance.
 * Performs case-insensitive comparison.
 *
 * @param input - The string to match against
 * @param list - The list of candidate strings to search
 * @param threshold - Maximum Levenshtein distance to consider a match. If undefined, returns the closest match regardless of distance.
 * @returns The closest matching string from the list, or null if the list is empty or no match is within the threshold
 *
 * @example
 * ```ts
 * didyoumean('speling', ['spelling', 'writing', 'reading']) // Returns 'spelling'
 * didyoumean('test', []) // Returns null
 * didyoumean('speling', ['spelling', 'writing', 'reading'], 2) // Returns 'spelling' (distance: 1)
 * didyoumean('xyz', ['spelling', 'writing', 'reading'], 2) // Returns null (all distances > 2)
 * ```
 */
function didyoumean(input, list, threshold) {
    if (list.length === 0)
        return null;
    const scores = rank(input, list);
    if (scores.length === 0)
        return null;
    const closest = scores[0];
    return closest.item;
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/visitor.ts.erb
class Visitor {
    visit(node) {
        if (!node)
            return;
        node.accept(this);
    }
    visitAll(nodes) {
        nodes.forEach(node => node?.accept(this));
    }
    visitChildNodes(node) {
        node.compactChildNodes().forEach(node => node.accept(this));
    }
    visitNode(_node) {
        // Default implementation does nothing
    }
    visitERBNode(_node) {
        // Default implementation does nothing
    }
    visitDocumentNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitLiteralNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLOpenTagNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLCloseTagNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLElementNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNameNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLTextNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLCommentNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLDoctypeNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitXMLDeclarationNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitCDATANode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitWhitespaceNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBIfNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBBlockNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBWhenNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBCaseNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBWhileNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBUntilNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBForNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBRescueNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBEnsureNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBBeginNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBYieldNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBInNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
}

class PrintContext {
    output = "";
    indentLevel = 0;
    currentColumn = 0;
    preserveStack = [];
    /**
     * Write text to the output
     */
    write(text) {
        this.output += text;
        this.currentColumn += text.length;
    }
    /**
     * Write text and update column tracking for newlines
     */
    writeWithColumnTracking(text) {
        this.output += text;
        const lines = text.split('\n');
        if (lines.length > 1) {
            this.currentColumn = lines[lines.length - 1].length;
        }
        else {
            this.currentColumn += text.length;
        }
    }
    /**
     * Increase indentation level
     */
    indent() {
        this.indentLevel++;
    }
    /**
     * Decrease indentation level
     */
    dedent() {
        if (this.indentLevel > 0) {
            this.indentLevel--;
        }
    }
    /**
     * Enter a tag that may preserve whitespace
     */
    enterTag(tagName) {
        this.preserveStack.push(tagName.toLowerCase());
    }
    /**
     * Exit the current tag
     */
    exitTag() {
        this.preserveStack.pop();
    }
    /**
     * Check if we're at the start of a line
     */
    isAtStartOfLine() {
        return this.currentColumn === 0;
    }
    /**
     * Get current indentation level
     */
    getCurrentIndentLevel() {
        return this.indentLevel;
    }
    /**
     * Get current column position
     */
    getCurrentColumn() {
        return this.currentColumn;
    }
    /**
     * Get the current tag stack (for debugging)
     */
    getTagStack() {
        return [...this.preserveStack];
    }
    /**
     * Get the complete output string
     */
    getOutput() {
        return this.output;
    }
    /**
     * Reset the context for reuse
     */
    reset() {
        this.output = "";
        this.indentLevel = 0;
        this.currentColumn = 0;
        this.preserveStack = [];
    }
}

/**
 * Default print options used when none are provided
 */
const DEFAULT_PRINT_OPTIONS = {
    ignoreErrors: false
};
class Printer extends Visitor {
    context = new PrintContext();
    /**
     * Static method to print a node without creating an instance
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    static print(input, options = DEFAULT_PRINT_OPTIONS) {
        const printer = new this();
        return printer.print(input, options);
    }
    /**
     * Print a node, token, or parse result to a string
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    print(input, options = DEFAULT_PRINT_OPTIONS) {
        if (!input)
            return "";
        if (isToken(input)) {
            return input.value;
        }
        if (Array.isArray(input)) {
            this.context.reset();
            input.forEach(node => this.visit(node));
            return this.context.getOutput();
        }
        const node = isParseResult(input) ? input.value : input;
        if (options.ignoreErrors === false && node.recursiveErrors().length > 0) {
            throw new Error(`Cannot print the node (${node.type}) since it or any of its children has parse errors. Either pass in a valid Node or call \`print()\` using \`print(node, { ignoreErrors: true })\``);
        }
        this.context.reset();
        this.visit(node);
        return this.context.getOutput();
    }
    write(content) {
        this.context.write(content);
    }
}

/**
 * IdentityPrinter - Provides lossless reconstruction of the original source
 *
 * This printer aims to reconstruct the original input as faithfully as possible,
 * preserving all whitespace, formatting, and structure. It's useful for:
 * - Testing parser accuracy (input should equal output)
 * - Baseline printing before applying transformations
 * - Verifying AST round-trip fidelity
 */
class IdentityPrinter extends Printer {
    static printERBNode(node) {
        const printer = new IdentityPrinter();
        printer.printERBNode(node);
        return printer.context.getOutput();
    }
    visitLiteralNode(node) {
        this.write(node.content);
    }
    visitHTMLTextNode(node) {
        this.write(node.content);
    }
    visitWhitespaceNode(node) {
        if (node.value) {
            this.write(node.value.value);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            this.write(node.tag_name.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLCloseTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            const before = getNodesBeforePosition(node.children, node.tag_name.location.start, true);
            const after = getNodesAfterPosition(node.children, node.tag_name.location.end);
            this.visitAll(before);
            this.write(node.tag_name.value);
            this.visitAll(after);
        }
        else {
            this.visitAll(node.children);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName) {
            this.context.enterTag(tagName);
        }
        if (node.open_tag) {
            this.visit(node.open_tag);
        }
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        if (tagName) {
            this.context.exitTag();
        }
    }
    visitHTMLAttributeNode(node) {
        if (node.name) {
            this.visit(node.name);
        }
        if (node.equals) {
            this.write(node.equals.value);
        }
        if (node.equals && node.value) {
            this.visit(node.value);
        }
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        if (node.quoted && node.open_quote) {
            this.write(node.open_quote.value);
        }
        this.visitChildNodes(node);
        if (node.quoted && node.close_quote) {
            this.write(node.close_quote.value);
        }
    }
    visitHTMLCommentNode(node) {
        if (node.comment_start) {
            this.write(node.comment_start.value);
        }
        this.visitChildNodes(node);
        if (node.comment_end) {
            this.write(node.comment_end.value);
        }
    }
    visitHTMLDoctypeNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitXMLDeclarationNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitCDATANode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitERBContentNode(node) {
        this.printERBNode(node);
    }
    visitERBIfNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.rescue_clause) {
            this.visit(node.rescue_clause);
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.ensure_clause) {
            this.visit(node.ensure_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    /**
     * Print ERB node tags and content
     */
    printERBNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.content) {
            this.write(node.content.value);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
}

const DEFAULT_ERB_TO_RUBY_STRING_OPTIONS = {
    ...DEFAULT_PRINT_OPTIONS,
    forceQuotes: false
};
/**
 * ERBToRubyStringPrinter - Converts ERB snippets to Ruby strings with interpolation
 *
 * This printer transforms ERB templates into Ruby strings by:
 * - Converting literal text to string content
 * - Converting <%= %> tags to #{} interpolation
 * - Converting simple if/else blocks to ternary operators
 * - Ignoring <% %> tags (they don't produce output)
 *
 * Examples:
 * - `hello world <%= hello %>` => `"hello world #{hello}"`
 * - `hello world <% hello %>` => `"hello world "`
 * - `Welcome <%= user.name %>!` => `"Welcome #{user.name}!"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>` => `"logged_in? ? "Welcome" : "Login"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>!` => `"#{logged_in? ? "Welcome" : "Login"}!"`
 */
class ERBToRubyStringPrinter extends IdentityPrinter {
    // TODO: cleanup `.type === "AST_*" checks`
    static print(node, options = DEFAULT_ERB_TO_RUBY_STRING_OPTIONS) {
        const erbNodes = filterNodes([node], ERBContentNode);
        if (erbNodes.length === 1 && isERBOutputNode(erbNodes[0]) && !options.forceQuotes) {
            return (erbNodes[0].content?.value || "").trim();
        }
        if ('children' in node && Array.isArray(node.children)) {
            const childErbNodes = filterNodes(node.children, ERBContentNode);
            const hasOnlyERBContent = node.children.length > 0 && node.children.length === childErbNodes.length;
            if (hasOnlyERBContent && childErbNodes.length === 1 && isERBOutputNode(childErbNodes[0]) && !options.forceQuotes) {
                return (childErbNodes[0].content?.value || "").trim();
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_IF_NODE" && !options.forceQuotes) {
                const ifNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertToTernary(ifNode)) {
                    printer.convertToTernaryWithoutWrapper(ifNode);
                    return printer.context.getOutput();
                }
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_UNLESS_NODE" && !options.forceQuotes) {
                const unlessNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertUnlessToTernary(unlessNode)) {
                    printer.convertUnlessToTernaryWithoutWrapper(unlessNode);
                    return printer.context.getOutput();
                }
            }
        }
        const printer = new ERBToRubyStringPrinter();
        printer.context.write('"');
        printer.visit(node);
        printer.context.write('"');
        return printer.context.getOutput();
    }
    visitHTMLTextNode(node) {
        if (node.content) {
            const escapedContent = node.content.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            this.context.write(escapedContent);
        }
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.context.write("#{");
            if (node.content?.value) {
                this.context.write(node.content.value.trim());
            }
            this.context.write("}");
        }
    }
    visitERBIfNode(node) {
        if (this.canConvertToTernary(node)) {
            this.convertToTernary(node);
        }
    }
    visitERBUnlessNode(node) {
        if (this.canConvertUnlessToTernary(node)) {
            this.convertUnlessToTernary(node);
        }
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    canConvertToTernary(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        const ifOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!ifOnlyText)
            return false;
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE") {
            return node.subsequent.statements
                ? node.subsequent.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertToTernaryWithoutWrapper(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
    canConvertUnlessToTernary(node) {
        const unlessOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!unlessOnlyText)
            return false;
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            return node.else_clause.statements
                ? node.else_clause.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertUnlessToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertUnlessToTernaryWithoutWrapper(node) {
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
}

/**
 * Default configuration for rules when defaultConfig is not specified.
 * Custom rules can omit defaultConfig and will use these defaults.
 */
const DEFAULT_RULE_CONFIG = {
    enabled: true,
    severity: "error",
    exclude: []
};
/**
 * Base class for parser rules.
 */
class ParserRule {
    static type = "parser";
    /** Indicates whether this rule supports autofix. Defaults to false. */
    static autocorrectable = false;
    get defaultConfig() {
        return DEFAULT_RULE_CONFIG;
    }
}
/**
 * Default context object with all keys defined but set to undefined
 */
const DEFAULT_LINT_CONTEXT = {
    fileName: undefined,
    validRuleNames: undefined,
    ignoredOffensesByLine: undefined,
    ignoreDisableComments: undefined
};
class SourceRule {
    static type = "source";
    /** Indicates whether this rule supports autofix. Defaults to false. */
    static autocorrectable = false;
    get defaultConfig() {
        return DEFAULT_RULE_CONFIG;
    }
}

var ControlFlowType;
(function (ControlFlowType) {
    ControlFlowType[ControlFlowType["CONDITIONAL"] = 0] = "CONDITIONAL";
    ControlFlowType[ControlFlowType["LOOP"] = 1] = "LOOP";
})(ControlFlowType || (ControlFlowType = {}));
/**
 * Base visitor class that provides common functionality for rule visitors
 */
class BaseRuleVisitor extends Visitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        super();
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create an unbound lint offense (without severity).
     * The Linter will bind severity based on the rule's config.
     */
    createOffense(message, location, autofixContext) {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            autofixContext,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, autofixContext) {
        this.offenses.push(this.createOffense(message, location, autofixContext));
    }
}
/**
 * Mixin that adds control flow tracking capabilities to rule visitors
 * This allows rules to track state across different control flow structures
 * like if/else branches, loops, etc.
 *
 * @template TAutofixContext - Type for autofix context (node + custom data)
 * @template TControlFlowState - Type for state passed between onEnterControlFlow and onExitControlFlow
 * @template TBranchState - Type for state passed between onEnterBranch and onExitBranch
 */
class ControlFlowTrackingVisitor extends BaseRuleVisitor {
    isInControlFlow = false;
    currentControlFlowType = null;
    /**
     * Handle visiting a control flow node with proper scope management
     */
    handleControlFlowNode(_node, controlFlowType, visitChildren) {
        const wasInControlFlow = this.isInControlFlow;
        const previousControlFlowType = this.currentControlFlowType;
        this.isInControlFlow = true;
        this.currentControlFlowType = controlFlowType;
        const stateToRestore = this.onEnterControlFlow(controlFlowType, wasInControlFlow);
        visitChildren();
        this.onExitControlFlow(controlFlowType, wasInControlFlow, stateToRestore);
        this.isInControlFlow = wasInControlFlow;
        this.currentControlFlowType = previousControlFlowType;
    }
    /**
     * Handle visiting a branch node (like else, when) with proper scope management
     */
    startNewBranch(visitChildren) {
        const stateToRestore = this.onEnterBranch();
        visitChildren();
        this.onExitBranch(stateToRestore);
    }
    visitERBIfNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBIfNode(node));
    }
    visitERBUnlessNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBUnlessNode(node));
    }
    visitERBCaseNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseNode(node));
    }
    visitERBCaseMatchNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseMatchNode(node));
    }
    visitERBWhileNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBWhileNode(node));
    }
    visitERBForNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBForNode(node));
    }
    visitERBUntilNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBUntilNode(node));
    }
    visitERBBlockNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBBlockNode(node));
    }
    visitERBElseNode(node) {
        this.startNewBranch(() => super.visitERBElseNode(node));
    }
    visitERBWhenNode(node) {
        this.startNewBranch(() => super.visitERBWhenNode(node));
    }
}
/**
 * Gets attributes from an HTMLOpenTagNode
 */
function getAttributes(node) {
    return node.children.filter(node => node.type === "AST_HTML_ATTRIBUTE_NODE");
}
/**
 * Gets the tag name from an HTML tag node (lowercased)
 */
function getTagName(node) {
    if (!node)
        return null;
    return node.tag_name?.value.toLowerCase() || null;
}
/**
 * Gets the attribute name from an HTMLAttributeNode (lowercased)
 * Returns null if the attribute name contains dynamic content (ERB)
 */
function getAttributeName(attributeNode, lowercase = true) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        const staticName = getStaticAttributeName(nameNode);
        if (!lowercase)
            return staticName;
        return staticName ? staticName.toLowerCase() : null;
    }
    return null;
}
/**
 * Checks if an attribute has a dynamic (ERB-containing) name
 */
function hasDynamicAttributeName(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return hasDynamicAttributeName$1(nameNode);
    }
    return false;
}
/**
 * Gets the combined string representation of an attribute name (for debugging)
 * This includes both static content and ERB syntax
 */
function getCombinedAttributeNameString(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return getCombinedAttributeName(nameNode);
    }
    return "";
}
/**
 * Checks if an attribute value contains only static content (no ERB)
 */
function hasStaticAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (!valueNode?.children)
        return false;
    return valueNode.children.every(child => child.type === "AST_LITERAL_NODE");
}
/**
 * Gets the static string value of an attribute (returns null if it contains ERB)
 */
function getStaticAttributeValue(attributeNode) {
    if (!hasStaticAttributeValue(attributeNode))
        return null;
    const valueNode = attributeNode.value;
    const result = valueNode.children
        ?.filter(child => child.type === "AST_LITERAL_NODE")
        .map(child => child.content)
        .join("") || "";
    return result;
}
/**
 * Gets the value nodes array for dynamic inspection
 */
function getAttributeValueNodes(attributeNode) {
    const valueNode = attributeNode.value;
    return valueNode?.children || [];
}
/**
 * Gets the static content of an attribute value (all literal parts combined)
 * Returns the concatenated literal content, or null if no literal nodes exist
 */
function getStaticAttributeValueContent(attributeNode) {
    const valueNodes = getAttributeValueNodes(attributeNode);
    return getStaticContentFromNodes(valueNodes);
}
/**
 * Gets the attribute value content from an HTMLAttributeValueNode
 */
function getAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (valueNode === null)
        return null;
    if (valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE" || !valueNode.children?.length) {
        return null;
    }
    let result = "";
    for (const child of valueNode.children) {
        switch (child.type) {
            case "AST_ERB_CONTENT_NODE": {
                const erbNode = child;
                if (erbNode.content) {
                    result += `${erbNode.tag_opening?.value}${erbNode.content.value}${erbNode.tag_closing?.value}`;
                }
                break;
            }
            case "AST_LITERAL_NODE": {
                result += child.content;
                break;
            }
        }
    }
    return result;
}
/**
 * Checks if an attribute has a value
 */
function hasAttributeValue(attributeNode) {
    return attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Gets the quote type used for an attribute value
 */
function getAttributeValueQuoteType(nodeOrAttribute) {
    let valueNode;
    if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_NODE") {
        const attributeNode = nodeOrAttribute;
        if (attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
            valueNode = attributeNode.value;
        }
    }
    else if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
        valueNode = nodeOrAttribute;
    }
    if (valueNode) {
        if (valueNode.quoted && valueNode.open_quote) {
            return valueNode.open_quote.value === '"' ? "double" : "single";
        }
        return "none";
    }
    return null;
}
/**
 * Finds an attribute by name in a list of attributes
 */
function findAttributeByName(attributes, attributeName) {
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            const attributeNode = child;
            const name = getAttributeName(attributeNode);
            if (name === attributeName.toLowerCase()) {
                return attributeNode;
            }
        }
    }
    return null;
}
/**
 * Checks if a tag has a specific attribute
 */
function hasAttribute(node, attributeName) {
    if (!node)
        return false;
    return getAttribute(node, attributeName) !== null;
}
/**
 * Checks if a tag has a specific attribute
 */
function getAttribute(node, attributeName) {
    const attributes = getAttributes(node);
    return findAttributeByName(attributes, attributeName);
}
/**
 * Common HTML element categorization
 */
const HTML_INLINE_ELEMENTS = new Set([
    "a", "abbr", "acronym", "b", "bdo", "big", "br", "button", "cite", "code",
    "dfn", "em", "i", "img", "input", "kbd", "label", "map", "object", "output",
    "q", "samp", "script", "select", "small", "span", "strong", "sub", "sup",
    "textarea", "time", "tt", "var"
]);
const HTML_BLOCK_ELEMENTS = new Set([
    "address", "article", "aside", "blockquote", "canvas", "dd", "div", "dl",
    "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2",
    "h3", "h4", "h5", "h6", "header", "hr", "li", "main", "nav", "noscript",
    "ol", "p", "pre", "section", "table", "tfoot", "ul", "video"
]);
const HTML_VOID_ELEMENTS = new Set([
    "area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta",
    "param", "source", "track", "wbr",
]);
const HTML_BOOLEAN_ATTRIBUTES = new Set([
    "autofocus", "autoplay", "checked", "controls", "defer", "disabled", "hidden",
    "loop", "multiple", "muted", "readonly", "required", "reversed", "selected",
    "open", "default", "formnovalidate", "novalidate", "itemscope", "scoped",
    "seamless", "allowfullscreen", "async", "compact", "declare", "nohref",
    "noresize", "noshade", "nowrap", "sortable", "truespeed", "typemustmatch"
]);
const HEADING_TAGS = new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
/**
 * SVG elements that use camelCase naming
 */
const SVG_CAMEL_CASE_ELEMENTS = new Set([
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
]);
/**
 * Mapping from lowercase SVG element names to their correct camelCase versions
 * Generated dynamically from SVG_CAMEL_CASE_ELEMENTS
 */
const SVG_LOWERCASE_TO_CAMELCASE = new Map(Array.from(SVG_CAMEL_CASE_ELEMENTS).map(element => [element.toLowerCase(), element]));
const VALID_ARIA_ROLES = new Set([
    "banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search",
    "article", "cell", "columnheader", "definition", "directory", "document", "feed", "figure",
    "group", "heading", "img", "list", "listitem", "math", "none", "note", "presentation",
    "row", "rowgroup", "rowheader", "separator", "table", "term", "tooltip",
    "alert", "alertdialog", "button", "checkbox", "combobox", "dialog", "grid", "gridcell", "link",
    "listbox", "menu", "menubar", "menuitem", "menuitemcheckbox", "menuitemradio", "option",
    "progressbar", "radio", "radiogroup", "scrollbar", "searchbox", "slider", "spinbutton",
    "status", "switch", "tab", "tablist", "tabpanel", "textbox", "timer", "toolbar", "tree",
    "treegrid", "treeitem",
    "log", "marquee"
]);
const ARIA_ATTRIBUTES = new Set([
    'aria-activedescendant',
    'aria-atomic',
    'aria-autocomplete',
    'aria-busy',
    'aria-checked',
    'aria-colcount',
    'aria-colindex',
    'aria-colspan',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-disabled',
    'aria-dropeffect',
    'aria-errormessage',
    'aria-expanded',
    'aria-flowto',
    'aria-grabbed',
    'aria-haspopup',
    'aria-hidden',
    'aria-invalid',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-level',
    'aria-live',
    'aria-modal',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-owns',
    'aria-placeholder',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-roledescription',
    'aria-rowcount',
    'aria-rowindex',
    'aria-rowspan',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
]);
/**
 * Helper function to create a location at the end of the source with a 1-character range
 */
function createEndOfFileLocation(source) {
    const lines = source.split('\n');
    const lastLineNumber = lines.length;
    const lastLine = lines[lines.length - 1];
    const lastColumnNumber = lastLine.length;
    const startColumn = lastColumnNumber > 0 ? lastColumnNumber - 1 : 0;
    return Location.from(lastLineNumber, startColumn, lastLineNumber, lastColumnNumber);
}
/**
 * Checks if an element is inline
 */
function isInlineElement(tagName) {
    return HTML_INLINE_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an element is block-level
 */
function isBlockElement(tagName) {
    return HTML_BLOCK_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an element is a void element
 */
function isVoidElement(tagName) {
    return HTML_VOID_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an attribute is a boolean attribute
 */
function isBooleanAttribute(attributeName) {
    return HTML_BOOLEAN_ATTRIBUTES.has(attributeName.toLowerCase());
}
/**
 * Attribute visitor that provides granular processing based on both
 * attribute name type (static/dynamic) and value type (static/dynamic)
 *
 * This gives you 4 distinct methods to override:
 * - checkStaticAttributeStaticValue()   - name="class" value="foo"
 * - checkStaticAttributeDynamicValue()  - name="class" value="<%= css_class %>"
 * - checkDynamicAttributeStaticValue()  - name="data-<%= key %>" value="foo"
 * - checkDynamicAttributeDynamicValue() - name="data-<%= key %>" value="<%= value %>"
 */
class AttributeVisitorMixin extends BaseRuleVisitor {
    constructor(ruleName, context) {
        super(ruleName, context);
    }
    visitHTMLOpenTagNode(node) {
        this.checkAttributesOnNode(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAttributesOnNode(node) {
        forEachAttribute(node, (attributeNode) => {
            const staticAttributeName = getAttributeName(attributeNode);
            const originalAttributeName = getAttributeName(attributeNode, false) || "";
            const isDynamicName = hasDynamicAttributeName(attributeNode);
            const staticAttributeValue = getStaticAttributeValue(attributeNode);
            const valueNodes = getAttributeValueNodes(attributeNode);
            const hasOutputERB = hasERBOutput(valueNodes);
            const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
            if (staticAttributeName && staticAttributeValue !== null) {
                this.checkStaticAttributeStaticValue({
                    attributeName: staticAttributeName,
                    attributeValue: staticAttributeValue,
                    attributeNode,
                    originalAttributeName,
                    parentNode: node
                });
            }
            else if (staticAttributeName && isEffectivelyStaticValue && !hasOutputERB) {
                const validatableContent = getValidatableStaticContent(valueNodes) || "";
                this.checkStaticAttributeStaticValue({ attributeName: staticAttributeName, attributeValue: validatableContent, attributeNode, originalAttributeName, parentNode: node });
            }
            else if (staticAttributeName && hasOutputERB) {
                const combinedValue = getAttributeValue(attributeNode);
                this.checkStaticAttributeDynamicValue({ attributeName: staticAttributeName, valueNodes, attributeNode, parentNode: node, originalAttributeName, combinedValue });
            }
            else if (isDynamicName && staticAttributeValue !== null) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                this.checkDynamicAttributeStaticValue({ nameNodes, attributeValue: staticAttributeValue, attributeNode, parentNode: node, combinedName });
            }
            else if (isDynamicName) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                const combinedValue = getAttributeValue(attributeNode);
                this.checkDynamicAttributeDynamicValue({ nameNodes, valueNodes, attributeNode, parentNode: node, combinedName, combinedValue });
            }
        });
    }
    /**
     * Static attribute name with static value: class="container"
     */
    checkStaticAttributeStaticValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Static attribute name with dynamic value: class="<%= css_class %>"
     */
    checkStaticAttributeDynamicValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with static value: data-<%= key %>="foo"
     */
    checkDynamicAttributeStaticValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with dynamic value: data-<%= key %>="<%= value %>"
     */
    checkDynamicAttributeDynamicValue(_params) {
        // Default implementation does nothing
    }
}
/**
 * Iterates over all attributes of a tag node, calling the callback for each attribute
 */
function forEachAttribute(node, callback) {
    const attributes = getAttributes(node);
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            callback(child);
        }
    }
}
/**
 * Base source visitor class that provides common functionality for source-based rule visitors
 */
class BaseSourceRuleVisitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create an unbound lint offense (without severity).
     * The Linter will bind severity based on the rule's config.
     */
    createOffense(message, location, autofixContext) {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            autofixContext,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, autofixContext) {
        this.offenses.push(this.createOffense(message, location, autofixContext));
    }
    /**
     * Main entry point for source rule visitors
     * @param source - The raw source code
     */
    visit(source) {
        this.visitSource(source);
    }
}
/**
 * Autofix utilities for applying string replacements
 */
/**
 * Checks if two locations are equal
 * @param a - First location
 * @param b - Second location
 * @returns true if locations are equal
 */
function locationsEqual(a, b) {
    return a.start.line === b.start.line &&
        a.start.column === b.start.column &&
        a.end.line === b.end.line &&
        a.end.column === b.end.column;
}
/**
 * Finds a node in the AST that has a specific location
 * Uses direct recursive traversal for reliability
 * @param root - The root node to search from
 * @param location - The location to match
 * @param predicate - Optional predicate function to filter nodes (e.g., isERBNode)
 * @returns The matching node or null if not found
 */
function findNodeByLocation(root, location, predicate) {
    const visited = new Set();
    function search(node) {
        if (!node || visited.has(node))
            return null;
        visited.add(node);
        if (node.location && locationsEqual(node.location, location)) {
            if (!predicate || predicate(node)) {
                return node;
            }
        }
        const propsToCheck = ['tag_opening', 'tag_closing', 'tag_name', 'name', 'equals', 'value', 'content'];
        for (const prop of propsToCheck) {
            if (node[prop]?.location && locationsEqual(node[prop].location, location)) {
                if (!predicate || predicate(node)) {
                    return node;
                }
            }
        }
        if (typeof node.compactChildNodes === 'function') {
            for (const child of node.compactChildNodes()) {
                const found = search(child);
                if (found)
                    return found;
            }
        }
        else {
            if (node.children && Array.isArray(node.children)) {
                for (const child of node.children) {
                    const found = search(child);
                    if (found)
                        return found;
                }
            }
            if (node.body && Array.isArray(node.body)) {
                for (const child of node.body) {
                    const found = search(child);
                    if (found)
                        return found;
                }
            }
        }
        return null;
    }
    return search(root);
}
/**
 * AST Navigation Utilities
 * These utilities help navigate the AST tree for complex autofix operations
 */
/**
 * Finds the parent node of a given child node in the AST
 * @param root - The root node to search from (typically the document node)
 * @param target - The child node to find the parent of
 * @returns The parent node, or null if not found
 *
 * @example
 * const parent = findParent(result.value, offense.autofixContext.node)
 * if (parent?.type === "AST_HTML_ELEMENT_NODE") {
 *   // Modify parent...
 * }
 */
function findParent(root, target) {
    let parentNode = null;
    const search = (node, _parent = null) => {
        if (parentNode)
            return;
        const nodeAny = node;
        if (nodeAny.children) {
            for (const child of nodeAny.children) {
                if (child === target) {
                    parentNode = node;
                    return;
                }
            }
        }
        const propsToCheck = ['open_tag', 'close_tag', 'body', 'name', 'value'];
        for (const prop of propsToCheck) {
            const value = node[prop];
            if (value === target) {
                parentNode = node;
                return;
            }
            if (Array.isArray(value) && value.includes(target)) {
                parentNode = node;
                return;
            }
        }
        if (nodeAny.children) {
            for (const child of nodeAny.children) {
                search(child, node);
                if (parentNode)
                    return;
            }
        }
        for (const prop of propsToCheck) {
            const value = node[prop];
            if (Array.isArray(value)) {
                for (const item of value) {
                    if (item && typeof item === 'object' && 'type' in item) {
                        search(item, node);
                        if (parentNode)
                            return;
                    }
                }
            }
            else if (value && typeof value === 'object' && 'type' in value) {
                search(value, node);
                if (parentNode)
                    return;
            }
        }
    };
    search(root);
    return parentNode;
}
const DOCUMENT_ONLY_TAG_NAMES = new Set([
    "html"
]);
const HTML_ONLY_TAG_NAMES = new Set([
    "head", "body"
]);
const HEAD_ONLY_TAG_NAMES = new Set([
    "base",
    "title",
    "style",
    "meta",
    "link",
]);
const HEAD_AND_BODY_TAG_NAMES = new Set([
    "script",
    "noscript",
    "template",
]);
function isDocumentOnlyTag(tagName) {
    return DOCUMENT_ONLY_TAG_NAMES.has(tagName.toLowerCase());
}
function isHtmlOnlyTag(tagName) {
    return HTML_ONLY_TAG_NAMES.has(tagName.toLowerCase());
}
function isHeadOnlyTag(tagName) {
    return HEAD_ONLY_TAG_NAMES.has(tagName.toLowerCase());
}
function isHeadAndBodyTag(tagName) {
    return HEAD_AND_BODY_TAG_NAMES.has(tagName.toLowerCase());
}
function isBodyOnlyTag(tagName) {
    const tag = tagName.toLowerCase();
    return (!isDocumentOnlyTag(tag) &&
        !isHtmlOnlyTag(tag) &&
        !isHeadOnlyTag(tag) &&
        !isHeadAndBodyTag(tag));
}

class ERBCommentSyntaxVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        const content = node.content?.value || "";
        if (content.match(/^ +#/)) {
            const openingTag = node.tag_opening?.value;
            if (content.includes("herb:disable")) {
                this.addOffense(`Use \`<%#\` instead of \`${openingTag} #\` for \`herb:disable\` directives. Herb directives only work with ERB comment syntax (\`<%# ... %>\`).`, node.location, { node });
            }
            else {
                this.addOffense(`Use \`<%#\` instead of \`${openingTag} #\`. Ruby comments immediately after ERB tags can cause parsing issues.`, node.location, { node });
            }
        }
    }
}
class ERBCommentSyntax extends ParserRule {
    static autocorrectable = true;
    name = "erb-comment-syntax";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBCommentSyntaxVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node } = offense.autofixContext;
        if (!node.tag_opening)
            return null;
        if (!node.content)
            return null;
        node.tag_opening.value = "<%#";
        const content = node.content.value;
        const match = content.match(/^ +(#)/);
        if (match) {
            node.content.value = content.substring(match[0].length);
        }
        return result;
    }
}

class ERBNoCaseNodeChildrenVisitor extends BaseRuleVisitor {
    visitERBCaseNode(node) {
        this.checkCaseNodeChildren(node, "when");
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.checkCaseNodeChildren(node, "in");
        this.visitChildNodes(node);
    }
    checkCaseNodeChildren(node, type) {
        if (!node.children || node.children.length === 0)
            return;
        const caseCode = IdentityPrinter.printERBNode(node);
        const firstCondition = node.conditions?.[0];
        const conditionCode = firstCondition && isERBNode(firstCondition) ? IdentityPrinter.printERBNode(firstCondition) : `<% ${type} ... %>`;
        for (const child of node.children) {
            if (!this.isAllowedContent(child)) {
                const childCode = IdentityPrinter.print(child).trim();
                this.addOffense(`Do not place \`${childCode}\` between \`${caseCode}\` and \`${conditionCode}\`. Content here is not part of any branch and will not be rendered.`, child.location);
            }
        }
    }
    isAllowedContent(node) {
        if (isWhitespaceNode(node))
            return true;
        if (isCommentNode(node))
            return true;
        if (isLiteralNode(node) || isHTMLTextNode(node)) {
            return /^\s*$/.test(node.content);
        }
        return false;
    }
}
class ERBNoCaseNodeChildrenRule extends ParserRule {
    name = "erb-no-case-node-children";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoCaseNodeChildrenVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoEmptyTagsVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        this.visitChildNodes(node);
        const { content, tag_closing } = node;
        if (!content)
            return;
        if (tag_closing?.value === "")
            return;
        if (content.value.trim().length > 0)
            return;
        this.addOffense("ERB tag should not be empty. Remove empty ERB tags or add content.", node.location);
    }
}
class ERBNoEmptyTagsRule extends ParserRule {
    name = "erb-no-empty-tags";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoEmptyTagsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

function positionFromOffset(source, offset) {
    let line = 1;
    let column = 0;
    let currentOffset = 0;
    for (let i = 0; i < source.length && currentOffset < offset; i++) {
        const char = source[i];
        currentOffset++;
        if (char === "\n") {
            line++;
            column = 0;
        }
        else {
            column++;
        }
    }
    return new Position(line, column);
}
class ERBNoExtraNewLineVisitor extends BaseSourceRuleVisitor {
    visitSource(source) {
        if (source.length === 0)
            return;
        const regex = /\n{4,}/g;
        let match;
        while ((match = regex.exec(source)) !== null) {
            const startOffset = match.index + 3;
            const endOffset = match.index + match[0].length;
            const start = positionFromOffset(source, startOffset);
            const end = positionFromOffset(source, endOffset);
            const location = new Location(start, end);
            const extraLines = match[0].length - 3;
            this.addOffense(`Extra blank line detected. Remove ${extraLines} blank ${extraLines === 1 ? "line" : "lines"} to maintain consistent spacing (max 2 allowed).`, location, {
                node: null,
                startOffset,
                endOffset
            });
        }
    }
}
class ERBNoExtraNewLineRule extends SourceRule {
    static autocorrectable = true;
    name = "erb-no-extra-newline";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(source, context) {
        const visitor = new ERBNoExtraNewLineVisitor(this.name, context);
        visitor.visit(source);
        return visitor.offenses;
    }
    autofix(offense, source, _context) {
        if (!offense.autofixContext)
            return null;
        const { startOffset, endOffset } = offense.autofixContext;
        const before = source.substring(0, startOffset);
        const after = source.substring(endOffset);
        return before + after;
    }
}

class ERBNoExtraWhitespaceInsideTagsVisitor extends BaseRuleVisitor {
    visitERBNode(node) {
        const openTag = node.tag_opening;
        const closeTag = node.tag_closing;
        const { value } = node.content ?? {};
        if (!openTag || !closeTag || !value)
            return;
        if (this.hasExtraLeadingWhitespace(value)) {
            this.reportWhitespace(node, openTag, closeTag, value, "start", 0, `Remove extra whitespace after \`${openTag.value}\`.`, "after-open");
        }
        if (openTag.value === "<%#" && value.startsWith("=") && value.length > 1) {
            const afterEquals = value.substring(1);
            if (afterEquals.match(/^\s{2,}/) && !afterEquals.startsWith("  \n") && !afterEquals.startsWith("\n")) {
                this.reportWhitespace(node, openTag, closeTag, value, "start", 1, `Remove extra whitespace after \`<%#=\`.`, "after-comment-equals");
            }
        }
        if (this.hasExtraTrailingWhitespace(value)) {
            this.reportWhitespace(node, openTag, closeTag, value, "end", 0, `Remove extra whitespace before \`${closeTag.value}\`.`, "before-close");
        }
    }
    hasExtraLeadingWhitespace(content) {
        return content.startsWith("  ") && !content.startsWith("  \n");
    }
    hasExtraTrailingWhitespace(content) {
        return !content.includes("\n") && /\s{2,}$/.test(content);
    }
    getWhitespaceLocation(node, content, position, offset = 0) {
        const contentLocation = node.content.location;
        if (position === "start") {
            const match = content.substring(offset).match(/^\s+/);
            const length = match ? match[0].length : 0;
            const startColumn = contentLocation.start.column + offset;
            return Location.from(contentLocation.start.line, startColumn, contentLocation.start.line, startColumn + length);
        }
        else {
            const match = content.match(/\s+$/);
            const length = match ? match[0].length : 0;
            return Location.from(contentLocation.end.line, contentLocation.end.column - length, contentLocation.end.line, contentLocation.end.column);
        }
    }
    reportWhitespace(node, openTag, closeTag, content, position, offset, message, fixType) {
        const location = this.getWhitespaceLocation(node, content, position, offset);
        this.addOffense(message, location, {
            node,
            openTag,
            closeTag,
            content,
            fixType
        });
    }
}
class ERBNoExtraWhitespaceRule extends ParserRule {
    static autocorrectable = true;
    name = "erb-no-extra-whitespace-inside-tags";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoExtraWhitespaceInsideTagsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, fixType } = offense.autofixContext;
        if (!node.content)
            return null;
        const content = node.content.value;
        switch (fixType) {
            case "before-close":
                node.content.value = content.replace(/\s{2,}$/, " ");
                break;
            case "after-open":
                node.content.value = content.replace(/^\s{2,}/, " ");
                break;
            case "after-comment-equals":
                if (content.startsWith("=")) {
                    const afterEquals = content.substring(1);
                    node.content.value = "= " + afterEquals.replace(/^\s{2,}/, "");
                }
                break;
            default:
                return null;
        }
        return result;
    }
}

class ERBNoOutputControlFlowRuleVisitor extends BaseRuleVisitor {
    visitERBIfNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    checkOutputControlFlow(controlBlock) {
        const openTag = controlBlock.tag_opening;
        if (!openTag) {
            return;
        }
        if (openTag.value === "<%=") {
            let controlBlockType = controlBlock.type;
            if (controlBlock.type === "AST_ERB_IF_NODE")
                controlBlockType = "if";
            if (controlBlock.type === "AST_ERB_ELSE_NODE")
                controlBlockType = "else";
            if (controlBlock.type === "AST_ERB_END_NODE")
                controlBlockType = "end";
            if (controlBlock.type === "AST_ERB_UNLESS_NODE")
                controlBlockType = "unless";
            this.addOffense(`Control flow statements like \`${controlBlockType}\` should not be used with output tags. Use \`<% ${controlBlockType} ... %>\` instead.`, openTag.location);
        }
        return;
    }
}
class ERBNoOutputControlFlowRule extends ParserRule {
    name = "erb-no-output-control-flow";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoOutputControlFlowRuleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoSilentTagInAttributeNameVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNameNode(node) {
        const erbNodes = filterERBContentNodes(node.children);
        const silentNodes = erbNodes.filter(this.isSilentERBTag);
        for (const node of silentNodes) {
            this.addOffense(`Remove silent ERB tag from HTML attribute name. Silent ERB tags (\`${node.tag_opening?.value}\`) do not output content and should not be used in attribute names.`, node.location);
        }
    }
    // TODO: might be worth to extract
    isSilentERBTag(node) {
        const silentTags = ["<%", "<%-", "<%#"];
        return silentTags.includes(node.tag_opening?.value || "");
    }
}
class ERBNoSilentTagInAttributeNameRule extends ParserRule {
    name = "erb-no-silent-tag-in-attribute-name";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBNoSilentTagInAttributeNameVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBPreferImageTagHelperVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(openTag) {
        const tagName = getTagName(openTag);
        if (tagName !== "img")
            return;
        const attributes = getAttributes(openTag);
        const srcAttribute = findAttributeByName(attributes, "src");
        if (!srcAttribute)
            return;
        if (!srcAttribute.value)
            return;
        const node = srcAttribute.value;
        const hasERBContent = this.containsERBContent(node);
        if (hasERBContent) {
            if (this.isDataUri(node))
                return;
            if (this.shouldFlagAsImageTagCandidate(node)) {
                const suggestedExpression = this.buildSuggestedExpression(node);
                this.addOffense(`Prefer \`image_tag\` helper over manual \`<img>\` with dynamic ERB expressions. Use \`<%= image_tag ${suggestedExpression}, alt: "..." %>\` instead.`, srcAttribute.location);
            }
        }
    }
    containsERBContent(node) {
        return filterNodes(node.children, ERBContentNode).length > 0;
    }
    isOnlyERBContent(node) {
        return node.children.length > 0 && node.children.length === filterNodes(node.children, ERBContentNode).length;
    }
    getContentofFirstChild(node) {
        if (!node.children || node.children.length === 0)
            return "";
        const firstChild = node.children[0];
        if (isNode(firstChild, LiteralNode)) {
            return (firstChild.content || "").trim();
        }
        return "";
    }
    isDataUri(node) {
        return this.getContentofFirstChild(node).startsWith("data:");
    }
    isFullUrl(node) {
        const content = this.getContentofFirstChild(node);
        return content.startsWith("http://") || content.startsWith("https://");
    }
    shouldFlagAsImageTagCandidate(node) {
        if (this.isOnlyERBContent(node))
            return true;
        if (this.isFullUrl(node))
            return false;
        return true;
    }
    buildSuggestedExpression(node) {
        if (!node.children)
            return "expression";
        try {
            return ERBToRubyStringPrinter.print(node, { ignoreErrors: false });
        }
        catch {
            return "expression";
        }
    }
}
class ERBPreferImageTagHelperRule extends ParserRule {
    name = "erb-prefer-image-tag-helper";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new ERBPreferImageTagHelperVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBRequireTrailingNewlineVisitor extends BaseSourceRuleVisitor {
    visitSource(source) {
        if (source.length === 0)
            return;
        if (!this.context.fileName)
            return;
        if (!source.endsWith('\n')) {
            this.addOffense("File must end with trailing newline.", createEndOfFileLocation(source));
        }
        else if (source.endsWith('\n\n')) {
            this.addOffense("File must end with exactly one trailing newline.", createEndOfFileLocation(source));
        }
    }
}
class ERBRequireTrailingNewlineRule extends SourceRule {
    static autocorrectable = true;
    name = "erb-require-trailing-newline";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(source, context) {
        const visitor = new ERBRequireTrailingNewlineVisitor(this.name, context);
        visitor.visit(source);
        return visitor.offenses;
    }
    autofix(_offense, source, _context) {
        return source.trimEnd() + "\n";
    }
}

class RequireWhitespaceInsideTags extends BaseRuleVisitor {
    visitERBNode(node) {
        const openTag = node.tag_opening;
        const closeTag = node.tag_closing;
        const content = node.content;
        if (!openTag || !closeTag || !content) {
            return;
        }
        const value = content.value;
        if (openTag.value === "<%#") {
            this.checkCommentTagWhitespace(node, openTag, closeTag, value);
        }
        else {
            this.checkOpenTagWhitespace(node, openTag, closeTag, value);
            this.checkCloseTagWhitespace(node, openTag, closeTag, value);
        }
    }
    checkCommentTagWhitespace(node, openTag, closeTag, content) {
        if (!content.startsWith(" ") && !content.startsWith("\n") && !content.startsWith("=")) {
            this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "after-open"
            });
        }
        else if (content.startsWith("=") && content.length > 1 && !content[1].match(/\s/)) {
            this.addOffense(`Add whitespace after \`<%#=\`.`, openTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "after-comment-equals"
            });
        }
        if (!content.endsWith(" ") && !content.endsWith("\n")) {
            this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, {
                node,
                openTag,
                closeTag,
                content,
                fixType: "before-close"
            });
        }
    }
    checkOpenTagWhitespace(node, openTag, closeTag, content) {
        if (content.startsWith(" ") || content.startsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, {
            node,
            openTag,
            closeTag,
            content,
            fixType: "after-open"
        });
    }
    checkCloseTagWhitespace(node, openTag, closeTag, content) {
        if (content.endsWith(" ") || content.endsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, {
            node,
            openTag,
            closeTag,
            content,
            fixType: "before-close"
        });
    }
}
class ERBRequireWhitespaceRule extends ParserRule {
    static autocorrectable = true;
    name = "erb-require-whitespace-inside-tags";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new RequireWhitespaceInsideTags(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, fixType } = offense.autofixContext;
        if (!node.content)
            return null;
        const content = node.content.value;
        if (fixType === "before-close") {
            node.content.value = content + " ";
            return result;
        }
        if (fixType === "after-open") {
            node.content.value = " " + content;
            return result;
        }
        if (fixType === "after-comment-equals" && content.startsWith("=")) {
            node.content.value = "= " + content.substring(1);
            return result;
        }
        return null;
    }
}

class ERBRightTrimVisitor extends BaseRuleVisitor {
    visitERBNode(node) {
        if (!node.tag_closing)
            return;
        const trimClosing = node.tag_closing.value;
        if (trimClosing !== "=%>")
            return;
        this.addOffense("Use `-%>` instead of `=%>` for right-trimming. The `=%>` syntax is obscure and not well-supported in most ERB engines.", node.tag_closing.location, { node });
    }
}
class ERBRightTrimRule extends ParserRule {
    static autocorrectable = true;
    name = "erb-right-trim";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ERBRightTrimVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node } = offense.autofixContext;
        if (!node.tag_closing)
            return null;
        const closing = node.tag_closing;
        if (closing.value === "=%>") {
            closing.value = "-%>";
            return result;
        }
        if (closing.value === "-%>") {
            closing.value = "%>";
            return result;
        }
        return null;
    }
}

/**
 * Utilities for parsing herb:disable comments
 */
/**
 * Prefix for herb:disable comments
 */
const HERB_DISABLE_PREFIX = "herb:disable";
/**
 * Parse a herb:disable comment from ERB comment content.
 * Use this when you have the content inside <%# ... %> (e.g., from ERBContentNode.content.value)
 *
 * @param content - The content string (without <%# %> delimiters)
 * @returns Parsed comment data or null if not a valid herb:disable comment
 *
 * @example
 * ```ts
 * const result = parseHerbDisableContent("herb:disable rule1, rule2")
 * // { match: "herb:disable rule1, rule2", ruleNames: ["rule1", "rule2"], rulesString: "rule1, rule2" }
 * ```
 */
function parseHerbDisableContent(content) {
    const trimmed = content.trim();
    if (!trimmed.startsWith(HERB_DISABLE_PREFIX))
        return null;
    const afterPrefix = trimmed.substring(HERB_DISABLE_PREFIX.length).trimStart();
    if (afterPrefix.length === 0)
        return null;
    const rulesString = afterPrefix.trimEnd();
    const ruleNames = rulesString.split(',').map(name => name.trim());
    if (ruleNames.some(name => name.length === 0))
        return null;
    if (ruleNames.length === 0)
        return null;
    const herbDisablePrefix = content.indexOf(HERB_DISABLE_PREFIX);
    const searchStart = herbDisablePrefix + HERB_DISABLE_PREFIX.length;
    const rulesStringOffset = content.indexOf(rulesString, searchStart);
    const ruleNameDetails = [];
    let currentOffset = 0;
    for (const ruleName of ruleNames) {
        const ruleOffset = rulesString.indexOf(ruleName, currentOffset);
        ruleNameDetails.push({
            name: ruleName,
            offset: rulesStringOffset + ruleOffset,
            length: ruleName.length
        });
        currentOffset = ruleOffset + ruleName.length;
    }
    return {
        match: trimmed,
        ruleNames,
        ruleNameDetails,
        rulesString
    };
}
/**
 * Parse a herb:disable comment from a full source line.
 * Use this when you have a complete line that may contain <%# herb:disable ... %>
 *
 * @param line - The source line that may contain a herb:disable comment
 * @returns Parsed comment data or null if not a valid herb:disable comment
 *
 * @example
 * ```ts
 * const result = parseHerbDisableLine("<div>test</div> <%# herb:disable rule1, rule2 %>")
 * // { match: "<%# herb:disable rule1, rule2 %>", ruleNames: ["rule1", "rule2"], rulesString: "rule1, rule2" }
 * ```
 */
function parseHerbDisableLine(line) {
    const startTag = "<%#";
    const endTag = "%>";
    const startIndex = line.indexOf(startTag);
    if (startIndex === -1)
        return null;
    const endIndex = line.indexOf(endTag, startIndex);
    if (endIndex === -1)
        return null;
    const content = line.substring(startIndex + startTag.length, endIndex).trim();
    if (!content.startsWith(HERB_DISABLE_PREFIX))
        return null;
    const afterPrefix = content.substring(HERB_DISABLE_PREFIX.length).trimStart();
    if (afterPrefix.length === 0)
        return null;
    const rulesString = afterPrefix.trimEnd();
    const ruleNames = rulesString.split(',').map(name => name.trim());
    if (ruleNames.some(name => name.length === 0))
        return null;
    if (ruleNames.length === 0)
        return null;
    const herbDisablePrefix = line.indexOf(HERB_DISABLE_PREFIX);
    const searchStart = herbDisablePrefix + HERB_DISABLE_PREFIX.length;
    const rulesStringOffset = line.indexOf(rulesString, searchStart);
    const ruleNameDetails = [];
    let currentOffset = 0;
    for (const ruleName of ruleNames) {
        const ruleOffset = rulesString.indexOf(ruleName, currentOffset);
        ruleNameDetails.push({
            name: ruleName,
            offset: rulesStringOffset + ruleOffset,
            length: ruleName.length
        });
        currentOffset = ruleOffset + ruleName.length;
    }
    const fullMatch = line.substring(startIndex, endIndex + endTag.length);
    return {
        match: fullMatch,
        ruleNames,
        ruleNameDetails,
        rulesString
    };
}

/**
 * Base visitor class for herb:disable comment validation rules.
 * Handles common patterns like checking ERB comments and parsing herb:disable content.
 */
class HerbDisableCommentBaseVisitor extends BaseRuleVisitor {
    constructor(ruleName, context) {
        super(ruleName, context);
    }
    visitERBContentNode(node) {
        if (node.tag_opening?.value !== "<%#")
            return;
        const content = node.content?.value;
        if (!content)
            return;
        this.checkHerbDisableComment(node, content);
    }
    /**
     * Helper to create a precise location for a specific rule name within the comment.
     * Returns null if content location is not available.
     */
    createRuleNameLocation(node, ruleDetail) {
        const contentLocation = node.content?.location;
        if (!contentLocation)
            return null;
        const startLine = contentLocation.start.line;
        const startColumn = contentLocation.start.column + ruleDetail.offset;
        return Location.from(startLine, startColumn, startLine, startColumn + ruleDetail.length);
    }
    /**
     * Helper to add an offense with a fallback to node location if precise location unavailable.
     */
    addOffenseWithFallback(message, preciseLocation, node) {
        this.addOffense(message, preciseLocation || node.location);
    }
}
/**
 * Base visitor for rules that need to process parsed herb:disable comments.
 * Only calls the abstract method if the content successfully parses as a herb:disable comment.
 */
class HerbDisableCommentParsedVisitor extends HerbDisableCommentBaseVisitor {
    checkHerbDisableComment(node, content) {
        const herbDisable = parseHerbDisableContent(content);
        if (!herbDisable)
            return;
        this.checkParsedHerbDisable(node, content, herbDisable);
    }
}

class HerbDisableCommentValidRuleNameVisitor extends HerbDisableCommentParsedVisitor {
    validRuleNames = new Set();
    validRuleNamesList = [];
    constructor(ruleName, validRuleNames, context) {
        super(ruleName, context);
        this.validRuleNames = new Set([...validRuleNames, "all"]);
        this.validRuleNamesList = Array.from(this.validRuleNames);
    }
    checkParsedHerbDisable(node, _content, herbDisable) {
        herbDisable.ruleNameDetails.forEach(ruleDetail => {
            if (this.validRuleNames.has(ruleDetail.name))
                return;
            const suggestion = didyoumean(ruleDetail.name, this.validRuleNamesList);
            const message = suggestion
                ? `Unknown rule \`${ruleDetail.name}\`. Did you mean \`${suggestion}\`?`
                : `Unknown rule \`${ruleDetail.name}\`.`;
            const location = this.createRuleNameLocation(node, ruleDetail);
            this.addOffenseWithFallback(message, location, node);
        });
    }
}
class HerbDisableCommentValidRuleNameRule extends ParserRule {
    name = "herb-disable-comment-valid-rule-name";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const validRuleNames = context?.validRuleNames;
        if (!validRuleNames)
            return [];
        if (validRuleNames.length === 0)
            return [];
        const visitor = new HerbDisableCommentValidRuleNameVisitor(this.name, validRuleNames, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentNoRedundantAllVisitor extends HerbDisableCommentParsedVisitor {
    checkParsedHerbDisable(node, _content, herbDisable) {
        if (!herbDisable.ruleNames.includes("all"))
            return;
        if (herbDisable.ruleNames.length <= 1)
            return;
        const allDetail = herbDisable.ruleNameDetails.find(detail => detail.name === "all");
        if (!allDetail)
            return;
        const location = this.createRuleNameLocation(node, allDetail);
        const message = `Using \`all\` with specific rules is redundant. Use \`herb:disable all\` by itself or list only specific rules.`;
        this.addOffenseWithFallback(message, location, node);
    }
}
class HerbDisableCommentNoRedundantAllRule extends ParserRule {
    name = "herb-disable-comment-no-redundant-all";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new HerbDisableCommentNoRedundantAllVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentNoDuplicateRulesVisitor extends HerbDisableCommentParsedVisitor {
    checkParsedHerbDisable(node, _content, herbDisable) {
        const seenRules = new Map();
        herbDisable.ruleNameDetails.forEach((ruleDetail, index) => {
            const firstIndex = seenRules.get(ruleDetail.name);
            if (firstIndex !== undefined) {
                const location = this.createRuleNameLocation(node, ruleDetail);
                const message = `Duplicate rule \`${ruleDetail.name}\` in \`herb:disable\` comment. Remove the duplicate.`;
                this.addOffenseWithFallback(message, location, node);
                return;
            }
            seenRules.set(ruleDetail.name, index);
        });
    }
}
class HerbDisableCommentNoDuplicateRulesRule extends ParserRule {
    name = "herb-disable-comment-no-duplicate-rules";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new HerbDisableCommentNoDuplicateRulesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentMissingRulesVisitor extends HerbDisableCommentBaseVisitor {
    checkHerbDisableComment(node, content) {
        const herbDisable = parseHerbDisableContent(content);
        if (herbDisable)
            return;
        const emptyFormat = /^\s*herb:disable\s*$/;
        if (!emptyFormat.test(content))
            return;
        this.addOffense(`\`herb:disable\` comment is missing rule names. Specify \`all\` or list specific rules to disable.`, node.location);
    }
}
class HerbDisableCommentMissingRulesRule extends ParserRule {
    name = "herb-disable-comment-missing-rules";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HerbDisableCommentMissingRulesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentMalformedVisitor extends HerbDisableCommentBaseVisitor {
    checkHerbDisableComment(node, content) {
        const trimmed = content.trim();
        const looksLikeHerbDisable = trimmed.startsWith("herb:disable");
        if (!looksLikeHerbDisable)
            return;
        if (trimmed.length > "herb:disable".length) {
            const charAfterPrefix = trimmed["herb:disable".length];
            if (charAfterPrefix !== ' ' && charAfterPrefix !== '\t' && charAfterPrefix !== '\n') {
                this.addOffense("`herb:disable` comment is missing a space after `herb:disable`. Add a space before the rule names.", node.location);
                return;
            }
        }
        const afterPrefix = trimmed.substring("herb:disable".length).trim();
        if (afterPrefix.length === 0)
            return;
        const parsed = parseHerbDisableContent(content);
        if (parsed !== null)
            return;
        let message = "`herb:disable` comment is malformed.";
        const rulesString = afterPrefix.trim();
        if (rulesString.endsWith(',')) {
            message = "`herb:disable` comment has a trailing comma. Remove the trailing comma.";
        }
        else if (rulesString.includes(',,') || rulesString.match(/,\s*,/)) {
            message = "`herb:disable` comment has consecutive commas. Remove extra commas.";
        }
        else if (rulesString.startsWith(',')) {
            message = "`herb:disable` comment starts with a comma. Remove the leading comma.";
        }
        this.addOffense(message, node.location);
    }
}
class HerbDisableCommentMalformedRule extends ParserRule {
    name = "herb-disable-comment-malformed";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HerbDisableCommentMalformedVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HerbDisableCommentUnnecessaryVisitor extends HerbDisableCommentParsedVisitor {
    ignoredOffensesByLine;
    validRuleNames;
    constructor(ruleName, ignoredOffensesByLine, validRuleNames, context) {
        super(ruleName, context);
        this.ignoredOffensesByLine = ignoredOffensesByLine;
        this.validRuleNames = new Set([...validRuleNames, "all"]);
    }
    checkParsedHerbDisable(node, _content, herbDisable) {
        const line = node.location.start.line;
        const usedRuleNames = this.ignoredOffensesByLine.get(line) || new Set();
        if (herbDisable.ruleNames.includes("all")) {
            if (herbDisable.ruleNames.length > 1)
                return;
            if (usedRuleNames.size > 0)
                return;
            this.addOffense(`No offenses to disable on this line. Remove the \`herb:disable all\` comment.`, node.location);
            return;
        }
        const unnecessaryRules = herbDisable.ruleNameDetails.filter(detail => this.validRuleNames.has(detail.name) && !usedRuleNames.has(detail.name));
        if (unnecessaryRules.length === 0)
            return;
        const validRuleCount = herbDisable.ruleNames.filter(name => this.validRuleNames.has(name)).length;
        if (unnecessaryRules.length === validRuleCount) {
            if (unnecessaryRules.length === 1) {
                const ruleName = unnecessaryRules[0].name;
                this.addOffense(`No offenses from \`${ruleName}\` on this line. Remove the \`herb:disable\` comment.`, node.location);
                return;
            }
            const unnecessaryRuleNames = unnecessaryRules.map(rule => `\`${rule.name}\``).join(", ");
            this.addOffense(`No offenses from rules ${unnecessaryRuleNames} on this line. Remove them from the \`herb:disable\` comment.`, node.location);
            return;
        }
        for (const unnecessaryRule of unnecessaryRules) {
            const location = this.createRuleNameLocation(node, unnecessaryRule);
            const message = `No offenses from \`${unnecessaryRule.name}\` on this line. Remove it from the \`herb:disable\` comment.`;
            this.addOffenseWithFallback(message, location, node);
        }
    }
}
class HerbDisableCommentUnnecessaryRule extends ParserRule {
    name = "herb-disable-comment-unnecessary";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const validRuleNames = context?.validRuleNames;
        const ignoredOffensesByLine = context?.ignoredOffensesByLine;
        if (!validRuleNames)
            return [];
        if (validRuleNames.length === 0)
            return [];
        if (!ignoredOffensesByLine)
            return [];
        const visitor = new HerbDisableCommentUnnecessaryVisitor(this.name, ignoredOffensesByLine, validRuleNames, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AnchorRechireHrefVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkATag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkATag(node) {
        const tagName = getTagName(node);
        if (tagName !== "a") {
            return;
        }
        if (!hasAttribute(node, "href")) {
            this.addOffense("Add an `href` attribute to `<a>` to ensure it is focusable and accessible.", node.tag_name.location);
        }
    }
}
class HTMLAnchorRequireHrefRule extends ParserRule {
    name = "html-anchor-require-href";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AnchorRechireHrefVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaAttributeMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    check(attributeName, attributeNode) {
        if (!attributeName.startsWith("aria-"))
            return;
        if (ARIA_ATTRIBUTES.has(attributeName))
            return;
        this.addOffense(`The attribute \`${attributeName}\` is not a valid ARIA attribute. ARIA attributes must match the WAI-ARIA specification.`, attributeNode.location);
    }
}
class HTMLAriaAttributeMustBeValid extends ParserRule {
    name = "html-aria-attribute-must-be-valid";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AriaAttributeMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaLabelIsWellFormattedVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-label")
            return;
        if (attributeValue.match(/[\r\n]+/) || attributeValue.match(/&#10;|&#13;|&#x0A;|&#x0D;/i)) {
            this.addOffense("The `aria-label` attribute value text should not contain line breaks. Use concise, single-line descriptions.", attributeNode.location);
            return;
        }
        if (this.looksLikeId(attributeValue)) {
            this.addOffense("The `aria-label` attribute value should not be formatted like an ID. Use natural, sentence-case text instead.", attributeNode.location);
            return;
        }
        if (attributeValue.match(/^[a-z]/)) {
            this.addOffense("The `aria-label` attribute value text should be formatted like visual text. Use sentence case (capitalize the first letter).", attributeNode.location);
        }
    }
    looksLikeId(text) {
        return (text.includes('_') ||
            text.includes('-') ||
            /^[a-z]+([A-Z][a-z]*)*$/.test(text)) && !text.includes(' ');
    }
}
class HTMLAriaLabelIsWellFormattedRule extends ParserRule {
    name = "html-aria-label-is-well-formatted";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AriaLabelIsWellFormattedVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLAriaLevelMustBeValidVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        this.validateAriaLevel(attributeValue, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        const validatableContent = getValidatableStaticContent(valueNodes);
        if (validatableContent !== null) {
            this.validateAriaLevel(validatableContent, attributeNode);
            return;
        }
        if (!hasERBOutput(valueNodes))
            return;
        const literalNodes = filterLiteralNodes(valueNodes);
        const erbOutputNodes = filterERBContentNodes(valueNodes).filter(isERBOutputNode);
        if (literalNodes.length > 0 && erbOutputNodes.length > 0) {
            const staticPart = literalNodes.map(node => node.content).join("");
            // TODO: this can be cleaned up using @herb-tools/printer
            const erbPart = erbOutputNodes[0];
            const erbText = `${erbPart.tag_opening?.value || ""}${erbPart.content?.value || ""}${erbPart.tag_closing?.value || ""}`;
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${staticPart}\` and the ERB expression \`${erbText}\`.`, attributeNode.location);
        }
    }
    validateAriaLevel(attributeValue, attributeNode) {
        if (!attributeValue || attributeValue === "") {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got an empty value.`, attributeNode.location);
            return;
        }
        const number = parseInt(attributeValue);
        if (isNaN(number) || number < 1 || number > 6 || attributeValue !== number.toString()) {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${attributeValue}\`.`, attributeNode.location);
        }
    }
}
class HTMLAriaLevelMustBeValidRule extends ParserRule {
    name = "html-aria-level-must-be-valid";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLAriaLevelMustBeValidVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleHeadingRequiresLevel extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode, parentNode }) {
        if (!(attributeName === "role" && attributeValue === "heading"))
            return;
        const ariaLevelAttributes = getAttributes(parentNode).find(attribute => getAttributeName(attribute) === "aria-level");
        if (ariaLevelAttributes)
            return;
        this.addOffense(`Element with \`role="heading"\` must have an \`aria-level\` attribute.`, attributeNode.location);
    }
}
class HTMLAriaRoleHeadingRequiresLevelRule extends ParserRule {
    name = "html-aria-role-heading-requires-level";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AriaRoleHeadingRequiresLevel(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "role")
            return;
        if (!attributeValue)
            return;
        if (VALID_ARIA_ROLES.has(attributeValue))
            return;
        this.addOffense(`The \`role\` attribute must be a valid ARIA role. Role \`${attributeValue}\` is not recognized.`, attributeNode.location);
    }
}
class HTMLAriaRoleMustBeValidRule extends ParserRule {
    name = "html-aria-role-must-be-valid";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AriaRoleMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AttributeDoubleQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (attributeValue?.includes('"'))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${attributeValue}"\`.`, attributeNode.value.location, {
            node: attributeNode,
            valueContent: attributeValue
        });
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode, combinedValue }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (filterLiteralNodes(valueNodes).some(node => node.content?.includes('"')))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${combinedValue}"\`.`, attributeNode.value.location, {
            node: attributeNode,
            valueContent: combinedValue || ""
        });
    }
}
class HTMLAttributeDoubleQuotesRule extends ParserRule {
    static autocorrectable = true;
    name = "html-attribute-double-quotes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new AttributeDoubleQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { value } } = offense.autofixContext;
        if (!value)
            return null;
        if (!value.open_quote)
            return null;
        if (!value.close_quote)
            return null;
        value.open_quote.value = '"';
        value.close_quote.value = '"';
        return result;
    }
}

class HTMLAttributeEqualsSpacingVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNode(attribute) {
        if (!attribute.equals || !attribute.name || !attribute.value) {
            return;
        }
        if (attribute.equals.value.startsWith(" ")) {
            this.addOffense("Remove whitespace before `=` in HTML attribute", attribute.equals.location, { node: attribute });
        }
        if (attribute.equals.value.endsWith(" ")) {
            this.addOffense("Remove whitespace after `=` in HTML attribute", attribute.equals.location, { node: attribute });
        }
    }
}
class HTMLAttributeEqualsSpacingRule extends ParserRule {
    static autocorrectable = true;
    name = "html-attribute-equals-spacing";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLAttributeEqualsSpacingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { equals } } = offense.autofixContext;
        if (!equals)
            return null;
        equals.value = "=";
        return result;
    }
}

class AttributeValuesRequireQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${attributeValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, {
            node: attributeNode,
            unquotedValue: attributeValue
        });
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode, combinedValue }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${combinedValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, {
            node: attributeNode,
            unquotedValue: combinedValue || ""
        });
    }
    hasAttributeValue(attributeNode) {
        return attributeNode.value?.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    isQuoted(attributeNode) {
        const valueNode = attributeNode.value;
        return valueNode ? valueNode.quoted : false;
    }
}
class HTMLAttributeValuesRequireQuotesRule extends ParserRule {
    static autocorrectable = true;
    name = "html-attribute-values-require-quotes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AttributeValuesRequireQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { value } } = offense.autofixContext;
        if (!value)
            return null;
        const quote = Token.from({ type: "TOKEN_QUOTE", value: '"', location: Location.zero, range: [0, 0] });
        if (value.open_quote) {
            value.open_quote.value = '"';
        }
        else {
            value.open_quote = quote;
        }
        if (value.close_quote) {
            value.close_quote.value = '"';
        }
        else {
            value.close_quote = quote;
        }
        value.quoted = true;
        return result;
    }
}

const ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT = new Set([
    "button", "fieldset", "input", "optgroup", "option", "select", "textarea"
]);
class AvoidBothDisabledAndAriaDisabledVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkElement(node) {
        const tagName = getTagName(node);
        if (!tagName || !ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT.has(tagName)) {
            return;
        }
        const hasDisabled = hasAttribute(node, "disabled");
        const hasAriaDisabled = hasAttribute(node, "aria-disabled");
        if ((hasDisabled && this.hasERBContent(node, "disabled")) || (hasAriaDisabled && this.hasERBContent(node, "aria-disabled"))) {
            return;
        }
        if (hasDisabled && hasAriaDisabled) {
            this.addOffense("aria-disabled may be used in place of native HTML disabled to allow tab-focus on an otherwise ignored element. Setting both attributes is contradictory and confusing. Choose either disabled or aria-disabled, not both.", node.tag_name.location);
        }
    }
    hasERBContent(node, attributeName) {
        const attributes = getAttributes(node);
        const attribute = findAttributeByName(attributes, attributeName);
        if (!attribute)
            return false;
        const valueNode = attribute.value;
        if (!valueNode || valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE")
            return false;
        const htmlValueNode = valueNode;
        if (!htmlValueNode.children)
            return false;
        return htmlValueNode.children.some((child) => child.type === "AST_ERB_CONTENT_NODE");
    }
}
class HTMLAvoidBothDisabledAndAriaDisabledRule extends ParserRule {
    name = "html-avoid-both-disabled-and-aria-disabled";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new AvoidBothDisabledAndAriaDisabledVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLBodyOnlyElementsVisitor extends BaseRuleVisitor {
    elementStack = [];
    visitHTMLElementNode(node) {
        const tagName = getTagName(node.open_tag)?.toLowerCase();
        if (!tagName)
            return;
        this.checkBodyOnlyElement(node, tagName);
        this.elementStack.push(tagName);
        this.visitChildNodes(node);
        this.elementStack.pop();
    }
    checkBodyOnlyElement(node, tagName) {
        if (this.insideBody)
            return;
        if (!this.insideHead)
            return;
        if (!isBodyOnlyTag(tagName))
            return;
        this.addOffense(`Element \`<${tagName}>\` must be placed inside the \`<body>\` tag.`, node.location);
    }
    get insideBody() {
        return this.elementStack.includes("body");
    }
    get insideHead() {
        return this.elementStack.includes("head");
    }
}
class HTMLBodyOnlyElementsRule extends ParserRule {
    static autocorrectable = false;
    name = "html-body-only-elements";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/*.xml", "**/*.xml.erb"]
        };
    }
    check(result, context) {
        const visitor = new HTMLBodyOnlyElementsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class BooleanAttributesNoValueVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ originalAttributeName, attributeNode }) {
        this.checkAttribute(originalAttributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ originalAttributeName, attributeNode }) {
        this.checkAttribute(originalAttributeName, attributeNode);
    }
    checkAttribute(attributeName, attributeNode) {
        if (!isBooleanAttribute(attributeName))
            return;
        if (!hasAttributeValue(attributeNode))
            return;
        this.addOffense(`Boolean attribute \`${IdentityPrinter.print(attributeNode.name)}\` should not have a value. Use \`${attributeName.toLowerCase()}\` instead of \`${IdentityPrinter.print(attributeNode)}\`.`, attributeNode.value.location, {
            node: attributeNode
        });
    }
}
class HTMLBooleanAttributesNoValueRule extends ParserRule {
    static autocorrectable = true;
    name = "html-boolean-attributes-no-value";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new BooleanAttributesNoValueVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node } = offense.autofixContext;
        node.equals = null;
        node.value = null;
        return result;
    }
}

class HeadOnlyElementsVisitor extends BaseRuleVisitor {
    elementStack = [];
    visitHTMLElementNode(node) {
        const tagName = getTagName(node)?.toLowerCase();
        if (!tagName)
            return;
        this.checkHeadOnlyElement(node, tagName);
        this.elementStack.push(tagName);
        this.visitChildNodes(node);
        this.elementStack.pop();
    }
    checkHeadOnlyElement(node, tagName) {
        if (this.insideHead)
            return;
        if (!this.insideBody)
            return;
        if (!isHeadOnlyTag(tagName))
            return;
        if (tagName === "title" && this.insideSVG)
            return;
        if (tagName === "meta" && this.hasItempropAttribute(node))
            return;
        this.addOffense(`Element \`<${tagName}>\` must be placed inside the \`<head>\` tag.`, node.location);
    }
    hasItempropAttribute(node) {
        return hasAttribute(node.open_tag, "itemprop");
    }
    get insideHead() {
        return this.elementStack.includes("head");
    }
    get insideBody() {
        return this.elementStack.includes("body");
    }
    get insideSVG() {
        return this.elementStack.includes("svg");
    }
}
class HTMLHeadOnlyElementsRule extends ParserRule {
    static autocorrectable = false;
    name = "html-head-only-elements";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/*.xml", "**/*.xml.erb"]
        };
    }
    check(result, context) {
        const visitor = new HeadOnlyElementsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class IframeHasTitleVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkIframeElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkIframeElement(node) {
        const tagName = getTagName(node);
        if (tagName !== "iframe") {
            return;
        }
        const ariaHiddenAttribute = getAttribute(node, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return;
            }
        }
        const attribute = getAttribute(node, "title");
        if (!attribute) {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location);
            return;
        }
        const value = getAttributeValue(attribute);
        if (!value || value.trim() === "") {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location);
        }
    }
}
class HTMLIframeHasTitleRule extends ParserRule {
    name = "html-iframe-has-title";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new IframeHasTitleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ImgRequireAltVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(node) {
        const tagName = getTagName(node);
        if (tagName !== "img") {
            return;
        }
        if (!hasAttribute(node, "alt")) {
            this.addOffense('Missing required `alt` attribute on `<img>` tag. Add `alt=""` for decorative images or `alt="description"` for informative images.', node.tag_name.location);
        }
    }
}
class HTMLImgRequireAltRule extends ParserRule {
    name = "html-img-require-alt";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new ImgRequireAltVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLInputRequireAutocompleteVisitor extends BaseRuleVisitor {
    HTML_INPUT_TYPES_REQUIRING_AUTOCOMPLETE = new Set([
        "color",
        "date",
        "datetime-local",
        "email",
        "month",
        "number",
        "password",
        "range",
        "search",
        "tel",
        "text",
        "time",
        "url",
        "week",
    ]);
    visitHTMLOpenTagNode(node) {
        this.checkInputTag(node);
    }
    checkInputTag(node) {
        if (!this.isInputTag(node) || this.hasAutocomplete(node))
            return;
        const typeAttribute = getAttribute(node, "type");
        if (!typeAttribute)
            return;
        const typeValue = getStaticAttributeValueContent(typeAttribute);
        if (!typeValue)
            return;
        if (!this.HTML_INPUT_TYPES_REQUIRING_AUTOCOMPLETE.has(typeValue))
            return;
        this.addOffense("Add an `autocomplete` attribute to improve form accessibility. Use a specific value (e.g., `autocomplete=\"email\"`), `autocomplete=\"on\"` for defaults, or `autocomplete=\"off\"` to disable.", node.location);
    }
    hasAutocomplete(node) {
        const autocompleteAttribute = getAttribute(node, "autocomplete");
        if (!autocompleteAttribute)
            return false;
        const autocompleteValue = getAttributeValue(autocompleteAttribute);
        if (!autocompleteValue)
            return false;
        return true;
    }
    isInputTag(node) {
        const tagName = getTagName$1(node);
        if (tagName === "input") {
            return true;
        }
        else {
            return false;
        }
    }
}
class HTMLInputRequireAutocompleteRule extends ParserRule {
    name = "html-input-require-autocomplete";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLInputRequireAutocompleteVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NavigationHasLabelVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkNavigationElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkNavigationElement(node) {
        const tagName = getTagName(node);
        const isNavElement = tagName === "nav";
        const hasNavigationRole = this.hasRoleNavigation(node);
        if (!isNavElement && !hasNavigationRole) {
            return;
        }
        const hasAriaLabel = hasAttribute(node, "aria-label");
        const hasAriaLabelledby = hasAttribute(node, "aria-labelledby");
        if (!hasAriaLabel && !hasAriaLabelledby) {
            let message = `The navigation landmark should have a unique accessible name via \`aria-label\` or \`aria-labelledby\`. Remember that the name does not need to include "navigation" or "nav" since it will already be announced.`;
            if (hasNavigationRole && !isNavElement) {
                message += ` Additionally, you can safely drop the \`role="navigation"\` and replace it with the native HTML \`<nav>\` element.`;
            }
            this.addOffense(message, node.tag_name.location);
        }
    }
    hasRoleNavigation(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "navigation";
    }
}
class HTMLNavigationHasLabelRule extends ParserRule {
    name = "html-navigation-has-label";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NavigationHasLabelVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const INTERACTIVE_ELEMENTS = new Set([
    "button", "summary", "input", "select", "textarea", "a"
]);
class NoAriaHiddenOnFocusableVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkAriaHiddenOnFocusable(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAriaHiddenOnFocusable(node) {
        if (!this.hasAriaHiddenTrue(node))
            return;
        if (this.isFocusable(node)) {
            this.addOffense(`Elements that are focusable should not have \`aria-hidden="true"\` because it will cause confusion for assistive technology users.`, node.tag_name.location);
        }
    }
    hasAriaHiddenTrue(node) {
        const attributes = getAttributes(node);
        const ariaHiddenAttr = findAttributeByName(attributes, "aria-hidden");
        if (!ariaHiddenAttr)
            return false;
        const value = getAttributeValue(ariaHiddenAttr);
        return value === "true";
    }
    isFocusable(node) {
        const tagName = getTagName(node);
        if (!tagName)
            return false;
        const tabIndexValue = this.getTabIndexValue(node);
        if (tagName === "a") {
            const hasHref = hasAttribute(node, "href");
            if (!hasHref) {
                return tabIndexValue !== null && tabIndexValue >= 0;
            }
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        if (INTERACTIVE_ELEMENTS.has(tagName)) {
            // Interactive elements are focusable unless tabindex is negative
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        else {
            // Non-interactive elements are focusable only if tabindex >= 0
            return tabIndexValue !== null && tabIndexValue >= 0;
        }
    }
    getTabIndexValue(node) {
        const attributes = getAttributes(node);
        const tabIndexAttribute = findAttributeByName(attributes, "tabindex");
        if (!tabIndexAttribute)
            return null;
        const value = getAttributeValue(tabIndexAttribute);
        if (!value)
            return null;
        const parsed = parseInt(value, 10);
        return isNaN(parsed) ? null : parsed;
    }
}
class HTMLNoAriaHiddenOnFocusableRule extends ParserRule {
    name = "html-no-aria-hidden-on-focusable";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoAriaHiddenOnFocusableVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class BlockInsideInlineVisitor extends BaseRuleVisitor {
    inlineStack = [];
    isValidHTMLOpenTag(node) {
        return !!(node.open_tag && node.open_tag.type === "AST_HTML_OPEN_TAG_NODE");
    }
    getElementType(tagName) {
        const isInline = isInlineElement(tagName);
        const isBlock = isBlockElement(tagName);
        const isUnknown = !isInline && !isBlock;
        return { isInline, isBlock, isUnknown };
    }
    addOffenseMessage(tagName, isBlock, openTag) {
        const parentInline = this.inlineStack[this.inlineStack.length - 1];
        const elementType = isBlock ? "Block-level" : "Unknown";
        this.addOffense(`${elementType} element \`<${tagName}>\` cannot be placed inside inline element \`<${parentInline}>\`.`, openTag.tag_name.location);
    }
    visitInlineElement(node, tagName) {
        this.inlineStack.push(tagName);
        super.visitHTMLElementNode(node);
        this.inlineStack.pop();
    }
    visitBlockElement(node) {
        const savedStack = [...this.inlineStack];
        this.inlineStack = [];
        super.visitHTMLElementNode(node);
        this.inlineStack = savedStack;
    }
    visitHTMLElementNode(node) {
        if (!this.isValidHTMLOpenTag(node)) {
            super.visitHTMLElementNode(node);
            return;
        }
        const openTag = node.open_tag;
        const tagName = openTag.tag_name?.value.toLowerCase();
        if (!tagName) {
            super.visitHTMLElementNode(node);
            return;
        }
        const { isInline, isBlock, isUnknown } = this.getElementType(tagName);
        if ((isBlock || isUnknown) && this.inlineStack.length > 0) {
            this.addOffenseMessage(tagName, isBlock, openTag);
        }
        if (isInline) {
            this.visitInlineElement(node, tagName);
            return;
        }
        this.visitBlockElement(node);
    }
}
class HTMLNoBlockInsideInlineRule extends ParserRule {
    name = "html-no-block-inside-inline";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new BlockInsideInlineVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoDuplicateAttributesVisitor extends AttributeVisitorMixin {
    attributeNames = new Map();
    visitHTMLOpenTagNode(node) {
        this.attributeNames.clear();
        super.visitHTMLOpenTagNode(node);
        this.reportDuplicates();
    }
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    trackAttributeName(attributeName, attributeNode) {
        if (!this.attributeNames.has(attributeName)) {
            this.attributeNames.set(attributeName, []);
        }
        this.attributeNames.get(attributeName).push(attributeNode);
    }
    reportDuplicates() {
        for (const [attributeName, attributeNodes] of this.attributeNames) {
            if (attributeNodes.length > 1) {
                for (let i = 1; i < attributeNodes.length; i++) {
                    const attributeNode = attributeNodes[i];
                    this.addOffense(`Duplicate attribute \`${attributeName}\` found on tag. Remove the duplicate occurrence.`, attributeNode.name.location);
                }
            }
        }
    }
}
class HTMLNoDuplicateAttributesRule extends ParserRule {
    name = "html-no-duplicate-attributes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoDuplicateAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class OutputPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(IdentityPrinter.print(node));
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.write(IdentityPrinter.print(node));
        }
    }
}
class NoDuplicateIdsVisitor extends ControlFlowTrackingVisitor {
    documentIds = new Set();
    currentBranchIds = new Set();
    controlFlowIds = new Set();
    visitHTMLAttributeNode(node) {
        this.checkAttribute(node);
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds,
            previousControlFlowIds: this.controlFlowIds
        };
        this.currentBranchIds = new Set();
        if (!wasAlreadyInControlFlow) {
            this.controlFlowIds = new Set();
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowIds.forEach(id => this.documentIds.add(id));
        }
        this.currentBranchIds = stateToRestore.previousBranchIds;
        this.controlFlowIds = stateToRestore.previousControlFlowIds;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds
        };
        if (this.isInControlFlow) {
            this.currentBranchIds = new Set();
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    checkAttribute(attributeNode) {
        if (!this.isIdAttribute(attributeNode))
            return;
        const idValue = this.extractIdValue(attributeNode);
        if (!idValue)
            return;
        if (this.isWhitespaceOnlyId(idValue.identifier))
            return;
        this.processIdDuplicate(idValue, attributeNode);
    }
    isIdAttribute(attributeNode) {
        if (!attributeNode.name?.children || !attributeNode.value)
            return false;
        return getStaticAttributeName(attributeNode.name) === "id";
    }
    extractIdValue(attributeNode) {
        const valueNodes = attributeNode.value?.children || [];
        if (hasERBOutput(valueNodes) && this.isInControlFlow && this.currentControlFlowType === ControlFlowType.LOOP) {
            return null;
        }
        const identifier = isEffectivelyStatic(valueNodes) ? getValidatableStaticContent(valueNodes) : OutputPrinter.print(valueNodes);
        if (!identifier)
            return null;
        return { identifier, shouldTrackDuplicates: true };
    }
    isWhitespaceOnlyId(identifier) {
        return identifier !== '' && identifier.trim() === '';
    }
    processIdDuplicate(idValue, attributeNode) {
        const { identifier, shouldTrackDuplicates } = idValue;
        if (!shouldTrackDuplicates)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowId(identifier, attributeNode);
        }
        else {
            this.handleGlobalId(identifier, attributeNode);
        }
    }
    handleControlFlowId(identifier, attributeNode) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.handleLoopId(identifier, attributeNode);
        }
        else {
            this.handleConditionalId(identifier, attributeNode);
        }
        this.currentBranchIds.add(identifier);
    }
    handleLoopId(identifier, attributeNode) {
        const isStaticId = this.isStaticId(attributeNode);
        if (isStaticId) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        if (this.currentBranchIds.has(identifier)) {
            this.addSameLoopIterationOffense(identifier, attributeNode.location);
        }
    }
    handleConditionalId(identifier, attributeNode) {
        if (this.currentBranchIds.has(identifier)) {
            this.addSameBranchOffense(identifier, attributeNode.location);
            return;
        }
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.controlFlowIds.add(identifier);
    }
    handleGlobalId(identifier, attributeNode) {
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.documentIds.add(identifier);
    }
    isStaticId(attributeNode) {
        const valueNodes = attributeNode.value.children;
        const isCompletelyStatic = valueNodes.every(child => isNode(child, LiteralNode));
        const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
        return isCompletelyStatic || isEffectivelyStaticValue;
    }
    addDuplicateIdOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found. IDs must be unique within a document.`, location);
    }
    addSameLoopIterationOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same loop iteration. IDs must be unique within the same loop iteration.`, location);
    }
    addSameBranchOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same control flow branch. IDs must be unique within the same control flow branch.`, location);
    }
}
class HTMLNoDuplicateIdsRule extends ParserRule {
    name = "html-no-duplicate-ids";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoDuplicateIdsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLNoDuplicateMetaNamesVisitor extends ControlFlowTrackingVisitor {
    elementStack = [];
    documentMetas = [];
    currentBranchMetas = [];
    controlFlowMetas = [];
    visitHTMLElementNode(node) {
        const tagName = getTagName(node)?.toLowerCase();
        if (!tagName)
            return;
        if (tagName === "head") {
            this.documentMetas = [];
            this.currentBranchMetas = [];
            this.controlFlowMetas = [];
        }
        else if (tagName === "meta" && this.insideHead) {
            this.collectAndCheckMetaTag(node);
        }
        this.elementStack.push(tagName);
        this.visitChildNodes(node);
        this.elementStack.pop();
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchMetas: this.currentBranchMetas,
            previousControlFlowMetas: this.controlFlowMetas
        };
        this.currentBranchMetas = [];
        if (!wasAlreadyInControlFlow) {
            this.controlFlowMetas = [];
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowMetas.forEach(meta => this.documentMetas.push(meta));
        }
        this.currentBranchMetas = stateToRestore.previousBranchMetas;
        this.controlFlowMetas = stateToRestore.previousControlFlowMetas;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchMetas: this.currentBranchMetas
        };
        if (this.isInControlFlow) {
            this.currentBranchMetas = [];
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    get insideHead() {
        return this.elementStack.includes("head");
    }
    collectAndCheckMetaTag(node) {
        const metaTag = { node };
        this.extractAttributes(node, metaTag);
        if (!metaTag.nameValue && !metaTag.httpEquivValue)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowMeta(metaTag);
        }
        else {
            this.handleGlobalMeta(metaTag);
        }
        this.currentBranchMetas.push(metaTag);
    }
    extractAttributes(node, metaTag) {
        if (isHTMLElementNode(node) && node.open_tag) {
            forEachAttribute(node.open_tag, (attributeNode) => {
                const name = getAttributeName(attributeNode);
                const value = getAttributeValue(attributeNode)?.trim();
                if (name === "name" && value) {
                    metaTag.nameValue = value;
                }
                else if (name === "http-equiv" && value) {
                    metaTag.httpEquivValue = value;
                }
            });
        }
    }
    handleControlFlowMeta(metaTag) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.checkAgainstMetaList(metaTag, this.currentBranchMetas, "within the same loop iteration");
        }
        else {
            this.checkAgainstMetaList(metaTag, this.currentBranchMetas, "within the same control flow branch");
            this.checkAgainstMetaList(metaTag, this.documentMetas, "");
            this.controlFlowMetas.push(metaTag);
        }
    }
    handleGlobalMeta(metaTag) {
        this.checkAgainstMetaList(metaTag, this.documentMetas, "");
        this.documentMetas.push(metaTag);
    }
    checkAgainstMetaList(metaTag, existingMetas, context) {
        for (const existing of existingMetas) {
            if (this.areMetaTagsDuplicate(metaTag, existing)) {
                const attributeDescription = metaTag.nameValue
                    ? `\`name="${metaTag.nameValue}"\``
                    : `\`http-equiv="${metaTag.httpEquivValue}"\``;
                const attributeType = metaTag.nameValue ? "Meta names" : "`http-equiv` values";
                const contextMsg = context ? ` ${context}` : "";
                this.addOffense(`Duplicate \`<meta>\` tag with ${attributeDescription}${contextMsg}. ${attributeType} should be unique within the \`<head>\` section.`, metaTag.node.location);
                return;
            }
        }
    }
    areMetaTagsDuplicate(meta1, meta2) {
        if (meta1.nameValue && meta2.nameValue) {
            return meta1.nameValue.toLowerCase() === meta2.nameValue.toLowerCase();
        }
        if (meta1.httpEquivValue && meta2.httpEquivValue) {
            return meta1.httpEquivValue.toLowerCase() === meta2.httpEquivValue.toLowerCase();
        }
        return false;
    }
}
class HTMLNoDuplicateMetaNamesRule extends ParserRule {
    static autocorrectable = false;
    name = "html-no-duplicate-meta-names";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLNoDuplicateMetaNamesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const RESTRICTED_ATTRIBUTES = new Set([
    'id',
    'class',
    'name',
    'for',
    'src',
    'href',
    'title',
    'data',
    'role'
]);
function isRestrictedAttribute(attributeName) {
    if (RESTRICTED_ATTRIBUTES.has(attributeName)) {
        return true;
    }
    if (attributeName.startsWith('data-')) {
        return true;
    }
    if (attributeName.startsWith('aria-')) {
        return true;
    }
    return false;
}
function isDataAttribute(attributeName) {
    return attributeName.startsWith('data-');
}
/**
 * Visitor that checks if a node tree contains any output content.
 * Output content includes:
 * - Non-whitespace literal text (LiteralNode)
 * - ERB output tags (<%= %>, <%== %>)
 */
class ContainsOutputContentVisitor extends Visitor {
    hasOutputContent = false;
    visitLiteralNode(node) {
        if (this.hasOutputContent)
            return;
        if (node.content && node.content.trim() !== "") {
            this.hasOutputContent = true;
            return;
        }
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        if (this.hasOutputContent)
            return;
        if (isERBOutputNode(node)) {
            this.hasOutputContent = true;
            return;
        }
        this.visitChildNodes(node);
    }
}
function containsOutputContent(node) {
    const visitor = new ContainsOutputContentVisitor();
    visitor.visit(node);
    return visitor.hasOutputContent;
}
class NoEmptyAttributesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        this.checkEmptyAttribute(attributeName, attributeValue, attributeNode);
    }
    checkDynamicAttributeStaticValue({ combinedName, attributeValue, attributeNode }) {
        const name = (combinedName || "").toLowerCase();
        this.checkEmptyAttribute(name, attributeValue, attributeNode);
    }
    checkEmptyAttribute(attributeName, attributeValue, attributeNode) {
        if (!isRestrictedAttribute(attributeName))
            return;
        if (attributeValue.trim() !== "")
            return;
        if (!attributeNode?.value)
            return;
        if (containsOutputContent(attributeNode.value))
            return;
        const hasExplicitValue = attributeNode.value !== null;
        if (isDataAttribute(attributeName)) {
            if (hasExplicitValue) {
                this.addOffense(`Data attribute \`${attributeName}\` should not have an empty value. Either provide a meaningful value or use \`${attributeName}\` instead of \`${IdentityPrinter.print(attributeNode)}\`.`, attributeNode.location);
            }
            return;
        }
        this.addOffense(`Attribute \`${attributeName}\` must not be empty. Either provide a meaningful value or remove the attribute entirely.`, attributeNode.location);
    }
}
class HTMLNoEmptyAttributesRule extends ParserRule {
    name = "html-no-empty-attributes";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new NoEmptyAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoEmptyHeadingsVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        this.checkHeadingElement(node);
        super.visitHTMLElementNode(node);
    }
    checkHeadingElement(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (!tagName) {
            return;
        }
        const isStandardHeading = HEADING_TAGS.has(tagName);
        const isAriaHeading = this.hasHeadingRole(openTag);
        if (!isStandardHeading && !isAriaHeading) {
            return;
        }
        if (this.isEmptyHeading(node)) {
            const elementDescription = isStandardHeading
                ? `\`<${tagName}>\``
                : `\`<${tagName} role="heading">\``;
            this.addOffense(`Heading element ${elementDescription} must not be empty. Provide accessible text content for screen readers and SEO.`, node.location);
        }
    }
    isEmptyHeading(node) {
        if (!node.body || node.body.length === 0) {
            return true;
        }
        let hasAccessibleContent = false;
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                if (this.isElementAccessible(elementNode)) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else {
                hasAccessibleContent = true;
                break;
            }
        }
        return !hasAccessibleContent;
    }
    hasHeadingRole(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "heading";
    }
    isElementAccessible(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return true;
        }
        const openTag = node.open_tag;
        const attributes = getAttributes(openTag);
        const ariaHiddenAttribute = findAttributeByName(attributes, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return false;
            }
        }
        if (!node.body || node.body.length === 0) {
            return false;
        }
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                if (this.isElementAccessible(elementNode)) {
                    return true;
                }
            }
            else {
                // If there's any non-literal/non-text/non-element content (like ERB), consider it accessible
                return true;
            }
        }
        return false;
    }
}
class HTMLNoEmptyHeadingsRule extends ParserRule {
    name = "html-no-empty-headings";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoEmptyHeadingsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NestedLinkVisitor extends BaseRuleVisitor {
    linkStack = [];
    checkNestedLink(openTag) {
        if (this.linkStack.length > 0) {
            this.addOffense("Nested `<a>` elements are not allowed. Links cannot contain other links.", openTag.tag_name.location);
            return true;
        }
        return false;
    }
    visitHTMLElementNode(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            super.visitHTMLElementNode(node);
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (tagName !== "a") {
            super.visitHTMLElementNode(node);
            return;
        }
        // If we're already inside a link, this is a nested link
        this.checkNestedLink(openTag);
        this.linkStack.push(openTag);
        super.visitHTMLElementNode(node);
        this.linkStack.pop();
    }
    // Handle self-closing <a> tags (though they're not valid HTML, they might exist)
    visitHTMLOpenTagNode(node) {
        const tagName = getTagName(node);
        if (tagName === "a" && node.is_void) {
            this.checkNestedLink(node);
        }
        super.visitHTMLOpenTagNode(node);
    }
}
class HTMLNoNestedLinksRule extends ParserRule {
    name = "html-no-nested-links";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NestedLinkVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoPositiveTabIndexVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "tabindex")
            return;
        const tabIndexValue = parseInt(attributeValue, 10);
        if (!isNaN(tabIndexValue) && tabIndexValue > 0) {
            this.addOffense(`Do not use positive \`tabindex\` values as they are error prone and can severely disrupt navigation experience for keyboard users. Use \`tabindex="0"\` to make an element focusable or \`tabindex="-1"\` to remove it from the tab sequence.`, attributeNode.location);
        }
    }
}
class HTMLNoPositiveTabIndexRule extends ParserRule {
    name = "html-no-positive-tab-index";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoPositiveTabIndexVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoSelfClosingVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (getTagName$1(node) === "svg") {
            this.visit(node.open_tag);
        }
        else {
            this.visitChildNodes(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_closing?.value === "/>") {
            const tagName = getTagName$1(node);
            const instead = isVoidElement(tagName) ? `<${tagName}>` : `<${tagName}></${tagName}>`;
            this.addOffense(`Use \`${instead}\` instead of self-closing \`<${tagName} />\` for HTML compatibility.`, node.location, {
                node,
                tagName,
                isVoid: isVoidElement(tagName)
            });
        }
    }
}
class HTMLNoSelfClosingRule extends ParserRule {
    static autocorrectable = true;
    name = "html-no-self-closing";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/views/**/*_mailer/**/*"]
        };
    }
    check(result, context) {
        const visitor = new NoSelfClosingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, tagName, isVoid } = offense.autofixContext;
        const { tag_closing } = node;
        if (!tag_closing)
            return null;
        tag_closing.value = ">";
        if (node.children && Array.isArray(node.children)) {
            const children = node.children;
            if (children.length > 0 && isWhitespaceNode(children[children.length - 1])) {
                node.children = children.slice(0, -1);
            }
        }
        if (!isVoid) {
            const parent = findParent(result.value, node);
            if (parent && parent.type === "AST_HTML_ELEMENT_NODE") {
                const tag_opening = { type: "TOKEN_HTML_TAG_START_CLOSE", value: "</", location: Location.zero, range: [0, 0] };
                const tag_name = { type: "TOKEN_IDENTIFIER", value: tagName, location: Location.zero, range: [0, 0] };
                const tag_closing = { type: "TOKEN_HTML_TAG_END", value: ">", location: Location.zero, range: [0, 0] };
                parent.close_tag = HTMLCloseTagNode.from({
                    type: "AST_HTML_CLOSE_TAG_NODE",
                    tag_opening,
                    tag_name,
                    tag_closing,
                    children: [],
                    errors: [],
                    location: Location.zero,
                });
            }
        }
        return result;
    }
}

const MESSAGES = {
    EXTRA_SPACE_NO_SPACE: "Extra space detected where there should be no space.",
    EXTRA_SPACE_SINGLE_SPACE: "Extra space detected where there should be a single space.",
    EXTRA_SPACE_SINGLE_BREAK: "Extra space detected where there should be a single space or a single line break.",
    NO_SPACE_SINGLE_SPACE: "No space detected where there should be a single space.",
};
class HTMLNoSpaceInTagVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        if (node.isSingleLine) {
            this.checkSingleLineTag(node);
        }
        else {
            this.checkMultilineTag(node);
        }
    }
    visitHTMLCloseTagNode(node) {
        this.reportAllWhitespace(node.children, MESSAGES.EXTRA_SPACE_NO_SPACE);
    }
    checkSingleLineTag(node) {
        const { children, tag_closing } = node;
        const isSelfClosing = tag_closing ? this.isSelfClosing(tag_closing) : false;
        this.checkWhitespaceInSingleLineTag(children, isSelfClosing);
        this.checkMissingSpaceBeforeSelfClosing(node, children, isSelfClosing);
    }
    checkWhitespaceInSingleLineTag(children, isSelfClosing) {
        const whitespaceNodes = filterWhitespaceNodes(children);
        whitespaceNodes.forEach((whitespace) => {
            const content = this.getWhitespaceContent(whitespace);
            if (!content)
                return;
            const isLastChild = children[children.length - 1] === whitespace;
            if (isLastChild) {
                this.checkTrailingWhitespace(whitespace, content, isSelfClosing);
                return;
            }
            if (content.length > 1) {
                this.addOffense(MESSAGES.EXTRA_SPACE_SINGLE_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_SINGLE_SPACE });
            }
        });
    }
    checkTrailingWhitespace(whitespace, content, isSelfClosing) {
        if (isSelfClosing && content === ' ')
            return;
        this.addOffense(MESSAGES.EXTRA_SPACE_NO_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_NO_SPACE });
    }
    checkMissingSpaceBeforeSelfClosing(node, children, isSelfClosing) {
        if (!isSelfClosing)
            return;
        const lastChild = children[children.length - 1];
        if (lastChild && isWhitespaceNode(lastChild))
            return;
        const lastNonWhitespace = children.filter(child => !isWhitespaceNode(child)).pop();
        const locationToReport = lastNonWhitespace?.location ?? node.tag_name?.location ?? node.location;
        this.addOffense(MESSAGES.NO_SPACE_SINGLE_SPACE, locationToReport, { node, message: MESSAGES.NO_SPACE_SINGLE_SPACE });
    }
    checkMultilineTag(node) {
        const whitespaceNodes = filterWhitespaceNodes(node.children);
        let previousWhitespace = null;
        whitespaceNodes.forEach((whitespace, index) => {
            const content = this.getWhitespaceContent(whitespace);
            if (!content)
                return;
            if (this.hasConsecutiveNewlines(content, previousWhitespace)) {
                this.addOffense(MESSAGES.EXTRA_SPACE_SINGLE_BREAK, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_SINGLE_BREAK });
                previousWhitespace = whitespace;
                return;
            }
            if (this.isNonNewlineWhitespace(content)) {
                this.checkIndentation(whitespace, index, whitespaceNodes.length, node);
            }
            previousWhitespace = whitespace;
        });
    }
    hasConsecutiveNewlines(content, previousWhitespace) {
        if (content === "\n")
            return previousWhitespace?.value?.value === "\n";
        if (!content.includes("\n"))
            return false;
        const newlines = content.match(/\n/g);
        return (newlines?.length ?? 0) > 1;
    }
    isNonNewlineWhitespace(content) {
        return !content.includes("\n");
    }
    checkIndentation(whitespace, index, totalWhitespaceNodes, node) {
        const isLastWhitespace = index === totalWhitespaceNodes - 1;
        const expectedIndent = isLastWhitespace ? node.location.start.column : node.location.start.column + 2;
        if (whitespace.location.end.column === expectedIndent)
            return;
        this.addOffense(MESSAGES.EXTRA_SPACE_NO_SPACE, whitespace.location, { node: whitespace, message: MESSAGES.EXTRA_SPACE_NO_SPACE });
    }
    isSelfClosing(tag_closing) {
        return tag_closing?.value?.includes('/') ?? false;
    }
    getWhitespaceContent(whitespace) {
        return whitespace.value?.value ?? null;
    }
    reportAllWhitespace(nodes, message) {
        const whitespaceNodes = Array.isArray(nodes) && nodes.length > 0 && !isWhitespaceNode(nodes[0])
            ? filterWhitespaceNodes(nodes)
            : nodes;
        whitespaceNodes.forEach(whitespace => {
            this.addOffense(message, whitespace.location, { node: whitespace, message });
        });
    }
}
class HTMLNoSpaceInTagRule extends ParserRule {
    // TODO: enable and fix autofix
    static autocorrectable = false;
    name = "html-no-space-in-tag";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new HTMLNoSpaceInTagVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node, message } = offense.autofixContext;
        if (!node)
            return null;
        if (isHTMLOpenTagNode(node)) {
            const token = Token.from({ type: "TOKEN_WHITESPACE", value: " ", range: [0, 0], location: Location.zero });
            const whitespace = new WhitespaceNode({ type: "AST_WHITESPACE_NODE", value: token, location: Location.zero, errors: [] });
            node.children.push(whitespace);
            return result;
        }
        if (!isWhitespaceNode(node))
            return null;
        const whitespaceNode = node;
        if (!whitespaceNode.value)
            return null;
        switch (message) {
            case MESSAGES.EXTRA_SPACE_NO_SPACE: {
                let selfClosing = false;
                let beginningOfLine = false;
                const parent = findParent(result.value, node);
                if (parent && isHTMLOpenTagNode(parent)) {
                    selfClosing = parent.tag_closing?.value === "/>";
                    beginningOfLine = node.location.start.column === 0;
                }
                whitespaceNode.value.value = selfClosing && !beginningOfLine ? " " : "";
                return result;
            }
            case MESSAGES.EXTRA_SPACE_SINGLE_BREAK: {
                if (whitespaceNode.value.value.includes("\n")) {
                    whitespaceNode.value.value = "";
                }
                else {
                    whitespaceNode.value.value = " ";
                }
                return result;
            }
            case MESSAGES.EXTRA_SPACE_SINGLE_SPACE:
            case MESSAGES.NO_SPACE_SINGLE_SPACE: {
                whitespaceNode.value.value = " ";
                return result;
            }
            default: return null;
        }
    }
}

class NoTitleAttributeVisitor extends BaseRuleVisitor {
    ALLOWED_ELEMENTS_WITH_TITLE = new Set(["iframe", "link"]);
    visitHTMLOpenTagNode(node) {
        this.checkTitleAttribute(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkTitleAttribute(node) {
        const tagName = getTagName(node);
        if (!tagName || this.ALLOWED_ELEMENTS_WITH_TITLE.has(tagName)) {
            return;
        }
        if (hasAttribute(node, "title")) {
            this.addOffense("The `title` attribute should never be used as it is inaccessible for several groups of users. Use `aria-label` or `aria-describedby` instead. Exceptions are provided for `<iframe>` and `<link>` elements.", node.tag_name.location);
        }
    }
}
class HTMLNoTitleAttributeRule extends ParserRule {
    name = "html-no-title-attribute";
    get defaultConfig() {
        return {
            enabled: false,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new NoTitleAttributeVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLNoUnderscoresInAttributeNamesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkDynamicAttributeStaticValue({ nameNodes, attributeNode }) {
        const attributeName = getStaticContentFromNodes(nameNodes);
        this.check(attributeName, attributeNode);
    }
    checkDynamicAttributeDynamicValue({ nameNodes, attributeNode }) {
        const attributeName = getStaticContentFromNodes(nameNodes);
        this.check(attributeName, attributeNode);
    }
    check(attributeName, attributeNode) {
        if (!attributeName)
            return;
        if (attributeName.includes("_")) {
            this.addOffense(`Attribute \`${IdentityPrinter.print(attributeNode.name)}\` should not contain underscores. Use hyphens (-) instead.`, attributeNode.name?.location ?? attributeNode.location);
        }
    }
}
class HTMLNoUnderscoresInAttributeNamesRule extends ParserRule {
    name = "html-no-underscores-in-attribute-names";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "warning"
        };
    }
    check(result, context) {
        const visitor = new HTMLNoUnderscoresInAttributeNamesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class XMLDeclarationChecker extends BaseRuleVisitor {
    hasXMLDeclaration = false;
    visitXMLDeclarationNode(_node) {
        this.hasXMLDeclaration = true;
    }
    visitChildNodes(node) {
        if (this.hasXMLDeclaration)
            return;
        super.visitChildNodes(node);
    }
}
class TagNameLowercaseVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (getTagName$1(node).toLowerCase() === "svg") {
            this.checkTagName(node.open_tag);
            this.checkTagName(node.close_tag);
        }
        else {
            super.visitHTMLElementNode(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        this.checkTagName(node);
    }
    visitHTMLCloseTagNode(node) {
        this.checkTagName(node);
    }
    checkTagName(node) {
        if (!node)
            return;
        const tagName = getTagName$1(node);
        if (!tagName)
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const type = isNode(node, HTMLOpenTagNode) ? "Opening" : "Closing";
        const open = isNode(node, HTMLOpenTagNode) ? "<" : "</";
        if (tagName !== lowercaseTagName) {
            this.addOffense(`${type} tag name \`${open}${tagName}>\` should be lowercase. Use \`${open}${lowercaseTagName}>\` instead.`, node.tag_name.location, {
                node,
                tagName,
                correctedTagName: lowercaseTagName
            });
        }
    }
}
class HTMLTagNameLowercaseRule extends ParserRule {
    static autocorrectable = true;
    name = "html-tag-name-lowercase";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error",
            exclude: ["**/*.xml", "**/*.xml.erb"]
        };
    }
    isEnabled(result, _context) {
        const checker = new XMLDeclarationChecker(this.name);
        checker.visit(result.value);
        return !checker.hasXMLDeclaration;
    }
    check(result, context) {
        const visitor = new TagNameLowercaseVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { tag_name }, correctedTagName } = offense.autofixContext;
        if (!tag_name)
            return null;
        tag_name.value = correctedTagName;
        return result;
    }
}

class SVGTagNameCapitalizationVisitor extends BaseRuleVisitor {
    insideSVG = false;
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName && ["svg"].includes(tagName.toLowerCase())) {
            const wasInsideSVG = this.insideSVG;
            this.insideSVG = true;
            this.visitChildNodes(node);
            this.insideSVG = wasInsideSVG;
            return;
        }
        if (this.insideSVG) {
            if (node.open_tag) {
                this.checkTagName(node.open_tag);
            }
            if (node.close_tag) {
                this.checkTagName(node.close_tag);
            }
        }
        this.visitChildNodes(node);
    }
    checkTagName(node) {
        const tagName = node.tag_name?.value;
        if (!tagName)
            return;
        if (SVG_CAMEL_CASE_ELEMENTS.has(tagName))
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const correctCamelCase = SVG_LOWERCASE_TO_CAMELCASE.get(lowercaseTagName);
        if (correctCamelCase && tagName !== correctCamelCase) {
            let type = node.type;
            if (node.type === "AST_HTML_OPEN_TAG_NODE")
                type = "Opening";
            if (node.type === "AST_HTML_CLOSE_TAG_NODE")
                type = "Closing";
            this.addOffense(`${type} SVG tag name \`${tagName}\` should use proper capitalization. Use \`${correctCamelCase}\` instead.`, node.tag_name.location, {
                node,
                currentTagName: tagName,
                correctCamelCase
            });
        }
    }
}
class SVGTagNameCapitalizationRule extends ParserRule {
    static autocorrectable = true;
    name = "svg-tag-name-capitalization";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result, context) {
        const visitor = new SVGTagNameCapitalizationVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
    autofix(offense, result, _context) {
        if (!offense.autofixContext)
            return null;
        const { node: { tag_name }, correctCamelCase } = offense.autofixContext;
        if (!tag_name)
            return null;
        tag_name.value = correctCamelCase;
        return result;
    }
}

class ParserNoErrorsRule extends ParserRule {
    name = "parser-no-errors";
    get defaultConfig() {
        return {
            enabled: true,
            severity: "error"
        };
    }
    check(result) {
        return result.recursiveErrors().map(error => this.herbErrorToLintOffense(error));
    }
    herbErrorToLintOffense(error) {
        return {
            message: `${error.message} (\`${error.type}\`)`,
            location: error.location,
            severity: error.severity,
            rule: this.name,
            code: this.name,
            source: "linter"
        };
    }
}

const rules = [
    ERBCommentSyntax,
    ERBNoCaseNodeChildrenRule,
    ERBNoEmptyTagsRule,
    ERBNoExtraNewLineRule,
    ERBNoExtraWhitespaceRule,
    ERBNoOutputControlFlowRule,
    ERBNoSilentTagInAttributeNameRule,
    ERBPreferImageTagHelperRule,
    ERBRequireTrailingNewlineRule,
    ERBRequireWhitespaceRule,
    ERBRightTrimRule,
    HerbDisableCommentValidRuleNameRule,
    HerbDisableCommentNoRedundantAllRule,
    HerbDisableCommentNoDuplicateRulesRule,
    HerbDisableCommentMissingRulesRule,
    HerbDisableCommentMalformedRule,
    HerbDisableCommentUnnecessaryRule,
    HTMLAnchorRequireHrefRule,
    HTMLAriaAttributeMustBeValid,
    HTMLAriaLabelIsWellFormattedRule,
    HTMLAriaLevelMustBeValidRule,
    HTMLAriaRoleHeadingRequiresLevelRule,
    HTMLAriaRoleMustBeValidRule,
    HTMLAttributeDoubleQuotesRule,
    HTMLAttributeEqualsSpacingRule,
    HTMLAttributeValuesRequireQuotesRule,
    HTMLAvoidBothDisabledAndAriaDisabledRule,
    HTMLBodyOnlyElementsRule,
    HTMLBooleanAttributesNoValueRule,
    HTMLHeadOnlyElementsRule,
    HTMLIframeHasTitleRule,
    HTMLImgRequireAltRule,
    HTMLInputRequireAutocompleteRule,
    HTMLNavigationHasLabelRule,
    HTMLNoAriaHiddenOnFocusableRule,
    HTMLNoBlockInsideInlineRule,
    HTMLNoDuplicateAttributesRule,
    HTMLNoDuplicateIdsRule,
    HTMLNoDuplicateMetaNamesRule,
    HTMLNoEmptyAttributesRule,
    HTMLNoEmptyHeadingsRule,
    HTMLNoNestedLinksRule,
    HTMLNoPositiveTabIndexRule,
    HTMLNoSelfClosingRule,
    HTMLNoSpaceInTagRule,
    HTMLNoTitleAttributeRule,
    HTMLNoUnderscoresInAttributeNamesRule,
    HTMLTagNameLowercaseRule,
    SVGTagNameCapitalizationRule,
    ParserNoErrorsRule,
];

const HERB_LINTER_PREFIX = "herb:linter";
const HERB_LINTER_IGNORE_PREFIX = `${HERB_LINTER_PREFIX} ignore`;
/**
 * Check if an ERB content node is a herb:linter ignore comment.
 *
 * @param node - The ERB content node to check
 * @returns true if this is a linter ignore directive
 */
function isHerbLinterIgnoreComment(node) {
    if (!isERBCommentNode(node))
        return false;
    const content = node?.content?.value || "";
    return content.trim() === HERB_LINTER_IGNORE_PREFIX;
}
/**
 * Check if the document contains a herb:linter ignore directive anywhere.
 */
function hasLinterIgnoreDirective(parseResult) {
    if (parseResult.failed)
        return false;
    const detector = new LinterIgnoreDetector();
    detector.visit(parseResult.value);
    return detector.hasIgnoreDirective;
}
/**
 * Visitor that detects if the AST contains a herb:linter ignore directive.
 */
class LinterIgnoreDetector extends Visitor {
    hasIgnoreDirective = false;
    visitERBContentNode(node) {
        if (isHerbLinterIgnoreComment(node)) {
            this.hasIgnoreDirective = true;
            return;
        }
        if (this.hasIgnoreDirective)
            return;
        this.visitChildNodes(node);
    }
}

class Linter {
    rules;
    allAvailableRules;
    herb;
    offenses;
    config;
    /**
     * Creates a new Linter instance with automatic rule filtering based on config.
     *
     * @param herb - The Herb backend instance for parsing and lexing
     * @param config - Optional full Config instance for rule filtering, severity overrides, and path-based filtering
     * @param customRules - Optional array of custom rules to include alongside built-in rules
     * @returns A configured Linter instance
     */
    static from(herb, config, customRules) {
        const allRules = customRules ? [...rules, ...customRules] : rules;
        const filteredRules = config?.linter?.rules
            ? Linter.filterRulesByConfig(allRules, config.linter.rules)
            : undefined;
        return new Linter(herb, filteredRules, config, allRules);
    }
    /**
     * Creates a new Linter instance.
     *
     * For most use cases, prefer `Linter.from()` which handles config-based filtering.
     * Use this constructor directly when you need explicit control over rules.
     *
     * @param herb - The Herb backend instance for parsing and lexing
     * @param rules - Array of rule classes (Parser/AST or Lexer) to use. If not provided, uses default rules.
     * @param config - Optional full Config instance for severity overrides and path-based rule filtering
     * @param allAvailableRules - Optional array of ALL available rules (including disabled) for herb:disable validation
     */
    constructor(herb, rules, config, allAvailableRules) {
        this.herb = herb;
        this.config = config;
        this.rules = rules !== undefined ? rules : this.getDefaultRules();
        this.allAvailableRules = allAvailableRules !== undefined ? allAvailableRules : this.rules;
        this.offenses = [];
    }
    /**
     * Filters rules based on default config and optional user config overrides.
     *
     * Priority:
     * 1. User config override (if rule config exists in userRulesConfig)
     * 2. Default config from rule's defaultConfig getter
     *
     * @param allRules - All available rule classes to filter from
     * @param userRulesConfig - Optional user configuration for rules
     * @returns Filtered array of rule classes that should be enabled
     */
    static filterRulesByConfig(allRules, userRulesConfig) {
        return allRules.filter(ruleClass => {
            const instance = new ruleClass();
            const ruleName = instance.name;
            const defaultEnabled = instance.defaultConfig?.enabled ?? DEFAULT_RULE_CONFIG.enabled;
            const userRuleConfig = userRulesConfig?.[ruleName];
            if (userRuleConfig !== undefined) {
                return userRuleConfig.enabled !== false;
            }
            return defaultEnabled;
        });
    }
    /**
     * Returns the default set of rule classes used by the linter.
     * These are the rules enabled when no custom rules are provided.
     * Filters all available rules to only include those enabled by default.
     * @returns Array of default rule classes
     */
    getDefaultRules() {
        return Linter.filterRulesByConfig(rules);
    }
    /**
     * Returns all available rule classes that can be referenced in herb:disable comments.
     * This includes all rules that exist, regardless of whether they're currently enabled.
     * Includes both built-in rules and any loaded custom rules.
     * @returns Array of all available rule classes
     */
    getAvailableRules() {
        return this.allAvailableRules;
    }
    /**
     * Meta-linting rules for herb:disable comments cannot be disabled
     * This ensures that invalid herb:disable comments are always caught
     */
    get nonExcludableRules() {
        return [
            "herb-disable-comment-valid-rule-name",
            "herb-disable-comment-no-redundant-all",
            "herb-disable-comment-no-duplicate-rules",
            "herb-disable-comment-malformed",
            "herb-disable-comment-missing-rules",
            "herb-disable-comment-unnecessary"
        ];
    }
    getRuleCount() {
        return this.rules.length;
    }
    /**
     * Type guard to check if a rule is a LexerRule
     */
    isLexerRule(rule) {
        return rule.constructor.type === "lexer";
    }
    /**
     * Type guard to check if a rule is a SourceRule
     */
    isSourceRule(rule) {
        return rule.constructor.type === "source";
    }
    /**
     * Execute a single rule and return its unbound offenses.
     * Handles rule type checking (Lexer/Parser/Source) and isEnabled checks.
     */
    executeRule(rule, parseResult, lexResult, source, context) {
        if (this.config && context?.fileName) {
            if (!this.config.isRuleEnabledForPath(rule.name, context.fileName)) {
                return [];
            }
        }
        if (context?.fileName && !this.config?.linter?.rules?.[rule.name]?.exclude) {
            const defaultExclude = rule.defaultConfig?.exclude ?? DEFAULT_RULE_CONFIG.exclude;
            if (defaultExclude && defaultExclude.length > 0) {
                const isExcluded = defaultExclude.some((pattern) => minimatch$1(context.fileName, pattern));
                if (isExcluded) {
                    return [];
                }
            }
        }
        let isEnabled = true;
        let ruleOffenses;
        if (this.isLexerRule(rule)) {
            if (rule.isEnabled) {
                isEnabled = rule.isEnabled(lexResult, context);
            }
            if (isEnabled) {
                ruleOffenses = rule.check(lexResult, context);
            }
            else {
                ruleOffenses = [];
            }
        }
        else if (this.isSourceRule(rule)) {
            if (rule.isEnabled) {
                isEnabled = rule.isEnabled(source, context);
            }
            if (isEnabled) {
                ruleOffenses = rule.check(source, context);
            }
            else {
                ruleOffenses = [];
            }
        }
        else {
            if (rule.isEnabled) {
                isEnabled = rule.isEnabled(parseResult, context);
            }
            if (isEnabled) {
                ruleOffenses = rule.check(parseResult, context);
            }
            else {
                ruleOffenses = [];
            }
        }
        return ruleOffenses;
    }
    filterOffenses(ruleOffenses, ruleName, ignoredOffensesByLine, herbDisableCache, ignoreDisableComments) {
        const kept = [];
        const ignored = [];
        const wouldBeIgnored = [];
        if (this.nonExcludableRules.includes(ruleName)) {
            return { kept: ruleOffenses, ignored: [], wouldBeIgnored: [] };
        }
        if (ignoreDisableComments) {
            for (const offense of ruleOffenses) {
                const line = offense.location.start.line;
                const disabledRules = herbDisableCache?.get(line) || [];
                if (disabledRules.includes(ruleName) || disabledRules.includes("all")) {
                    wouldBeIgnored.push(offense);
                }
            }
            return { kept: ruleOffenses, ignored: [], wouldBeIgnored };
        }
        for (const offense of ruleOffenses) {
            const line = offense.location.start.line;
            const disabledRules = herbDisableCache?.get(line) || [];
            if (disabledRules.includes(ruleName) || disabledRules.includes("all")) {
                ignored.push(offense);
                if (ignoredOffensesByLine) {
                    if (!ignoredOffensesByLine.has(line)) {
                        ignoredOffensesByLine.set(line, new Set());
                    }
                    const usedRuleName = disabledRules.includes(ruleName) ? ruleName : "all";
                    ignoredOffensesByLine.get(line).add(usedRuleName);
                }
                continue;
            }
            kept.push(offense);
        }
        return { kept, ignored, wouldBeIgnored: [] };
    }
    /**
     * Lint source code using Parser/AST, Lexer, and Source rules.
     * @param source - The source code to lint
     * @param context - Optional context for linting (e.g., fileName for distinguishing files vs snippets)
     */
    lint(source, context) {
        this.offenses = [];
        let ignoredCount = 0;
        let wouldBeIgnoredCount = 0;
        const parseResult = this.herb.parse(source, { track_whitespace: true });
        // Check for file-level ignore directive using visitor
        if (hasLinterIgnoreDirective(parseResult)) {
            return {
                offenses: [],
                errors: 0,
                warnings: 0,
                info: 0,
                hints: 0,
                ignored: 0
            };
        }
        const lexResult = this.herb.lex(source);
        const hasParserErrors = parseResult.recursiveErrors().length > 0;
        const sourceLines = source.split("\n");
        const ignoredOffensesByLine = new Map();
        const herbDisableCache = new Map();
        if (hasParserErrors) {
            const hasParserRule = this.rules.find(RuleClass => (new RuleClass()).name === "parser-no-errors");
            if (hasParserRule) {
                const rule = new ParserNoErrorsRule();
                const offenses = rule.check(parseResult);
                this.offenses.push(...offenses);
            }
            return {
                offenses: this.offenses,
                errors: this.offenses.filter(o => o.severity === "error").length,
                warnings: this.offenses.filter(o => o.severity === "warning").length,
                info: this.offenses.filter(o => o.severity === "info").length,
                hints: this.offenses.filter(o => o.severity === "hint").length,
                ignored: 0
            };
        }
        for (let i = 0; i < sourceLines.length; i++) {
            const line = sourceLines[i];
            if (line.includes("herb:disable")) {
                const herbDisable = parseHerbDisableLine(line);
                herbDisableCache.set(i + 1, herbDisable?.ruleNames || []);
            }
        }
        context = {
            ...context,
            validRuleNames: this.getAvailableRules().map(RuleClass => new RuleClass().name),
            ignoredOffensesByLine
        };
        const regularRules = this.rules.filter(RuleClass => {
            const rule = new RuleClass();
            return rule.name !== "herb-disable-comment-unnecessary";
        });
        for (const RuleClass of regularRules) {
            const rule = new RuleClass();
            const unboundOffenses = this.executeRule(rule, parseResult, lexResult, source, context);
            const boundOffenses = this.bindSeverity(unboundOffenses, rule.name);
            const { kept, ignored, wouldBeIgnored } = this.filterOffenses(boundOffenses, rule.name, ignoredOffensesByLine, herbDisableCache, context?.ignoreDisableComments);
            ignoredCount += ignored.length;
            wouldBeIgnoredCount += wouldBeIgnored.length;
            this.offenses.push(...kept);
        }
        const unnecessaryRuleClass = this.rules.find(RuleClass => {
            const rule = new RuleClass();
            return rule.name === "herb-disable-comment-unnecessary";
        });
        if (unnecessaryRuleClass) {
            const unnecessaryRule = new unnecessaryRuleClass();
            const unboundOffenses = unnecessaryRule.check(parseResult, context);
            const boundOffenses = this.bindSeverity(unboundOffenses, unnecessaryRule.name);
            this.offenses.push(...boundOffenses);
        }
        const finalOffenses = this.offenses;
        const errors = finalOffenses.filter(offense => offense.severity === "error").length;
        const warnings = finalOffenses.filter(offense => offense.severity === "warning").length;
        const info = finalOffenses.filter(offense => offense.severity === "info").length;
        const hints = finalOffenses.filter(offense => offense.severity === "hint").length;
        const result = {
            offenses: finalOffenses,
            errors,
            warnings,
            info,
            hints,
            ignored: ignoredCount
        };
        if (wouldBeIgnoredCount > 0) {
            result.wouldBeIgnored = wouldBeIgnoredCount;
        }
        return result;
    }
    /**
     * Bind severity to unbound offenses based on rule's defaultConfig and user config overrides.
     *
     * Priority:
     * 1. User config severity override (if specified in config)
     * 2. Rule's default severity (from defaultConfig.severity)
     *
     * @param unboundOffenses - Array of offenses without severity
     * @param ruleName - Name of the rule that produced the offenses
     * @returns Array of offenses with severity bound
     */
    bindSeverity(unboundOffenses, ruleName) {
        const RuleClass = this.rules.find(rule => {
            const instance = new rule();
            return instance.name === ruleName;
        });
        if (!RuleClass) {
            return unboundOffenses.map(offense => ({
                ...offense,
                severity: "error"
            }));
        }
        const ruleInstance = new RuleClass();
        const defaultSeverity = ruleInstance.defaultConfig?.severity ?? DEFAULT_RULE_CONFIG.severity;
        const userRuleConfig = this.config?.linter?.rules?.[ruleName];
        const severity = userRuleConfig?.severity ?? defaultSeverity;
        return unboundOffenses.map(offense => ({
            ...offense,
            severity
        }));
    }
    /**
     * Automatically fix offenses in the source code.
     * Uses AST mutation for parser rules and token mutation for lexer rules.
     * @param source - The source code to fix
     * @param context - Optional context for linting (e.g., fileName)
     * @param offensesToFix - Optional array of specific offenses to fix. If not provided, all fixable offenses will be fixed.
     * @returns AutofixResult containing the corrected source and lists of fixed/unfixed offenses
     */
    autofix(source, context, offensesToFix) {
        const lintResult = offensesToFix ? { offenses: offensesToFix } : this.lint(source, context);
        const parserOffenses = [];
        const sourceOffenses = [];
        for (const offense of lintResult.offenses) {
            const RuleClass = this.rules.find(rule => {
                const instance = new rule();
                return instance.name === offense.rule;
            });
            if (!RuleClass)
                continue;
            if (RuleClass.type === "lexer") ;
            else if (RuleClass.type === "source") {
                sourceOffenses.push(offense);
            }
            else {
                parserOffenses.push(offense);
            }
        }
        let currentSource = source;
        const fixed = [];
        const unfixed = [];
        if (parserOffenses.length > 0) {
            const parseResult = this.herb.parse(currentSource, { track_whitespace: true });
            for (const offense of parserOffenses) {
                const RuleClass = this.rules.find(rule => new rule().name === offense.rule);
                if (!RuleClass) {
                    unfixed.push(offense);
                    continue;
                }
                const rule = new RuleClass();
                if (!rule.autofix) {
                    unfixed.push(offense);
                    continue;
                }
                if (offense.autofixContext) {
                    const originalNodeType = offense.autofixContext.node.type;
                    const location = offense.autofixContext.node.location ? Location.from(offense.autofixContext.node.location) : offense.location;
                    const freshNode = findNodeByLocation(parseResult.value, location, (node) => node.type === originalNodeType);
                    if (freshNode) {
                        offense.autofixContext.node = freshNode;
                    }
                    else {
                        unfixed.push(offense);
                        continue;
                    }
                }
                const fixedResult = rule.autofix(offense, parseResult, context);
                if (fixedResult) {
                    fixed.push(offense);
                }
                else {
                    unfixed.push(offense);
                }
            }
            if (fixed.length > 0) {
                const printer = new IdentityPrinter();
                currentSource = printer.print(parseResult.value);
            }
        }
        if (sourceOffenses.length > 0) {
            const sortedSourceOffenses = sourceOffenses.sort((a, b) => {
                if (a.location.start.line !== b.location.start.line) {
                    return b.location.start.line - a.location.start.line;
                }
                return b.location.start.column - a.location.start.column;
            });
            for (const offense of sortedSourceOffenses) {
                const RuleClass = this.rules.find(rule => new rule().name === offense.rule);
                if (!RuleClass) {
                    unfixed.push(offense);
                    continue;
                }
                const rule = new RuleClass();
                if (!rule.autofix) {
                    unfixed.push(offense);
                    continue;
                }
                const correctedSource = rule.autofix(offense, currentSource, context);
                if (correctedSource) {
                    currentSource = correctedSource;
                    fixed.push(offense);
                }
                else {
                    unfixed.push(offense);
                }
            }
        }
        return {
            source: currentSource,
            fixed,
            unfixed
        };
    }
}

const DEFAULT_PATTERNS = [
    ".herb/rules/**/*.mjs",
];
/**
 * Loads custom linter rules from the user's project
 */
class CustomRuleLoader {
    baseDir;
    patterns;
    silent;
    constructor(options = {}) {
        this.baseDir = options.baseDir || process.cwd();
        this.patterns = options.patterns || DEFAULT_PATTERNS;
        this.silent = options.silent || false;
    }
    /**
     * Discovers custom rule files in the project
     */
    async discoverRuleFiles() {
        const allFiles = [];
        for (const pattern of this.patterns) {
            try {
                const files = await glob$1(pattern, {
                    cwd: this.baseDir,
                    absolute: true,
                    nodir: true
                });
                allFiles.push(...files);
            }
            catch (error) {
                if (!this.silent) {
                    console.warn(`Warning: Failed to search pattern "${pattern}": ${error}`);
                }
            }
        }
        return [...new Set(allFiles)];
    }
    /**
     * Loads a single rule file
     */
    async loadRuleFile(filePath) {
        try {
            const fileUrl = url.pathToFileURL(filePath).href;
            const cacheBustedUrl = `${fileUrl}?t=${Date.now()}`;
            const module = await import(cacheBustedUrl);
            if (module.default && this.isValidRuleClass(module.default)) {
                return [module.default];
            }
            if (!this.silent) {
                console.warn(`Warning: No valid default export found in "${filePath}". Custom rules must use default export.`);
            }
            return [];
        }
        catch (error) {
            if (!this.silent) {
                console.error(`Error loading rule file "${filePath}": ${error}`);
            }
            return [];
        }
    }
    /**
     * Type guard to check if an export is a valid rule class
     */
    isValidRuleClass(value) {
        if (typeof value !== 'function')
            return false;
        if (!value.prototype)
            return false;
        const instance = new value();
        return typeof instance.check === 'function' && typeof instance.name === 'string';
    }
    /**
     * Loads all custom rules from the project
     */
    async loadRules() {
        const ruleFiles = await this.discoverRuleFiles();
        if (ruleFiles.length === 0) {
            return [];
        }
        const allRules = [];
        for (const filePath of ruleFiles) {
            const rules = await this.loadRuleFile(filePath);
            allRules.push(...rules);
        }
        return allRules;
    }
    /**
     * Loads all custom rules and returns detailed information about each rule
     */
    async loadRulesWithInfo() {
        const ruleFiles = await this.discoverRuleFiles();
        if (ruleFiles.length === 0) {
            return { rules: [], ruleInfo: [], duplicateWarnings: [] };
        }
        const allRules = [];
        const ruleInfo = [];
        const duplicateWarnings = [];
        const seenNames = new Map();
        for (const filePath of ruleFiles) {
            const rules = await this.loadRuleFile(filePath);
            for (const RuleClass of rules) {
                const instance = new RuleClass();
                const ruleName = instance.name;
                if (seenNames.has(ruleName)) {
                    const firstPath = seenNames.get(ruleName);
                    duplicateWarnings.push(`Custom rule "${ruleName}" is defined in multiple files: "${firstPath}" and "${filePath}". The later one will be used.`);
                }
                else {
                    seenNames.set(ruleName, filePath);
                }
                allRules.push(RuleClass);
                ruleInfo.push({
                    name: ruleName,
                    path: filePath
                });
            }
        }
        return { rules: allRules, ruleInfo, duplicateWarnings };
    }
    /**
     * Static helper to check if custom rules exist in a project
     */
    static async hasCustomRules(baseDir = process.cwd()) {
        const loader = new CustomRuleLoader({ baseDir, silent: true });
        const files = await loader.discoverRuleFiles();
        return files.length > 0;
    }
    /**
     * Static helper to load custom rules and merge with default rules
     */
    static async loadAndMergeRules(defaultRules, options = {}) {
        const loader = new CustomRuleLoader(options);
        const customRules = await loader.loadRules();
        return [...defaultRules, ...customRules];
    }
}

/**
 * Loads custom rules from the filesystem.
 * Only available in Node.js environments.
 */
async function loadCustomRules(options) {
    const loader = new CustomRuleLoader(options);
    const { rules: customRules, ruleInfo, duplicateWarnings } = await loader.loadRulesWithInfo();
    return {
        rules: customRules,
        ruleInfo,
        warnings: duplicateWarnings
    };
}

class FileProcessor {
    linter = null;
    customRulesLoaded = false;
    isRuleAutocorrectable(ruleName) {
        if (!this.linter)
            return false;
        const RuleClass = this.linter.rules.find((rule) => {
            const instance = new rule();
            return instance.name === ruleName;
        });
        if (!RuleClass)
            return false;
        return RuleClass.autocorrectable === true;
    }
    async processFiles(files, formatOption = 'detailed', context) {
        let totalErrors = 0;
        let totalWarnings = 0;
        let totalInfo = 0;
        let totalHints = 0;
        let totalIgnored = 0;
        let totalWouldBeIgnored = 0;
        let filesWithOffenses = 0;
        let filesFixed = 0;
        let ruleCount = 0;
        const allOffenses = [];
        const ruleOffenses = new Map();
        if (!this.linter) {
            let customRules = undefined;
            let customRuleInfo = [];
            let customRuleWarnings = [];
            if (context?.loadCustomRules && !this.customRulesLoaded) {
                try {
                    const result = await loadCustomRules({
                        baseDir: context.projectPath,
                        silent: formatOption === 'json'
                    });
                    customRules = result.rules;
                    customRuleInfo = result.ruleInfo;
                    customRuleWarnings = result.warnings;
                    this.customRulesLoaded = true;
                    if (customRules.length > 0 && formatOption !== 'json') {
                        const ruleText = customRules.length === 1 ? 'rule' : 'rules';
                        console.log(colorize(`\nLoaded ${customRules.length} custom ${ruleText}:`, "green"));
                        for (const { name, path } of customRuleInfo) {
                            const relativePath = context.projectPath ? path.replace(context.projectPath + '/', '') : path;
                            console.log(colorize(`   ${name}`, "cyan") + colorize(` (${relativePath})`, "dim"));
                        }
                        if (customRuleWarnings.length > 0) {
                            console.log();
                            for (const warning of customRuleWarnings) {
                                console.warn(colorize(`   ${warning}`, "yellow"));
                            }
                        }
                        console.log();
                    }
                }
                catch (error) {
                    if (formatOption !== 'json') {
                        console.warn(colorize(`Warning: Failed to load custom rules: ${error}`, "yellow"));
                    }
                }
            }
            this.linter = Linter.from(Herb, context?.config, customRules);
        }
        for (const filename of files) {
            const filePath = context?.projectPath ? path$1$1.resolve(context.projectPath, filename) : path$1$1.resolve(filename);
            let content = fs.readFileSync(filePath, "utf-8");
            const lintResult = this.linter.lint(content, {
                fileName: filename,
                ignoreDisableComments: context?.ignoreDisableComments
            });
            if (ruleCount === 0) {
                ruleCount = this.linter.getRuleCount();
            }
            if (context?.fix && lintResult.offenses.length > 0) {
                const autofixResult = this.linter.autofix(content, {
                    fileName: filename,
                    ignoreDisableComments: context?.ignoreDisableComments
                });
                if (autofixResult.fixed.length > 0) {
                    fs.writeFileSync(filePath, autofixResult.source, "utf-8");
                    filesFixed++;
                    if (formatOption !== 'json') {
                        console.log(`${colorize("", "brightGreen")} ${colorize(filename, "cyan")} - ${colorize(`Fixed ${autofixResult.fixed.length} offense(s)`, "green")}`);
                    }
                }
                content = autofixResult.source;
                for (const offense of autofixResult.unfixed) {
                    allOffenses.push({
                        filename,
                        offense: offense,
                        content,
                        autocorrectable: this.isRuleAutocorrectable(offense.rule)
                    });
                    const ruleData = ruleOffenses.get(offense.rule) || { count: 0, files: new Set() };
                    ruleData.count++;
                    ruleData.files.add(filename);
                    ruleOffenses.set(offense.rule, ruleData);
                }
                if (autofixResult.unfixed.length > 0) {
                    totalErrors += autofixResult.unfixed.filter(offense => offense.severity === "error").length;
                    totalWarnings += autofixResult.unfixed.filter(offense => offense.severity === "warning").length;
                    totalInfo += autofixResult.unfixed.filter(offense => offense.severity === "info").length;
                    totalHints += autofixResult.unfixed.filter(offense => offense.severity === "hint").length;
                    filesWithOffenses++;
                }
            }
            else if (lintResult.offenses.length === 0) {
                if (files.length === 1 && formatOption !== 'json') {
                    console.log(`${colorize("", "brightGreen")} ${colorize(filename, "cyan")} - ${colorize("No issues found", "green")}`);
                }
            }
            else {
                for (const offense of lintResult.offenses) {
                    allOffenses.push({
                        filename,
                        offense: offense,
                        content,
                        autocorrectable: this.isRuleAutocorrectable(offense.rule)
                    });
                    const ruleData = ruleOffenses.get(offense.rule) || { count: 0, files: new Set() };
                    ruleData.count++;
                    ruleData.files.add(filename);
                    ruleOffenses.set(offense.rule, ruleData);
                }
                totalErrors += lintResult.errors;
                totalWarnings += lintResult.warnings;
                totalInfo += lintResult.offenses.filter(o => o.severity === "info").length;
                totalHints += lintResult.offenses.filter(o => o.severity === "hint").length;
                filesWithOffenses++;
            }
            totalIgnored += lintResult.ignored;
            if (lintResult.wouldBeIgnored) {
                totalWouldBeIgnored += lintResult.wouldBeIgnored;
            }
        }
        const result = {
            totalErrors,
            totalWarnings,
            totalInfo,
            totalHints,
            totalIgnored,
            filesWithOffenses,
            filesFixed,
            ruleCount,
            allOffenses,
            ruleOffenses,
            context
        };
        if (totalWouldBeIgnored > 0) {
            result.totalWouldBeIgnored = totalWouldBeIgnored;
        }
        return result;
    }
}

class SummaryReporter {
    pluralize(count, singular, plural) {
        return count === 1 ? singular : (plural || `${singular}s`);
    }
    displaySummary(data) {
        const { files, totalErrors, totalWarnings, totalInfo = 0, totalHints = 0, totalIgnored, totalWouldBeIgnored, filesWithOffenses, ruleCount, startTime, startDate, showTiming, autofixableCount, ignoreDisableComments } = data;
        console.log("\n");
        console.log(` ${colorize("Summary:", "bold")}`);
        const labelWidth = 12;
        const pad = (label) => label.padEnd(labelWidth);
        console.log(`  ${colorize(pad("Checked"), "gray")} ${colorize(`${files.length} ${this.pluralize(files.length, "file")}`, "cyan")}`);
        if (files.length > 1) {
            const filesChecked = files.length;
            const filesClean = filesChecked - filesWithOffenses;
            let filesSummary = "";
            let shouldDim = false;
            if (filesWithOffenses > 0) {
                filesSummary = `${colorize(colorize(`${filesWithOffenses} with offenses`, "brightRed"), "bold")} | ${colorize(colorize(`${filesClean} clean`, "green"), "bold")} ${colorize(colorize(`(${filesChecked} total)`, "gray"), "dim")}`;
            }
            else {
                filesSummary = `${colorize(colorize(`${filesChecked} clean`, "green"), "bold")} ${colorize(colorize(`(${filesChecked} total)`, "gray"), "dim")}`;
                shouldDim = true;
            }
            if (shouldDim) {
                console.log(colorize(`  ${colorize(pad("Files"), "gray")} ${filesSummary}`, "dim"));
            }
            else {
                console.log(`  ${colorize(pad("Files"), "gray")} ${filesSummary}`);
            }
        }
        let offensesSummary = "";
        const parts = [];
        if (totalErrors > 0) {
            parts.push(colorize(colorize(`${totalErrors} ${this.pluralize(totalErrors, "error")}`, "brightRed"), "bold"));
        }
        if (totalWarnings > 0) {
            parts.push(colorize(colorize(`${totalWarnings} ${this.pluralize(totalWarnings, "warning")}`, "brightYellow"), "bold"));
        }
        else if (totalErrors > 0) {
            parts.push(colorize(colorize(`${totalWarnings} ${this.pluralize(totalWarnings, "warning")}`, "green"), "bold"));
        }
        if (totalInfo > 0) {
            parts.push(colorize(colorize(`${totalInfo} info`, "brightBlue"), "bold"));
        }
        if (totalHints > 0) {
            parts.push(colorize(colorize(`${totalHints} ${this.pluralize(totalHints, "hint")}`, "gray"), "bold"));
        }
        if (totalIgnored > 0) {
            parts.push(colorize(colorize(`${totalIgnored} ignored`, "gray"), "bold"));
        }
        if (parts.length === 0) {
            offensesSummary = colorize(colorize("0 offenses", "green"), "bold");
        }
        else {
            offensesSummary = parts.join(" | ");
            let detailText = "";
            const totalOffenses = totalErrors + totalWarnings + totalInfo + totalHints;
            if (filesWithOffenses > 0) {
                detailText = `${totalOffenses} ${this.pluralize(totalOffenses, "offense")} across ${filesWithOffenses} ${this.pluralize(filesWithOffenses, "file")}`;
            }
            if (detailText) {
                offensesSummary += ` ${colorize(colorize(`(${detailText})`, "gray"), "dim")}`;
            }
        }
        console.log(`  ${colorize(pad("Offenses"), "gray")} ${offensesSummary}`);
        if (ignoreDisableComments && totalWouldBeIgnored && totalWouldBeIgnored > 0) {
            const message = `${colorize(colorize(`${totalWouldBeIgnored} additional ${this.pluralize(totalWouldBeIgnored, "offense")} reported (would have been ignored)`, "cyan"), "bold")}`;
            console.log(`  ${colorize(pad("Note"), "gray")} ${message}`);
        }
        const totalOffenses = totalErrors + totalWarnings + totalInfo + totalHints;
        if (autofixableCount > 0 || totalOffenses > 0) {
            let fixableLine = `${colorize(colorize(`${totalOffenses} ${this.pluralize(totalOffenses, "offense")}`, "brightRed"), "bold")}`;
            if (autofixableCount > 0) {
                fixableLine += ` | ${colorize(colorize(`${autofixableCount} autocorrectable using \`--fix\``, "green"), "bold")}`;
            }
            console.log(`  ${colorize(pad("Fixable"), "gray")} ${fixableLine}`);
        }
        if (showTiming) {
            const duration = Date.now() - startTime;
            const timeString = startDate.toTimeString().split(' ')[0];
            console.log(`  ${colorize(pad("Start at"), "gray")} ${colorize(timeString, "cyan")}`);
            console.log(`  ${colorize(pad("Duration"), "gray")} ${colorize(`${duration}ms`, "cyan")} ${colorize(colorize(`(${ruleCount} ${this.pluralize(ruleCount, "rule")})`, "gray"), "dim")}`);
        }
        if (filesWithOffenses === 0 && files.length > 1) {
            console.log("");
            console.log(` ${colorize("", "brightGreen")} ${colorize("All files are clean!", "green")}`);
        }
    }
    displayMostViolatedRules(ruleOffenses, limit = 5) {
        if (ruleOffenses.size === 0)
            return;
        const allRules = Array.from(ruleOffenses.entries()).sort((a, b) => b[1].count - a[1].count);
        const displayedRules = allRules.slice(0, limit);
        const remainingRules = allRules.slice(limit);
        const title = ruleOffenses.size <= limit ? "Rule offenses:" : "Most frequent rule offenses:";
        console.log(` ${colorize(title, "bold")}`);
        for (const [rule, data] of displayedRules) {
            const fileCount = data.files.size;
            const countText = `(${data.count} ${this.pluralize(data.count, "offense")} in ${fileCount} ${this.pluralize(fileCount, "file")})`;
            console.log(`  ${colorize(rule, "gray")} ${colorize(colorize(countText, "gray"), "dim")}`);
        }
        if (remainingRules.length > 0) {
            const remainingOffenseCount = remainingRules.reduce((sum, [_, data]) => sum + data.count, 0);
            const remainingRuleCount = remainingRules.length;
            console.log(colorize(colorize(`\n  ...and ${remainingRuleCount} more ${this.pluralize(remainingRuleCount, "rule")} with ${remainingOffenseCount} ${this.pluralize(remainingOffenseCount, "offense")}`, "gray"), "dim"));
        }
    }
}

class BaseFormatter {
}

class SimpleFormatter extends BaseFormatter {
    async format(allOffenses) {
        if (allOffenses.length === 0)
            return;
        const groupedOffenses = new Map();
        for (const processedFile of allOffenses) {
            const offenses = groupedOffenses.get(processedFile.filename) || [];
            offenses.push(processedFile);
            groupedOffenses.set(processedFile.filename, offenses);
        }
        for (const [filename, processedFiles] of groupedOffenses) {
            console.log("");
            this.formatFileProcessed(filename, processedFiles);
        }
    }
    formatFile(filename, offenses) {
        console.log(`${colorize(filename, "cyan")}:`);
        for (const offense of offenses) {
            const isError = offense.severity === "error";
            const severity = isError ? colorize("", "brightRed") : colorize("", "brightYellow");
            const rule = colorize(`(${offense.code})`, "blue");
            const locationString = `${offense.location.start.line}:${offense.location.start.column}`;
            const paddedLocation = locationString.padEnd(4);
            console.log(`  ${colorize(paddedLocation, "gray")} ${severity} ${offense.message} ${rule}`);
        }
        console.log("");
    }
    formatFileProcessed(filename, processedFiles) {
        console.log(`${colorize(filename, "cyan")}:`);
        for (const { offense, autocorrectable } of processedFiles) {
            const isError = offense.severity === "error";
            const severity = isError ? colorize("", "brightRed") : colorize("", "brightYellow");
            const rule = colorize(`(${offense.code})`, "blue");
            const locationString = `${offense.location.start.line}:${offense.location.start.column}`;
            const paddedLocation = locationString.padEnd(4);
            const correctable = autocorrectable ? colorize(colorize(" [Correctable]", "green"), "bold") : "";
            console.log(`  ${colorize(paddedLocation, "gray")} ${severity} ${offense.message} ${rule}${correctable}`);
        }
        console.log("");
    }
}

class DetailedFormatter extends BaseFormatter {
    highlighter = null;
    theme;
    wrapLines;
    truncateLines;
    constructor(theme = DEFAULT_THEME, wrapLines = true, truncateLines = false) {
        super();
        this.theme = theme;
        this.wrapLines = wrapLines;
        this.truncateLines = truncateLines;
    }
    async format(allOffenses, isSingleFile = false) {
        if (allOffenses.length === 0)
            return;
        if (!this.highlighter) {
            this.highlighter = new Highlighter(this.theme);
            await this.highlighter.initialize();
        }
        if (isSingleFile) {
            const { filename, content } = allOffenses[0];
            const diagnostics = allOffenses.map(item => {
                if (item.autocorrectable && item.offense.code) {
                    return {
                        ...item.offense,
                        message: `${item.offense.message} ${colorize(colorize("[Correctable]", "green"), "bold")}`
                    };
                }
                return item.offense;
            });
            const highlighted = this.highlighter.highlight(filename, content, {
                diagnostics: diagnostics,
                splitDiagnostics: true,
                contextLines: 2,
                wrapLines: this.wrapLines,
                truncateLines: this.truncateLines
            });
            console.log(`\n${highlighted}`);
        }
        else {
            const totalMessageCount = allOffenses.length;
            for (let i = 0; i < allOffenses.length; i++) {
                const { filename, offense, content, autocorrectable } = allOffenses[i];
                let modifiedOffense = offense;
                if (autocorrectable && offense.code) {
                    modifiedOffense = {
                        ...offense,
                        message: `${offense.message} ${colorize(colorize("[Correctable]", "green"), "bold")}`
                    };
                }
                const formatted = this.highlighter.highlightDiagnostic(filename, modifiedOffense, content, {
                    contextLines: 2,
                    wrapLines: this.wrapLines,
                    truncateLines: this.truncateLines
                });
                console.log(`\n${formatted}`);
                const width = LineWrapper.getTerminalWidth();
                const progressText = `[${i + 1}/${totalMessageCount}]`;
                const rightPadding = 16;
                const separatorLength = Math.max(0, width - progressText.length - 1 - rightPadding);
                const separator = '';
                const leftSeparator = colorize(separator.repeat(separatorLength), "gray");
                const rightSeparator = colorize(separator.repeat(4), "gray");
                const progress = colorize(progressText, "gray");
                console.log(colorize(`${leftSeparator}  ${progress}`, "dim") + colorize(` ${rightSeparator}\n`, "dim"));
            }
        }
    }
    formatFile(_filename, _offenses) {
        throw new Error("formatFile is not implemented for DetailedFormatter");
    }
}

// https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-commands
class GitHubActionsFormatter extends BaseFormatter {
    highlighter;
    wrapLines;
    truncateLines;
    constructor(wrapLines = true, truncateLines = false) {
        super();
        this.wrapLines = wrapLines;
        this.truncateLines = truncateLines;
        this.highlighter = new Highlighter();
    }
    static MESSAGE_ESCAPE_MAP = {
        '%': '%25',
        '\n': '%0A',
        '\r': '%0D'
    };
    static PARAM_ESCAPE_MAP = {
        '%': '%25',
        '\n': '%0A',
        '\r': '%0D',
        ':': '%3A',
        ',': '%2C'
    };
    async format(allDiagnostics, _isSingleFile = false) {
        await this.formatAnnotations(allDiagnostics);
    }
    async formatAnnotations(allDiagnostics) {
        if (allDiagnostics.length === 0)
            return;
        if (!this.highlighter.initialized) {
            await this.highlighter.initialize();
        }
        for (const { filename, offense, content } of allDiagnostics) {
            const originalNoColor = process.env.NO_COLOR;
            process.env.NO_COLOR = "1";
            let plainCodePreview = "";
            try {
                const formatted = this.highlighter.highlightDiagnostic(filename, offense, content, {
                    contextLines: 2,
                    wrapLines: this.wrapLines,
                    truncateLines: this.truncateLines
                });
                plainCodePreview = formatted.split('\n').slice(1).join('\n');
            }
            finally {
                if (originalNoColor === undefined) {
                    delete process.env.NO_COLOR;
                }
                else {
                    process.env.NO_COLOR = originalNoColor;
                }
            }
            this.formatDiagnostic(filename, offense, plainCodePreview);
        }
    }
    formatFile(filename, diagnostics) {
        for (const diagnostic of diagnostics) {
            this.formatDiagnostic(filename, diagnostic);
        }
    }
    // GitHub Actions annotation format:
    // ::{level} file={file},line={line},col={col},title={title}::{message}
    //
    formatDiagnostic(filename, diagnostic, codePreview = "") {
        let level;
        switch (diagnostic.severity) {
            case "error":
                level = "error";
                break;
            case "warning":
                level = "warning";
                break;
            case "info":
            case "hint":
                level = "notice";
                break;
            default:
                level = "warning";
        }
        const { line, column } = diagnostic.location.start;
        const escapedFilename = this.escapeParam(filename);
        let message = diagnostic.message;
        if (diagnostic.code) {
            message += ` [${diagnostic.code}]`;
        }
        if (codePreview) {
            message += "\n\n" + codePreview;
        }
        const escapedMessage = this.escapeMessage(message);
        let annotations = `file=${escapedFilename},line=${line},col=${column}`;
        if (diagnostic.code) {
            const title = `${diagnostic.code}  ${name}@${version}`;
            const escapedTitle = this.escapeParam(title);
            annotations += `,title=${escapedTitle}`;
        }
        console.log(`\n::${level} ${annotations}::${escapedMessage}`);
    }
    escapeMessage(string) {
        return string.replace(new RegExp(Object.keys(GitHubActionsFormatter.MESSAGE_ESCAPE_MAP).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'g'), match => GitHubActionsFormatter.MESSAGE_ESCAPE_MAP[match]);
    }
    escapeParam(string) {
        return string.replace(new RegExp(Object.keys(GitHubActionsFormatter.PARAM_ESCAPE_MAP).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'g'), match => GitHubActionsFormatter.PARAM_ESCAPE_MAP[match]);
    }
}

class OutputManager {
    summaryReporter = new SummaryReporter();
    /**
     * Output successful lint results
     */
    async outputResults(results, options) {
        const { allOffenses, files, totalErrors, totalWarnings, totalInfo, totalHints, totalIgnored, totalWouldBeIgnored, filesWithOffenses, ruleCount, ruleOffenses, context } = results;
        const autofixableCount = allOffenses.filter(offense => offense.autocorrectable).length;
        if (options.useGitHubActions) {
            const githubFormatter = new GitHubActionsFormatter(options.wrapLines, options.truncateLines);
            await githubFormatter.formatAnnotations(allOffenses);
            if (options.formatOption !== "json") {
                const regularFormatter = options.formatOption === "simple"
                    ? new SimpleFormatter()
                    : new DetailedFormatter(options.theme, options.wrapLines, options.truncateLines);
                await regularFormatter.format(allOffenses, files.length === 1);
                this.summaryReporter.displayMostViolatedRules(ruleOffenses);
                this.summaryReporter.displaySummary({
                    files,
                    totalErrors,
                    totalWarnings,
                    totalInfo,
                    totalHints,
                    totalIgnored,
                    totalWouldBeIgnored,
                    filesWithOffenses,
                    ruleCount,
                    startTime: options.startTime,
                    startDate: options.startDate,
                    showTiming: options.showTiming,
                    ruleOffenses,
                    autofixableCount,
                    ignoreDisableComments: context?.ignoreDisableComments,
                });
            }
        }
        else if (options.formatOption === "json") {
            const output = {
                offenses: allOffenses.map(({ filename, offense }) => ({
                    filename,
                    message: offense.message,
                    location: offense.location.toJSON(),
                    severity: offense.severity,
                    code: offense.code,
                    source: offense.source
                })),
                summary: {
                    filesChecked: files.length,
                    filesWithOffenses,
                    totalErrors,
                    totalWarnings,
                    totalInfo,
                    totalHints,
                    totalIgnored,
                    totalOffenses: totalErrors + totalWarnings,
                    ruleCount
                },
                timing: null,
                completed: true,
                clean: totalErrors === 0 && totalWarnings === 0,
                message: null
            };
            const duration = Date.now() - options.startTime;
            output.timing = options.showTiming ? {
                startTime: options.startDate.toISOString(),
                duration: duration
            } : null;
            console.log(JSON.stringify(output, null, 2));
        }
        else {
            const formatter = options.formatOption === "simple"
                ? new SimpleFormatter()
                : new DetailedFormatter(options.theme, options.wrapLines, options.truncateLines);
            await formatter.format(allOffenses, files.length === 1);
            this.summaryReporter.displayMostViolatedRules(ruleOffenses);
            this.summaryReporter.displaySummary({
                files,
                totalErrors,
                totalWarnings,
                totalInfo,
                totalHints,
                totalIgnored,
                totalWouldBeIgnored,
                filesWithOffenses,
                ruleCount,
                startTime: options.startTime,
                startDate: options.startDate,
                showTiming: options.showTiming,
                ruleOffenses,
                autofixableCount,
                ignoreDisableComments: context?.ignoreDisableComments,
            });
        }
    }
    /**
     * Output informational message (like "no files found")
     */
    outputInfo(message, options) {
        if (options.useGitHubActions) ;
        else if (options.formatOption === "json") {
            const output = {
                offenses: [],
                summary: {
                    filesChecked: 0,
                    filesWithOffenses: 0,
                    totalErrors: 0,
                    totalWarnings: 0,
                    totalInfo: 0,
                    totalHints: 0,
                    totalIgnored: 0,
                    totalOffenses: 0,
                    ruleCount: 0
                },
                timing: null,
                completed: false,
                clean: null,
                message
            };
            const duration = Date.now() - options.startTime;
            output.timing = options.showTiming ? {
                startTime: options.startDate.toISOString(),
                duration: duration
            } : null;
            console.log(JSON.stringify(output, null, 2));
        }
        else {
            console.log(message);
        }
    }
    /**
     * Output error message
     */
    outputError(message, options) {
        if (options.useGitHubActions) {
            console.log(`::error::${message}`);
        }
        else if (options.formatOption === "json") {
            const output = {
                offenses: [],
                summary: null,
                timing: null,
                completed: false,
                clean: null,
                message
            };
            console.log(JSON.stringify(output, null, 2));
        }
        else {
            console.error(message);
        }
    }
}

class CLI {
    argumentParser = new ArgumentParser();
    fileProcessor = new FileProcessor();
    outputManager = new OutputManager();
    projectPath = process.cwd();
    getProjectPath() {
        return this.projectPath;
    }
    exitWithError(message, formatOption, exitCode = 1) {
        this.outputManager.outputError(message, {
            formatOption,
            theme: 'auto',
            wrapLines: false,
            truncateLines: false,
            showTiming: false,
            useGitHubActions: false,
            startTime: 0,
            startDate: new Date()
        });
        process.exit(exitCode);
    }
    exitWithInfo(message, formatOption, exitCode = 0, timingData) {
        const outputOptions = {
            formatOption,
            theme: 'auto',
            wrapLines: false,
            truncateLines: false,
            showTiming: timingData?.showTiming ?? false,
            useGitHubActions: false,
            startTime: timingData?.startTime ?? Date.now(),
            startDate: timingData?.startDate ?? new Date()
        };
        this.outputManager.outputInfo(message, outputOptions);
        process.exit(exitCode);
    }
    determineProjectPath(patterns) {
        const pattern = patterns[0];
        if (pattern) {
            const resolvedPattern = path$1$1.resolve(pattern);
            if (fs.existsSync(resolvedPattern)) {
                const stats = fs.statSync(resolvedPattern);
                if (stats.isDirectory()) {
                    this.projectPath = resolvedPattern;
                }
                else {
                    this.projectPath = path$1$1.dirname(resolvedPattern);
                }
            }
        }
    }
    adjustPattern(pattern, configGlobPattern) {
        if (!pattern) {
            return configGlobPattern;
        }
        const resolvedPattern = path$1$1.resolve(pattern);
        if (fs.existsSync(resolvedPattern)) {
            const stats = fs.statSync(resolvedPattern);
            if (stats.isDirectory()) {
                return configGlobPattern;
            }
            else if (stats.isFile()) {
                return path$1$1.relative(this.projectPath, resolvedPattern);
            }
        }
        return pattern;
    }
    async resolvePatternToFiles(pattern, config, force) {
        const resolvedPattern = path$1$1.resolve(pattern);
        const isExplicitFile = fs.existsSync(resolvedPattern) && fs.statSync(resolvedPattern).isFile();
        let explicitFile;
        if (isExplicitFile) {
            explicitFile = pattern;
        }
        const filesConfig = config.getFilesConfigForTool('linter');
        const configGlobPattern = filesConfig.include && filesConfig.include.length > 0
            ? (filesConfig.include.length === 1 ? filesConfig.include[0] : `{${filesConfig.include.join(',')}}`)
            : '**/*.html.erb';
        const adjustedPattern = this.adjustPattern(pattern, configGlobPattern);
        let files = await glob$1(adjustedPattern, {
            cwd: this.projectPath,
            ignore: filesConfig.exclude || []
        });
        if (explicitFile && files.length === 0) {
            if (!force) {
                console.error(`  File ${explicitFile} is excluded by configuration patterns.`);
                console.error(`   Use --force to lint it anyway.\n`);
                process.exit(0);
            }
            else {
                console.log(`  Forcing linter on excluded file: ${explicitFile}`);
                console.log();
                files = [adjustedPattern];
            }
        }
        return { files, explicitFile };
    }
    async beforeProcess() {
        // Hook for subclasses to add custom output before processing
    }
    async afterProcess(_results, _outputOptions) {
        // Hook for subclasses to add custom output after processing
    }
    async run() {
        await Herb.load();
        const startTime = Date.now();
        const startDate = new Date();
        let { patterns, configFile, formatOption, showTiming, theme, wrapLines, truncateLines, useGitHubActions, fix, ignoreDisableComments, force, init, loadCustomRules } = this.argumentParser.parse(process.argv);
        this.determineProjectPath(patterns);
        if (init) {
            const configPath = configFile || this.projectPath;
            if (Config.exists(configPath)) {
                const fullPath = configFile || Config.configPathFromProjectPath(this.projectPath);
                console.error(`\n Configuration file already exists at ${fullPath}`);
                console.error(`  Use --config-file to specify a different location.\n`);
                process.exit(1);
            }
            const config = await Config.loadForCLI(configPath, version, true);
            const extensionAdded = addHerbExtensionRecommendation(this.projectPath);
            console.log(`\n Configuration initialized at ${config.path}`);
            if (extensionAdded) {
                console.log(` VSCode extension recommended in ${getExtensionsJsonRelativePath()}`);
            }
            console.log(`  Edit this file to customize linter and formatter settings.\n`);
            process.exit(0);
        }
        const silent = formatOption === 'json';
        const config = await Config.load(configFile || this.projectPath, { version, exitOnError: true, createIfMissing: false, silent });
        const linterConfig = config.options.linter || {};
        const outputOptions = {
            formatOption,
            theme,
            wrapLines,
            truncateLines,
            showTiming,
            useGitHubActions,
            startTime,
            startDate
        };
        try {
            await this.beforeProcess();
            if (linterConfig.enabled === false && !force) {
                this.exitWithInfo("Linter is disabled in .herb.yml configuration. Use --force to lint anyway.", formatOption, 0, { startTime, startDate, showTiming });
            }
            if (force && linterConfig.enabled === false) {
                console.log("  Forcing linter run (disabled in .herb.yml)");
                console.log();
            }
            let files;
            let explicitFiles = [];
            if (patterns.length === 0) {
                files = await config.findFilesForTool('linter', this.projectPath);
            }
            else {
                const allFiles = [];
                for (const pattern of patterns) {
                    const { files: patternFiles, explicitFile } = await this.resolvePatternToFiles(pattern, config, force);
                    if (patternFiles.length === 0) {
                        console.error(` No files found matching pattern: ${pattern}`);
                        process.exit(1);
                    }
                    allFiles.push(...patternFiles);
                    if (explicitFile) {
                        explicitFiles.push(explicitFile);
                    }
                }
                files = [...new Set(allFiles)];
            }
            if (files.length === 0) {
                this.exitWithInfo(`No files found matching patterns: ${patterns.join(', ') || 'from config'}`, formatOption, 0, { startTime, startDate, showTiming });
            }
            let processingConfig = config;
            if (force && explicitFiles.length > 0) {
                const modifiedConfig = Object.create(Object.getPrototypeOf(config));
                Object.assign(modifiedConfig, config);
                modifiedConfig.config = {
                    ...config.config,
                    linter: {
                        ...config.config.linter,
                        exclude: []
                    }
                };
                processingConfig = modifiedConfig;
            }
            const context = {
                projectPath: this.projectPath,
                pattern: patterns.join(' '),
                fix,
                ignoreDisableComments,
                linterConfig,
                config: processingConfig,
                loadCustomRules
            };
            const results = await this.fileProcessor.processFiles(files, formatOption, context);
            await this.outputManager.outputResults({ ...results, files }, outputOptions);
            await this.afterProcess(results, outputOptions);
            if (results.totalErrors > 0) {
                process.exit(1);
            }
        }
        catch (error) {
            this.exitWithError(`Error: ${error}`, formatOption);
        }
    }
}

const cli = new CLI();
cli.run();
//# sourceMappingURL=herb-lint.js.map

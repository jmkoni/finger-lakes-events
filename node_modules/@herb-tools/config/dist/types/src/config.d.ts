import { DiagnosticSeverity } from "@herb-tools/core";
export interface ConfigValidationError {
    message: string;
    path: (string | number | symbol)[];
    code: string;
    line?: number;
    column?: number;
    severity?: 'error' | 'warning';
}
export type FilesConfig = {
    include?: string[];
    exclude?: string[];
};
export type RuleConfig = {
    enabled?: boolean;
    severity?: DiagnosticSeverity;
    autoCorrect?: boolean;
    include?: string[];
    only?: string[];
    exclude?: string[];
};
export type LinterConfig = {
    enabled?: boolean;
    include?: string[];
    exclude?: string[];
    rules?: Record<string, RuleConfig>;
};
export type FormatterConfig = {
    enabled?: boolean;
    include?: string[];
    exclude?: string[];
    indentWidth?: number;
    maxLineLength?: number;
    rewriter?: {
        pre?: string[];
        post?: string[];
    };
};
export type HerbConfigOptions = {
    files?: FilesConfig;
    linter?: LinterConfig;
    formatter?: FormatterConfig;
};
export type HerbConfig = HerbConfigOptions & {
    version: string;
};
export type LoadOptions = {
    silent?: boolean;
    version?: string;
    createIfMissing?: boolean;
    exitOnError?: boolean;
};
export type FromObjectOptions = {
    projectPath?: string;
    version?: string;
};
export declare class Config {
    static configPath: string;
    private static PROJECT_INDICATORS;
    readonly path: string;
    config: HerbConfig;
    constructor(projectPath: string, config: HerbConfig);
    get projectPath(): string;
    get version(): string;
    get options(): HerbConfigOptions;
    get linter(): LinterConfig | undefined;
    get formatter(): FormatterConfig | undefined;
    toJSON(): string;
    /**
     * Check if the linter is enabled.
     * @returns true if linter is enabled (default), false if explicitly disabled
     */
    get isLinterEnabled(): boolean;
    /**
     * Check if the formatter is enabled.
     * @returns true if formatter is enabled (default), false if explicitly disabled
     */
    get isFormatterEnabled(): boolean;
    /**
     * Check if a specific rule is disabled.
     * @param ruleName - The name of the rule to check
     * @returns true if the rule is explicitly disabled, false otherwise
     */
    isRuleDisabled(ruleName: string): boolean;
    /**
     * Check if a specific rule is enabled.
     * @param ruleName - The name of the rule to check
     * @returns true if the rule is enabled, false otherwise
     */
    isRuleEnabled(ruleName: string): boolean;
    /**
     * Get the files configuration for a specific tool.
     * Tool-specific file config takes precedence over top-level config.
     * Include patterns are additive (defaults are already merged in this.config).
     * @param tool - The tool to get files config for ('linter' or 'formatter')
     * @returns The merged files configuration
     */
    getFilesConfigForTool(tool: 'linter' | 'formatter'): FilesConfig;
    /**
     * Get the files configuration for the linter.
     * Linter-specific file config takes precedence over top-level config.
     * @returns The merged files configuration for linter
     */
    get filesConfigForLinter(): FilesConfig;
    /**
     * Get the files configuration for the formatter.
     * Formatter-specific file config takes precedence over top-level config.
     * @returns The merged files configuration for formatter
     */
    get filesConfigForFormatter(): FilesConfig;
    /**
     * Find files for a specific tool based on its configuration.
     * Uses include patterns from config, applies exclude patterns.
     * @param tool - The tool to find files for ('linter' or 'formatter')
     * @param cwd - The directory to search from (defaults to project path)
     * @returns Promise resolving to array of absolute file paths
     */
    findFilesForTool(tool: 'linter' | 'formatter', cwd?: string): Promise<string[]>;
    /**
     * Find files for the linter based on linter configuration.
     * @param cwd - The directory to search from (defaults to project path)
     * @returns Promise resolving to array of absolute file paths
     */
    findFilesForLinter(cwd?: string): Promise<string[]>;
    /**
     * Find files for the formatter based on formatter configuration.
     * @param cwd - The directory to search from (defaults to project path)
     * @returns Promise resolving to array of absolute file paths
     */
    findFilesForFormatter(cwd?: string): Promise<string[]>;
    /**
     * Check if a file path is excluded by glob patterns.
     * @param filePath - The file path to check
     * @param excludePatterns - Array of glob patterns to check against
     * @returns true if the path matches any exclude pattern
     */
    private isPathExcluded;
    /**
     * Check if a file path matches any of the include patterns.
     * @param filePath - The file path to check
     * @param includePatterns - Array of glob patterns to check against
     * @returns true if the path matches any include pattern, or true if no patterns specified
     */
    private isPathIncluded;
    /**
     * Check if a tool (linter or formatter) is enabled for a specific file path.
     * Respects both the tool's enabled state and its exclude patterns.
     * @param filePath - The file path to check
     * @param tool - The tool to check ('linter' or 'formatter')
     * @returns true if the tool is enabled for this path
     */
    isEnabledForPath(filePath: string, tool: 'linter' | 'formatter'): boolean;
    /**
     * Check if the linter is enabled for a specific file path.
     * Respects both linter.enabled and linter.exclude patterns.
     * @param filePath - The file path to check
     * @returns true if the linter is enabled for this path
     */
    isLinterEnabledForPath(filePath: string): boolean;
    /**
     * Check if the formatter is enabled for a specific file path.
     * Respects both formatter.enabled and formatter.exclude patterns.
     * @param filePath - The file path to check
     * @returns true if the formatter is enabled for this path
     */
    isFormatterEnabledForPath(filePath: string): boolean;
    /**
     * Check if a specific rule is enabled for a specific file path.
     * Respects linter.enabled, linter.exclude, rule.enabled, rule.include, rule.only, and rule.exclude patterns.
     *
     * Pattern precedence:
     * - If rule.only is specified: Only files matching 'only' patterns (ignores all 'include' patterns)
     * - If rule.only is NOT specified: Files matching 'include' patterns (if specified, additive)
     * - rule.exclude is always applied regardless of 'only' or 'include'
     *
     * @param ruleName - The name of the rule to check
     * @param filePath - The file path to check
     * @returns true if the rule is enabled for this path
     */
    isRuleEnabledForPath(ruleName: string, filePath: string): boolean;
    /**
     * Apply configured severity overrides to a lint offense.
     * Returns the configured severity if set, otherwise returns the original severity.
     */
    getConfiguredSeverity(ruleName: string, defaultSeverity: DiagnosticSeverity): DiagnosticSeverity;
    /**
     * Apply severity overrides from config to an array of offenses.
     * Each offense must have a `rule` and `severity` property.
     */
    applySeverityOverrides<T extends {
        rule: string;
        severity: DiagnosticSeverity;
    }>(offenses: T[]): T[];
    static configPathFromProjectPath(projectPath: string): string;
    /**
     * Get the default file patterns that Herb recognizes.
     * These are the default extensions/patterns used when no custom patterns are specified.
     * @returns Array of glob patterns for HTML+ERB files
     */
    static getDefaultFilePatterns(): string[];
    /**
     * Check if a .herb.yml config file exists at the given path.
     *
     * @param pathOrFile - Path to directory or explicit config file path
     * @returns True if .herb.yml exists at the location, false otherwise
     */
    static exists(pathOrFile: string): boolean;
    /**
     * Read raw YAML content from a config file.
     * Handles both explicit .herb.yml paths and directory paths.
     *
     * @param pathOrFile - Path to .herb.yml file or directory containing it
     * @returns string - The raw YAML content
     */
    static readRawYaml(pathOrFile: string): string;
    /**
     * Load Herb configuration from a file or directory
     *
     * This is the main entry point for loading configuration. It:
     * 1. Discovers the config file by walking up the directory tree
     * 2. Reads and validates the config
     * 3. Merges with defaults for a fully resolved config
     * 4. Auto-creates default config if createIfMissing option is true
     * 5. Prints informative messages to console
     *
     * @param pathOrFile - File path, directory path, or any path to start search from
     * @param options - Loading options
     * @returns Promise<Config> - Fully resolved config instance
     */
    static load(pathOrFile: string, options?: LoadOptions): Promise<Config>;
    /**
     * Load config for editor/language server use (silent mode, no file creation).
     * This is a convenience method for the common pattern used in editors.
     *
     * @param pathOrFile - Directory path or explicit .herb.yml file path
     * @param version - Optional version string (defaults to package version)
     * @returns Config instance or throws on errors
     */
    static loadForEditor(pathOrFile: string, version?: string): Promise<Config>;
    /**
     * Load config for CLI use (may create file, show errors).
     * This is a convenience method for the common pattern used in CLI tools.
     *
     * @param pathOrFile - Directory path or explicit .herb.yml file path
     * @param version - Optional version string (defaults to package version)
     * @param createIfMissing - Whether to create config if missing (default: false)
     * @returns Config instance or throws on errors
     */
    static loadForCLI(pathOrFile: string, version?: string, createIfMissing?: boolean): Promise<Config>;
    /**
     * Mutate an existing config file by reading it, validating, merging with a mutation, and writing back.
     * This preserves the user's YAML file structure and only writes what's explicitly configured.
     *
     * @param configPath - Path to the .herb.yml file
     * @param mutation - Partial config to merge (e.g., { linter: { rules: { "rule-name": { enabled: false } } } })
     * @returns Promise<void>
     *
     * @example
     * // Disable a rule in .herb.yml
     * await Config.mutateConfigFile('/path/to/.herb.yml', {
     *   linter: {
     *     rules: {
     *       'html-img-require-alt': { enabled: false }
     *     }
     *   }
     * })
     */
    static mutateConfigFile(configPath: string, mutation: Partial<HerbConfigOptions>): Promise<void>;
    /**
     * Apply mutation to YAML content and return the mutated string (synchronous)
     * Useful for code actions and other scenarios where you need the mutated content
     * without writing to disk.
     *
     * @param yamlContent - The original YAML content (with comments)
     * @param mutation - The mutation to apply
     * @returns The mutated YAML content (with comments preserved)
     */
    static applyMutationToYamlString(yamlContent: string, mutation: Partial<HerbConfigOptions>): string;
    /**
     * Create a new config file content with a mutation applied
     * Uses the default template with comments and applies the mutation
     *
     * @param mutation - The mutation to apply to the default config
     * @param version - The version to use (defaults to package version)
     * @returns The config file content as a YAML string
     */
    static createConfigYamlString(mutation: Partial<HerbConfigOptions>, version?: string): string;
    /**
     * Apply mutation to a YAML document while preserving comments
     * Works recursively to handle nested objects
     */
    private static applyMutationToDocument;
    /**
     * Add spacing between top-level keys and nested rule keys in YAML
     */
    private static addYamlSpacing;
    /**
     * Create a Config instance from a partial config object
     *
     * Useful for testing and programmatic config creation.
     * Deep merges the partial config with defaults.
     *
     * @param partial - Partial config object
     * @param options - Options including projectPath and version
     * @returns Config instance with fully resolved config
     */
    static fromObject(partial: Partial<HerbConfigOptions>, options?: FromObjectOptions): Config;
    /**
     * Find config file by walking up directory tree
     *
     * @param startPath - Path to start searching from (file or directory)
     * @returns Object with configPath (if found) and projectRoot
     */
    private static findConfigFile;
    /**
     * Check if a directory is a project root
     */
    private static isProjectRoot;
    /**
     * Load config from explicit path (from --config-file argument)
     */
    private static loadFromExplicitPath;
    /**
     * Load config from discovered path
     */
    private static loadFromPath;
    /**
     * Create default config at project root
     */
    private static createDefaultConfig;
    /**
     * Validate config text without loading or exiting process
     * Used by language servers to show diagnostics
     * Returns empty array if valid, array of errors/warnings if invalid
     */
    static validateConfigText(text: string, options?: {
        version?: string;
        projectPath?: string;
    }): Promise<ConfigValidationError[]>;
    /**
     * Read, parse, and validate config file
     */
    private static readAndValidateConfig;
    /**
     * Get default configuration object
     */
    private static getDefaultConfig;
}

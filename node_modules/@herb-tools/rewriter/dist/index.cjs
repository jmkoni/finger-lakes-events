'use strict';

/**
 * Base class for AST rewriters that transform AST nodes before formatting
 *
 * AST rewriters receive a Node and can mutate it in place or return a modified Node.
 * They run before the formatting step.
 *
 * @example
 * ```typescript
 * import { ASTRewriter, asMutable } from "@herb-tools/rewriter"
 * import { Visitor } from "@herb-tools/core"
 *
 * class MyRewriter extends ASTRewriter {
 *   get name() { return "my-rewriter" }
 *   get description() { return "My custom AST rewriter" }
 *
 *   async initialize(context) {
 *     // Load config, initialize dependencies, etc.
 *   }
 *
 *   rewrite(node, context) {
 *     // Use visitor pattern to traverse and modify AST
 *     const visitor = new MyVisitor()
 *     visitor.visit(node)
 *
 *     return node
 *   }
 * }
 * ```
 */
class ASTRewriter {
    /**
     * Optional async initialization hook
     *
     * Called once before the first rewrite operation. Use this to:
     * - Load configuration files
     * - Initialize dependencies
     * - Perform expensive setup operations
     *
     * @param context - Context with baseDir and optional filePath
     */
    async initialize(_context) {
        // Override in subclass if needed
    }
}

/**
 * Base class for string rewriters that transform the formatted output
 *
 * String rewriters receive the formatted string and can modify it before
 * returning the final output. They run after the formatting step.
 *
 * @example
 * ```typescript
 * import { StringRewriter } from "@herb-tools/rewriter"
 *
 * class AddTrailingNewline extends StringRewriter {
 *   get name() { return "add-trailing-newline" }
 *   get description() { return "Ensures file ends with a newline" }
 *
 *   rewrite(formatted, context) {
 *     return formatted.endsWith("\n") ? formatted : formatted + "\n"
 *   }
 * }
 * ```
 */
class StringRewriter {
    /**
     * Optional async initialization hook
     *
     * Called once before the first rewrite operation. Use this to:
     * - Load configuration files
     * - Initialize dependencies
     * - Perform expensive setup operations
     *
     * @param context - Context with baseDir and optional filePath
     */
    async initialize(_context) {
        // Override in subclass if needed
    }
}

/**
 * Cast a readonly value to a mutable version
 *
 * @example
 * const literalNode = asMutable(node)
 * literalNode.content = "new value"
 */
function asMutable(node) {
    return node;
}

/**
 * Type guard to check if a class is an ASTRewriter
 * Uses duck typing to work across module boundaries
 */
function isASTRewriterClass(obj) {
    if (typeof obj !== 'function')
        return false;
    if (obj.prototype instanceof ASTRewriter)
        return true;
    let proto = obj.prototype;
    while (proto) {
        if (proto.constructor?.name === 'ASTRewriter')
            return true;
        proto = Object.getPrototypeOf(proto);
    }
    return false;
}
/**
 * Type guard to check if a class is a StringRewriter
 * Uses duck typing to work across module boundaries
 */
function isStringRewriterClass(obj) {
    if (typeof obj !== 'function')
        return false;
    if (obj.prototype instanceof StringRewriter)
        return true;
    let proto = obj.prototype;
    while (proto) {
        if (proto.constructor?.name === 'StringRewriter')
            return true;
        proto = Object.getPrototypeOf(proto);
    }
    return false;
}
/**
 * Type guard to check if a class is any kind of rewriter
 */
function isRewriterClass(obj) {
    return isASTRewriterClass(obj) || isStringRewriterClass(obj);
}

class Position {
    line;
    column;
    static from(positionOrLine, column) {
        if (typeof positionOrLine === "number") {
            return new Position(positionOrLine, column);
        }
        else {
            return new Position(positionOrLine.line, positionOrLine.column);
        }
    }
    static get zero() {
        return new Position(0, 0);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Location {
    start;
    end;
    static from(locationOrLine, column, endLine, endColumn) {
        if (typeof locationOrLine === "number") {
            const start = Position.from(locationOrLine, column);
            const end = Position.from(endLine, endColumn);
            return new Location(start, end);
        }
        else {
            const start = Position.from(locationOrLine.start);
            const end = Position.from(locationOrLine.end);
            return new Location(start, end);
        }
    }
    static get zero() {
        return new Location(Position.zero, Position.zero);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Range {
    start;
    end;
    static from(rangeOrStart, end) {
        if (typeof rangeOrStart === "number") {
            return new Range(rangeOrStart, end);
        }
        else {
            return new Range(rangeOrStart[0], rangeOrStart[1]);
        }
    }
    static get zero() {
        return new Range(0, 0);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range.from(token.range), Location.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/errors.ts.erb
class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
}
class UnexpectedError extends HerbError {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── description: ${JSON.stringify(this.description)}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnexpectedTokenError extends HerbError {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += `└── found: ${this.found ? this.found.treeInspect() : "∅"}\n`;
        return output;
    }
}
class MissingOpeningTagError extends HerbError {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class MissingClosingTagError extends HerbError {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class TagNamesMismatchError extends HerbError {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class QuotesMismatchError extends HerbError {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_quote: data.opening_quote ? Token.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : "∅"}\n`;
        output += `└── closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : "∅"}\n`;
        return output;
    }
}
class VoidElementClosingTagError extends HerbError {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── expected: ${JSON.stringify(this.expected)}\n`;
        output += `└── found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnclosedElementError extends HerbError {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
        return output;
    }
}
class RubyParseError extends HerbError {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `├── error_message: ${JSON.stringify(this.error_message)}\n`;
        output += `├── diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += `└── level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
}
class ERBControlFlowScopeError extends HerbError {
    keyword;
    static from(data) {
        return new ERBControlFlowScopeError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            keyword: data.keyword,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.keyword = props.keyword;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "ERB_CONTROL_FLOW_SCOPE_ERROR",
            keyword: this.keyword,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBControlFlowScopeError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── keyword: ${JSON.stringify(this.keyword)}\n`;
        return output;
    }
}
class MissingERBEndTagError extends HerbError {
    keyword;
    static from(data) {
        return new MissingERBEndTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            keyword: data.keyword,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.keyword = props.keyword;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSINGERB_END_TAG_ERROR",
            keyword: this.keyword,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingERBEndTagError ${this.location.treeInspectWithLabel()}\n`;
        output += `├── message: "${this.message}"\n`;
        output += `└── keyword: ${JSON.stringify(this.keyword)}\n`;
        return output;
    }
}
function fromSerializedError(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError.from(error);
        case "ERB_CONTROL_FLOW_SCOPE_ERROR": return ERBControlFlowScopeError.from(error);
        case "MISSINGERB_END_TAG_ERROR": return MissingERBEndTagError.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}
function convertToUTF8(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/nodes.ts.erb
class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "∅\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length === 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "│   ", isLast, false);
            }
            else {
                const symbol = isLast ? "└── " : "├── ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "∅\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? "└── " : "├── ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index === 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
}
class DocumentNode extends Node {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class LiteralNode extends Node {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
}
class HTMLOpenTagNode extends Node {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        return output;
    }
}
class HTMLCloseTagNode extends Node {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class HTMLElementNode extends Node {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    source;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_tag: data.open_tag ? fromSerializedNode((data.open_tag)) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            close_tag: data.close_tag ? fromSerializedNode((data.close_tag)) : null,
            is_void: data.is_void,
            source: data.source,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
        this.source = props.source;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
            source: this.source,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_tag: ${this.inspectNode(this.open_tag, "│   ")}`;
        output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `├── close_tag: ${this.inspectNode(this.close_tag, "│   ")}`;
        output += `├── is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : "∅"}\n`;
        output += `└── source: ${this.source ? JSON.stringify(this.source) : "∅"}\n`;
        return output;
    }
}
class HTMLAttributeValueNode extends Node {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_quote: data.open_quote ? Token.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            close_quote: data.close_quote ? Token.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── open_quote: ${this.open_quote ? this.open_quote.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── close_quote: ${this.close_quote ? this.close_quote.treeInspect() : "∅"}\n`;
        output += `└── quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : "∅"}\n`;
        return output;
    }
}
class HTMLAttributeNameNode extends Node {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class HTMLAttributeNode extends Node {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            name: data.name ? fromSerializedNode((data.name)) : null,
            equals: data.equals ? Token.from(data.equals) : null,
            value: data.value ? fromSerializedNode((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── name: ${this.inspectNode(this.name, "│   ")}`;
        output += `├── equals: ${this.equals ? this.equals.treeInspect() : "∅"}\n`;
        output += `└── value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
}
class HTMLTextNode extends Node {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── content: ${this.content ? JSON.stringify(this.content) : "∅"}\n`;
        return output;
    }
}
class HTMLCommentNode extends Node {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            comment_start: data.comment_start ? Token.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            comment_end: data.comment_end ? Token.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── comment_start: ${this.comment_start ? this.comment_start.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── comment_end: ${this.comment_end ? this.comment_end.treeInspect() : "∅"}\n`;
        return output;
    }
}
class HTMLDoctypeNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class XMLDeclarationNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class CDATANode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class WhitespaceNode extends Node {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            value: data.value ? Token.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `└── value: ${this.value ? this.value.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBContentNode extends Node {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        // no-op for analyzed_ruby
        output += `├── parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : "∅"}\n`;
        output += `└── valid: ${typeof this.valid === 'boolean' ? String(this.valid) : "∅"}\n`;
        return output;
    }
}
class ERBEndNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBElseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBIfNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── subsequent: ${this.inspectNode(this.subsequent, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBBlockNode extends Node {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── body: ${this.inspectArray(this.body, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhenNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBCaseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBCaseMatchNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── children: ${this.inspectArray(this.children, "│   ")}`;
        output += `├── conditions: ${this.inspectArray(this.conditions, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhileNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUntilNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBForNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBRescueNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `└── subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
}
class ERBEnsureNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBBeginNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── rescue_clause: ${this.inspectNode(this.rescue_clause, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `├── ensure_clause: ${this.inspectNode(this.ensure_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUnlessNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `├── statements: ${this.inspectArray(this.statements, "│   ")}`;
        output += `├── else_clause: ${this.inspectNode(this.else_clause, "│   ")}`;
        output += `└── end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBYieldNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `└── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        return output;
    }
}
class ERBInNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += `├── errors: ${this.inspectArray(this.errors, "│   ")}`;
        output += `├── tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : "∅"}\n`;
        output += `├── content: ${this.content ? this.content.treeInspect() : "∅"}\n`;
        output += `├── tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : "∅"}\n`;
        output += `└── statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
function fromSerializedNode(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode.from(node);
        case "AST_LITERAL_NODE": return LiteralNode.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode.from(node);
        case "AST_CDATA_NODE": return CDATANode.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
}

class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
}

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
class ParseResult extends Result {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode.from(result.value), result.source, result.warnings.map((warning) => HerbWarning.from(warning)), result.errors.map((error) => HerbError.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
}
function isToken(object) {
    return (object instanceof Token) || (object?.constructor?.name === "Token" && "value" in object) || object.type?.startsWith('TOKEN_');
}
function isParseResult(object) {
    return (object instanceof ParseResult) || (object?.constructor?.name === "ParseResult" && "value" in object);
}
/**
 * Compares two positions to determine if the first comes before the second
 * Returns true if pos1 comes before pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionBefore(position1, position2, inclusive = false) {
    if (position1.line < position2.line)
        return true;
    if (position1.line > position2.line)
        return false;
    return inclusive ? position1.column <= position2.column : position1.column < position2.column;
}
/**
 * Compares two positions to determine if the first comes after the second
 * Returns true if pos1 comes after pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionAfter(position1, position2, inclusive = false) {
    if (position1.line > position2.line)
        return true;
    if (position1.line < position2.line)
        return false;
    return inclusive ? position1.column >= position2.column : position1.column > position2.column;
}
/**
 * Gets nodes that end before the specified position
 * @param inclusive - If true, includes nodes that end exactly at the position (default: false, matching half-open interval semantics)
 */
function getNodesBeforePosition(nodes, position, inclusive = false) {
    return nodes.filter(node => node.location && isPositionBefore(node.location.end, position, inclusive));
}
/**
 * Gets nodes that start after the specified position
 * @param inclusive - If true, includes nodes that start exactly at the position (default: true, matching typical boundary behavior)
 */
function getNodesAfterPosition(nodes, position, inclusive = true) {
    return nodes.filter(node => node.location && isPositionAfter(node.location.start, position, inclusive));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.8.2/templates/javascript/packages/core/src/visitor.ts.erb
class Visitor {
    visit(node) {
        if (!node)
            return;
        node.accept(this);
    }
    visitAll(nodes) {
        nodes.forEach(node => node?.accept(this));
    }
    visitChildNodes(node) {
        node.compactChildNodes().forEach(node => node.accept(this));
    }
    visitNode(_node) {
        // Default implementation does nothing
    }
    visitERBNode(_node) {
        // Default implementation does nothing
    }
    visitDocumentNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitLiteralNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLOpenTagNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLCloseTagNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLElementNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNameNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLTextNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLCommentNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLDoctypeNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitXMLDeclarationNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitCDATANode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitWhitespaceNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBIfNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBBlockNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBWhenNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBCaseNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBWhileNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBUntilNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBForNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBRescueNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBEnsureNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBBeginNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBYieldNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBInNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
}

class PrintContext {
    output = "";
    indentLevel = 0;
    currentColumn = 0;
    preserveStack = [];
    /**
     * Write text to the output
     */
    write(text) {
        this.output += text;
        this.currentColumn += text.length;
    }
    /**
     * Write text and update column tracking for newlines
     */
    writeWithColumnTracking(text) {
        this.output += text;
        const lines = text.split('\n');
        if (lines.length > 1) {
            this.currentColumn = lines[lines.length - 1].length;
        }
        else {
            this.currentColumn += text.length;
        }
    }
    /**
     * Increase indentation level
     */
    indent() {
        this.indentLevel++;
    }
    /**
     * Decrease indentation level
     */
    dedent() {
        if (this.indentLevel > 0) {
            this.indentLevel--;
        }
    }
    /**
     * Enter a tag that may preserve whitespace
     */
    enterTag(tagName) {
        this.preserveStack.push(tagName.toLowerCase());
    }
    /**
     * Exit the current tag
     */
    exitTag() {
        this.preserveStack.pop();
    }
    /**
     * Check if we're at the start of a line
     */
    isAtStartOfLine() {
        return this.currentColumn === 0;
    }
    /**
     * Get current indentation level
     */
    getCurrentIndentLevel() {
        return this.indentLevel;
    }
    /**
     * Get current column position
     */
    getCurrentColumn() {
        return this.currentColumn;
    }
    /**
     * Get the current tag stack (for debugging)
     */
    getTagStack() {
        return [...this.preserveStack];
    }
    /**
     * Get the complete output string
     */
    getOutput() {
        return this.output;
    }
    /**
     * Reset the context for reuse
     */
    reset() {
        this.output = "";
        this.indentLevel = 0;
        this.currentColumn = 0;
        this.preserveStack = [];
    }
}

/**
 * Default print options used when none are provided
 */
const DEFAULT_PRINT_OPTIONS = {
    ignoreErrors: false
};
class Printer extends Visitor {
    context = new PrintContext();
    /**
     * Static method to print a node without creating an instance
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    static print(input, options = DEFAULT_PRINT_OPTIONS) {
        const printer = new this();
        return printer.print(input, options);
    }
    /**
     * Print a node, token, or parse result to a string
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    print(input, options = DEFAULT_PRINT_OPTIONS) {
        if (!input)
            return "";
        if (isToken(input)) {
            return input.value;
        }
        if (Array.isArray(input)) {
            this.context.reset();
            input.forEach(node => this.visit(node));
            return this.context.getOutput();
        }
        const node = isParseResult(input) ? input.value : input;
        if (options.ignoreErrors === false && node.recursiveErrors().length > 0) {
            throw new Error(`Cannot print the node (${node.type}) since it or any of its children has parse errors. Either pass in a valid Node or call \`print()\` using \`print(node, { ignoreErrors: true })\``);
        }
        this.context.reset();
        this.visit(node);
        return this.context.getOutput();
    }
    write(content) {
        this.context.write(content);
    }
}

/**
 * IdentityPrinter - Provides lossless reconstruction of the original source
 *
 * This printer aims to reconstruct the original input as faithfully as possible,
 * preserving all whitespace, formatting, and structure. It's useful for:
 * - Testing parser accuracy (input should equal output)
 * - Baseline printing before applying transformations
 * - Verifying AST round-trip fidelity
 */
class IdentityPrinter extends Printer {
    static printERBNode(node) {
        const printer = new IdentityPrinter();
        printer.printERBNode(node);
        return printer.context.getOutput();
    }
    visitLiteralNode(node) {
        this.write(node.content);
    }
    visitHTMLTextNode(node) {
        this.write(node.content);
    }
    visitWhitespaceNode(node) {
        if (node.value) {
            this.write(node.value.value);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            this.write(node.tag_name.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLCloseTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            const before = getNodesBeforePosition(node.children, node.tag_name.location.start, true);
            const after = getNodesAfterPosition(node.children, node.tag_name.location.end);
            this.visitAll(before);
            this.write(node.tag_name.value);
            this.visitAll(after);
        }
        else {
            this.visitAll(node.children);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName) {
            this.context.enterTag(tagName);
        }
        if (node.open_tag) {
            this.visit(node.open_tag);
        }
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        if (tagName) {
            this.context.exitTag();
        }
    }
    visitHTMLAttributeNode(node) {
        if (node.name) {
            this.visit(node.name);
        }
        if (node.equals) {
            this.write(node.equals.value);
        }
        if (node.equals && node.value) {
            this.visit(node.value);
        }
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        if (node.quoted && node.open_quote) {
            this.write(node.open_quote.value);
        }
        this.visitChildNodes(node);
        if (node.quoted && node.close_quote) {
            this.write(node.close_quote.value);
        }
    }
    visitHTMLCommentNode(node) {
        if (node.comment_start) {
            this.write(node.comment_start.value);
        }
        this.visitChildNodes(node);
        if (node.comment_end) {
            this.write(node.comment_end.value);
        }
    }
    visitHTMLDoctypeNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitXMLDeclarationNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitCDATANode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitERBContentNode(node) {
        this.printERBNode(node);
    }
    visitERBIfNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.rescue_clause) {
            this.visit(node.rescue_clause);
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.ensure_clause) {
            this.visit(node.ensure_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    /**
     * Print ERB node tags and content
     */
    printERBNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.content) {
            this.write(node.content.value);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
}

({
    ...DEFAULT_PRINT_OPTIONS});

/**
 * Rewrite an AST Node using the provided rewriters
 *
 * This is the main rewrite function that operates on AST nodes.
 * For string input, use `rewriteString()` instead.
 *
 * @example
 * ```typescript
 * import { Herb } from '@herb-tools/node-wasm'
 * import { rewrite } from '@herb-tools/rewriter'
 * import { tailwindClassSorter } from '@herb-tools/rewriter/loader'
 *
 * await Herb.load()
 *
 * const template = '<div class="text-red-500 p-4 mt-2"></div>'
 * const parseResult = Herb.parse(template)
 * const { output, node } = rewrite(parseResult.value, [tailwindClassSorter()])
 * ```
 *
 * @param node - The AST Node to rewrite
 * @param rewriters - Array of rewriter instances to apply
 * @param options - Optional configuration for the rewrite operation
 * @returns Object containing the rewritten string and Node
 */
function rewrite(node, rewriters, options = {}) {
    const { baseDir = process.cwd(), filePath } = options;
    const context = { baseDir, filePath };
    let currentNode = node;
    const astRewriters = rewriters.filter(rewriter => rewriter instanceof ASTRewriter);
    const stringRewriters = rewriters.filter(rewriter => rewriter instanceof StringRewriter);
    for (const rewriter of astRewriters) {
        try {
            currentNode = rewriter.rewrite(currentNode, context);
        }
        catch (error) {
            console.error(`AST rewriter "${rewriter.name}" failed:`, error);
        }
    }
    let result = IdentityPrinter.print(currentNode);
    for (const rewriter of stringRewriters) {
        try {
            result = rewriter.rewrite(result, context);
        }
        catch (error) {
            console.error(`String rewriter "${rewriter.name}" failed:`, error);
        }
    }
    return {
        output: result,
        node: currentNode
    };
}
/**
 * Rewrite an HTML+ERB template string
 *
 * Convenience wrapper around `rewrite()` that parses the string first.
 *
 * @example
 * ```typescript
 * import { Herb } from '@herb-tools/node-wasm'
 * import { rewriteString } from '@herb-tools/rewriter'
 * import { tailwindClassSorter } from '@herb-tools/rewriter/loader'
 *
 * await Herb.load()
 *
 * const template = '<div class="text-red-500 p-4 mt-2"></div>'
 * const output = rewriteString(Herb, template, [tailwindClassSorter()])
 * // output: '<div class="mt-2 p-4 text-red-500"></div>'
 * ```
 *
 * @param herb - The Herb backend instance for parsing
 * @param template - The HTML+ERB template string to rewrite
 * @param rewriters - Array of rewriter instances to apply
 * @param options - Optional configuration for the rewrite operation
 * @returns The rewritten template string
 */
function rewriteString(herb, template, rewriters, options = {}) {
    const parseResult = herb.parse(template, { track_whitespace: true });
    if (parseResult.failed) {
        return template;
    }
    const { output } = rewrite(parseResult.value, rewriters, options);
    return output;
}

exports.ASTRewriter = ASTRewriter;
exports.StringRewriter = StringRewriter;
exports.asMutable = asMutable;
exports.isASTRewriterClass = isASTRewriterClass;
exports.isRewriterClass = isRewriterClass;
exports.isStringRewriterClass = isStringRewriterClass;
exports.rewrite = rewrite;
exports.rewriteString = rewriteString;
//# sourceMappingURL=index.cjs.map
